<!doctype html>
<html lang=en-US>
<meta charset=utf8>
<meta name="viewport" content="width=device-width, initial-scale=1"><title>ProseMirror API 参考手册</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel=stylesheet href=/css/site.css>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-79359216-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-79359216-2');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5486286026923411"
     crossorigin="anonymous"></script>
<script async src="https://fundingchoicesmessages.google.com/i/pub-5486286026923411?ers=1" nonce="wfbcB_BXTEc885VHCZEEPg"></script><script nonce="wfbcB_BXTEc885VHCZEEPg">(function() {function signalGooglefcPresent() {if (!window.frames['googlefcPresent']) {if (document.body) {const iframe = document.createElement('iframe'); iframe.style = 'width: 0; height: 0; border: none; z-index: -1000; left: -1000px; top: -1000px;'; iframe.style.display = 'none'; iframe.name = 'googlefcPresent'; document.body.appendChild(iframe);} else {setTimeout(signalGooglefcPresent, 0);}}}signalGooglefcPresent();})();</script>

<header >
  <nav>
    <a class=logo href="/">ProseMirror</a>
    <div class=navlinks><a class=toc-toggle>导航</a><a href="/examples/" >示例</a>
      <a href="/docs/" class=active>文档</a>
      <a href="https://discuss.prosemirror.net/">论坛</a>
      <a href="https://github.com/prosemirror">GitHub</a>
      <a href="https://twitter.com/prosemirror">Twitter</a>
      <a href="https://github.com/Xheldon">译者</a>
    </div>
  </nav></header><nav id=toc>
    <ul><li><a href="#top.intro">Intro</a></li><li><a href="#state">prosemirror-state</a><ul><li><a href="#state.Editor_State">Editor State</a></li><li><a href="#state.Selection">Selection</a></li><li><a href="#state.Plugin_System">Plugin System</a></li></ul></li><li><a href="#view">prosemirror-view</a><ul><li><a href="#view.Props">Props</a></li><li><a href="#view.Decorations">Decorations</a></li></ul></li><li><a href="#model">prosemirror-model</a><ul><li><a href="#model.Document_Structure">Document Structure</a></li><li><a href="#model.Resolved_Positions">Resolved Positions</a></li><li><a href="#model.Document_Schema">Document Schema</a></li><li><a href="#model.DOM_Representation">DOM Representation</a></li></ul></li><li><a href="#transform">prosemirror-transform</a><ul><li><a href="#transform.Steps">Steps</a></li><li><a href="#transform.Position_Mapping">Position Mapping</a></li><li><a href="#transform.Document_transforms">Document transforms</a></li></ul></li><li><a href="#commands">prosemirror-commands</a></li><li><a href="#history">prosemirror-history</a></li><li><a href="#collab">prosemirror-collab</a></li><li><a href="#keymap">prosemirror-keymap</a></li><li><a href="#inputrules">prosemirror-inputrules</a></li><li><a href="#gapcursor">prosemirror-gapcursor</a></li><li><a href="#schema-basic">prosemirror-schema-basic</a></li><li><a href="#schema-list">prosemirror-schema-list</a></li></ul>
  </nav>
  <script>
addEventListener("load", function() {
  var toc = document.querySelector("nav#toc")
  var state = "top"
  var footer = document.querySelector("footer"), header = document.querySelector("header")
  function align() {
    var tocRect = toc.getBoundingClientRect(),
        headRect = header.getBoundingClientRect(),
        footRect = footer.getBoundingClientRect()
    if (state == "top" && headRect.bottom <= -40 ||
        state == "bottom" && toc.getBoundingClientRect().top >= 0) {
      toc.style.top = "0"
      toc.style.bottom = ""
      toc.classList.add("fixed")
      state = "fixed"
    } else if (state == "fixed" && headRect.bottom > -40) {
      toc.style.bottom = toc.style.top = ""
      toc.classList.remove("fixed")
      state = "top"
    } else if (state == "fixed" && footRect.top <tocRect.bottom) {
      toc.style.bottom = footRect.height + "px"
      toc.style.top = "auto"
      toc.classList.remove("fixed")
      state = "bottom"
    }
  }
  if (document.body.scrollHeight - header.offsetHeight > innerHeight) {
    align()
    addEventListener("scroll", align)
  }
  document.querySelector(".toc-toggle").addEventListener("click", function() {
    toc.classList.toggle("open")
  })
})
</script><article><section id="part_top">
  <h2 id="top.intro">API 参考手册</h2><blockquote>
<p>本文档手册上次更新日期为：<strong>2021年6月13日</strong>，文档更新总览请查看：<a href="https://github.com/xheldon-prosemirror/prosemirror/blob/master/X_CHANGELOG.md">X_CHANGELOG</a>。</p>
</blockquote>
<blockquote>
<p>注：自 <a href="https://twitter.com/ProseMirror/status/1310952477265727495">2020年9月29日全部翻译完成</a> 以来，之后的每一次对应模块的更新都是与上游仓库进行合并，以保持翻译文档的最新版本，因此可能存在版本落后的问题，如果发现版本落后，请查看 <a href="https://prosemirror.net/docs/ref/">原始文档</a>，同时在 <a href="https://t.me/xheldon_tech">电报群</a> 里找我合并一下上游仓库，我会尽快更新中文版。</p>
</blockquote>
<b>
译者前言：
</b><ol><b>
<li>鼠标悬浮在中文上会出现英文原文，方便读者在觉得翻译质量不行的时候直接查看原文。</li>
<li>专有名词不翻译，如 Schema、State、View 等，以让读者能在阅读源码或者在社区提问的时候对应上相应的概念。</li>
<li>因为有些接口需要上下文，因此译者的增加了注释以对此进行额外的说明，以灰色背景块显示出来，代表了译者对某个接口的理解。</li>
<li>本文档与 <a href="https://prosemirror.net/docs/ref/">官网</a> 保持同步（译者不定期检查原仓库，然后 Merge 最新的代码，最后翻译完成后更新本文档）。</li>
</b><li><b>本文档翻译工作是作者业余时间完成，你如果觉得有帮助可以 <a href="https://www.xheldon.com/donate/">赏杯咖啡钱</a> 。
</b></li>
</ol>
<hr>

<p data-en="This is the reference manual for the
ProseMirror rich text editor. It lists and
describes the full public API exported by the library. For more
introductory material, please see the guide." lang="cn">本页面是富文本编辑器 <a href="https://prosemirror.xheldon.com">ProseMirror</a> 的 API 手册，它列出和描述了该库导出的全部接口。想了解更多关于它的介绍，请访问：<a href="/docs/guide/">指南</a></p>

<p data-en="ProseMirror is structured as a number of separate modules. This
reference manual describes the exported API per module. If you want to
use something from the prosemirror-state module, for
example, you can import it like this:" lang="cn">ProseMirror 由多个单独的模块构成。这个手册描述了每个模块导出的 API。例如，如果你想使用 <a href="#state"><code>prosemirror-state</code></a> 模块，你可以像下面这样导入即可：</p>
<pre><code class="language-javascript"><span class="hl-keyword">var</span> <span class="hl-def">EditorState</span> <span class="hl-operator">=</span> <span class="hl-variable">require</span>(<span class="hl-string">"prosemirror-state"</span>).<span class="hl-property">EditorState</span>
<span class="hl-keyword">var</span> <span class="hl-def">state</span> <span class="hl-operator">=</span> <span class="hl-variable">EditorState</span>.<span class="hl-property">create</span>({<span class="hl-property">schema</span>: <span class="hl-variable">mySchema</span>})
</code></pre>

<p data-en="Or, using ES6 syntax:" lang="cn">或者使用 ES6 的语法：</p>
<pre><code class="language-javascript"><span class="hl-keyword">import</span> {<span class="hl-def">EditorState</span>} <span class="hl-keyword">from</span> <span class="hl-string">"prosemirror-state"</span>
<span class="hl-keyword">let</span> <span class="hl-def">state</span> <span class="hl-operator">=</span> <span class="hl-variable">EditorState</span>.<span class="hl-property">create</span>({<span class="hl-property">schema</span>: <span class="hl-variable">mySchema</span>})
</code></pre>
</section><section id=part_state>
    <h2 class=module id=state>
      <a href="#state">prosemirror-state <span class=kind>module</span></a>
    </h2>
<p data-en="This module implements the state object of a ProseMirror editor, along
with the representation of the selection and the plugin abstraction." lang="cn">本模块实现了 ProseMirror 编辑器的 state 对象，以及关于选区 selection 和 插件 plugin 的抽象。</p>
<h3 id="state.Editor_State"><a href="#state.Editor_State">Editor State</a></h3>

<p data-en="ProseMirror keeps all editor state (the things, basically, that would
be required to create an editor just like the current one) in a single
object. That object is updated (creating a new
state) by applying transactions to it." lang="cn">ProseMirror 使用一个单独的大 <a href="#state.EditorState">对象</a> 来保持对编辑器所有 state 的引用（基本上来说，需要创建一个与当前编辑器相同的编辑器）。
这个对象通过应用一个 <a href="#state.Transaction">transactions</a> 来更新（即创建一个新的 state）。</p>
<p type="comment"><span>注: </span>transactions 按惯例在写代码的或者看源码的时候被缩写成 <code>tr</code></p>
<h4 id="state.EditorState">
  <a href="#state.EditorState">EditorState</a> <span class="kind">class</span></h4>
<p data-en="The state of a ProseMirror editor is represented by an object
of this type. A state is a persistent data structure—it isn't
updated, but rather a new state value is computed from an old one
using the apply method." lang="cn">ProseMirror 编辑器状态由此对象表示。一个 state 是一个持久化的数据结构--它本身并不更新，旧的 state 通过 <a href="#state.EditorState.apply"><code>apply</code></a> 方法产生一个新的 state。</p>

<p data-en="A state holds a number of built-in fields, and plugins can
define additional fields." lang="cn">一个 state 有很多内建的字段，同时可以通过 plugins 来 <a href="#state.PluginSpec.state">定义</a> 额外的字段。</p>
<dl><dt id="state.EditorState.doc"><code><strong><a href="#state.EditorState.doc">doc</a></strong>: <a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The current document." lang="cn">当前文档</p>
</dd><dt id="state.EditorState.selection"><code><strong><a href="#state.EditorState.selection">selection</a></strong>: <a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="The selection." lang="cn">当前选区。</p>
</dd><dt id="state.EditorState.storedMarks"><code><strong><a href="#state.EditorState.storedMarks">storedMarks</a></strong>: ?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="A set of marks to apply to the next input. Will be null when
no explicit marks have been set." lang="cn">即将要应用到下一次输入的 marks。如果没有显式的设置 marks，此字段将会是 null。</p>
</dd><dt id="state.EditorState.schema"><code><strong><a href="#state.EditorState.schema">schema</a></strong>: <a href="#model.Schema"><span class="type">Schema</span></a></code></dt>

<dd>
<p data-en="The schema of the state's document." lang="cn">state 所表示的文档的 schema。</p>
</dd><dt id="state.EditorState.plugins"><code><strong><a href="#state.EditorState.plugins">plugins</a></strong>: [<a href="#state.Plugin"><span class="type">Plugin</span></a>]</code></dt>

<dd>
<p data-en="The plugins that are active in this state." lang="cn">在当前 state 中激活的 plugins。</p>
</dd><dt id="state.EditorState.apply"><code><strong><a href="#state.EditorState.apply">apply</a></strong>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>) →&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a></code></dt>

<dd>
<p data-en="Apply the given transaction to produce a new state." lang="cn">对旧的 state 应用给定的 transaction 以产生一个新的 state。</p>
</dd><dt id="state.EditorState.applyTransaction"><code><strong><a href="#state.EditorState.applyTransaction">applyTransaction</a></strong>(<span class="param">rootTr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>) →&nbsp;{<span class="prop">state:&nbsp;</span><a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="prop">transactions:&nbsp;</span>[<a href="#state.Transaction"><span class="type">Transaction</span></a>]}</code></dt>

<dd>
<p data-en="Verbose variant of apply that
returns the precise transactions that were applied (which might
be influenced by the transaction
hooks of
plugins) along with the new state." lang="cn"><a href="#state.EditorState.apply"><code>apply</code></a> 的复杂版。该接口返回将应用到旧 state 以产生新 state 的每一个 transactions
（其返回解构可能被插件的 <a href="#state.PluginSpec.filterTransaction">transaction hooks</a> 影响。）</p>
</dd><dt id="state.EditorState.tr"><code><strong><a href="#state.EditorState.tr">tr</a></strong>: <a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Start a transaction from this state." lang="cn">从当前 state 生成一个新的 <a href="#state.Transaction">transaction</a> 以对当前 state 进行修改。</p>
<p type="comment"><span>注: </span>该 transaction 是一个 getter 函数，每次调用都会 new 一个新的 transaction。</p>
</dd><dt id="state.EditorState.reconfigure"><code><strong><a href="#state.EditorState.reconfigure">reconfigure</a></strong>(<span class="param">config:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a></code></dt>

<dd>
<p data-en="Create a new state based on this one, but with an adjusted set of
active plugins. State fields that exist in both sets of plugins
are kept unchanged. Those that no longer exist are dropped, and
those that are new are initialized using their
init method, passing in the new
configuration object.." lang="cn">基于当前的 state 新建一个新的 state，只是新的 state 的中的字段会由传入的 plugins 重新配置。新旧两组 plugins 中的 state 字段中都存在的字段保持不变。
（相比于旧的 plugins 中）不再存在的字段将会被丢弃，新增的字段将会使用 plugin 的 state 对象的 <a href="#state.StateField.init"><code>init</code></a> 方法进行初始化后作为新的 state 字段。</p>
<p type="comment"><span>注: </span>plugin 配置对象有一个 state 字段，其有两个方法，一个是 init 用来初始化 state；一个是 apply，用来决定如何更新 state。此 create 方法对于新增的 plugin 会调用其 state 的 init 方法进行初始化，以生成编辑器的 state。</p>
<dl><dt id="state.EditorState.reconfigure^config"><code><strong><a href="#state.EditorState.reconfigure^config">config</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="configuration options" lang="cn">配置选项，之前还有一个 schema 属性可以配置，后来没；之前返回的 Plugin 是可选的，即可能什么也不返回，后来去掉了可选符号 <code>?</code> 不知道什么原因，有兴趣的可以看下变更历史。</p>
<dl><dt id="state.EditorState.reconfigure^config.plugins"><code><strong><a href="#state.EditorState.reconfigure^config.plugins">plugins</a></strong>: [<a href="#state.Plugin"><span class="type">Plugin</span></a>]</code></dt>

<dd>
<p data-en="New set of active plugins." lang="cn">新的激活的插件集合。</p>
<p type="comment"><span>注: </span>plugins 上的 state 构成新的编辑器的 state。</p>
</dd></dl></dd></dl></dd><dt id="state.EditorState.toJSON"><code><strong><a href="#state.EditorState.toJSON">toJSON</a></strong>(<span class="param">pluginFields:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#state.Plugin"><span class="type">Plugin</span></a>&gt; | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Serialize this state to JSON. If you want to serialize the state
of plugins, pass an object mapping property names to use in the
resulting JSON object to plugin objects. The argument may also be
a string or number, in which case it is ignored, to support the
way JSON.stringify calls toString methods." lang="cn">将 state 对象序列化成 JSON 对象。如果你想序列化 plugin 的 state，则需要传递一个有着属性名-插件的映射关系的对象，该对象的属性名就会出现在返回值结果对象中。
参数也可以是字符串或者数字，但这种情况下参数会被忽略，以支持以 <code>JSON.stringify</code> 的方式调用 <code>toString</code> 方法。</p>
<p type="comment"><span>注: </span>如果想序列化 plugin 的 state，需要 plugin 的 state 对象有提供 toJSON 方法，该方法的参数是 plugin 的 key。<code>doc</code> 和 <code>selection</code> 是保留字段，不能作为参数对象的属性名。</p>
</dd><dt id="state.EditorState^create"><code>static <strong><a href="#state.EditorState^create">create</a></strong>(<span class="param">config:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a></code></dt>

<dd>
<p data-en="Create a new state." lang="cn">创建一个新的 state。</p>
<dl><dt id="state.EditorState^create^config"><code><strong><a href="#state.EditorState^create^config">config</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Configuration options. Must contain schema or doc (or both)." lang="cn">state 配置选项。必须包含 <code>schema</code> 和 <code>doc</code> （或者两者都有）。</p>
<dl><dt id="state.EditorState^create^config.schema"><code><strong><a href="#state.EditorState^create^config.schema">schema</a></strong>: ?⁠<a href="#model.Schema"><span class="type">Schema</span></a></code></dt>

<dd>
<p data-en="The schema to use (only relevant if no doc is specified)." lang="cn">当前编辑器所使用的 schema。</p>
</dd><dl><dt id="state.EditorState^create^config.doc"><code><strong><a href="#state.EditorState^create^config.doc">doc</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The starting document." lang="cn">初始文档。</p>
</dd><dl><dt id="state.EditorState^create^config.selection"><code><strong><a href="#state.EditorState^create^config.selection">selection</a></strong>: ?⁠<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="A valid selection in the document." lang="cn">文档中可用的选区。</p>
</dd><dl><dt id="state.EditorState^create^config.storedMarks"><code><strong><a href="#state.EditorState^create^config.storedMarks">storedMarks</a></strong>: ?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="The initial set of stored marks." lang="cn"><a href="#state.EditorState.storedMarks">stored marks</a> 的初始集合。</p>
</dd><dl><dt id="state.EditorState^create^config.plugins"><code><strong><a href="#state.EditorState^create^config.plugins">plugins</a></strong>: ?⁠[<a href="#state.Plugin"><span class="type">Plugin</span></a>]</code></dt>

<dd>
<p data-en="The plugins that should be active in this state." lang="cn">state 中激活的 plugins。</p>
</dd></dl></dl></dl></dl></dl></dd></dl></dd><dt id="state.EditorState^fromJSON"><code>static <strong><a href="#state.EditorState^fromJSON">fromJSON</a></strong>(<span class="param">config:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">json:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">pluginFields:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#state.Plugin"><span class="type">Plugin</span></a>&gt;) →&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a></code></dt>

<dd>
<p data-en="Deserialize a JSON representation of a state. config should
have at least a schema field, and should contain array of
plugins to initialize the state with. pluginFields can be used
to deserialize the state of plugins, by associating plugin
instances with the property names they use in the JSON object." lang="cn">反序列化一个 state 的 JSON 表示。<code>config</code> 至少应该有一个 <code>schema</code> 字段，并且应该包含用来初始化 state 的 plugin 数组。
<code>pluginField</code> 参数通过在 JSON 对象中的属性名与 plugin 实例对应的方式来反序列化 plugin 的 state。</p>
<p type="comment"><span>注: </span><code>pluginFields</code> 中的属性名如果对应到了某个 plugin 的 key（string），则会调用对应 plugin 的 state 的 fromJSON 方法，
如果没有对应到任一个 plugin 的 key，则会直接调 plugin 的 state 的 init 方法，前者参数是 config、插件对应的 json 和根据 config 生成的编辑器 state；后者参数是 config 和根据 config 生成的编辑器的 state。</p>
<dl><dt id="state.EditorState^fromJSON^config"><code><strong><a href="#state.EditorState^fromJSON^config">config</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="configuration options" lang="cn">配置选项</p>
<dl><dt id="state.EditorState^fromJSON^config.schema"><code><strong><a href="#state.EditorState^fromJSON^config.schema">schema</a></strong>: <a href="#model.Schema"><span class="type">Schema</span></a></code></dt>

<dd>
<p data-en="The schema to use." lang="cn">反序列化用到的 schema。</p>
</dd><dl><dt id="state.EditorState^fromJSON^config.plugins"><code><strong><a href="#state.EditorState^fromJSON^config.plugins">plugins</a></strong>: ?⁠[<a href="#state.Plugin"><span class="type">Plugin</span></a>]</code></dt>

<dd>
<p data-en="The set of active plugins." lang="cn">激活插件的集合。</p>
</dd></dl></dl></dd></dl></dd></dl>
<h4 id="state.Transaction">
  <a href="#state.Transaction">Transaction</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#transform.Transform"><span class="type">Transform</span></a></code></span></h4>
<p data-en="An editor state transaction, which can be applied to a state to
create an updated state. Use
EditorState.tr to create an instance." lang="cn">一个编辑器 state 的 transaction 可以被用来应用到 state 以创建一个更新的 state。
使用 <a href="#state.EditorState.tr"><code>EditorState.tr</code></a> 来创建一个 transaction 实例。</p>
<p type="comment"><span>注: </span>EditorState.tr 是一个 getter 函数，每次调用都会 new 一个新的。</p>

<p data-en="Transactions track changes to the document (they are a subclass of
Transform), but also other state changes,
like selection updates and adjustments of the set of stored
marks. In addition, you can store
metadata properties in a transaction, which are extra pieces of
information that client code or plugins can use to describe what a
transacion represents, so that they can update their own
state accordingly." lang="cn">Transactions （它是 <a href="#transform.Transform"><code>Transform</code></a> 的子类）不仅会追踪对文档的修改，还能追踪 state 的其他变化，
比如选区更新以及 <a href="#state.EditorState.storedMarks">storedmarks</a> 的调整。此外，你还可以在 transaction 中储存 metadata 信息，
metadata 信息是一种很有用的信息形式以告诉客户端代码或者该 transaction 所代表的含义，然后它们以此来相应的更新它们 <a href="#state.StateField">自己的 state</a>。</p>

<p data-en="The editor view uses a few metadata properties:
it will attach a property &quot;pointer&quot; with the value true to
selection transactions directly caused by mouse or touch input, and
a &quot;uiEvent&quot; property of that may be &quot;paste&quot;, &quot;cut&quot;, or &quot;drop&quot;." lang="cn"><a href="#view.EditorView">编辑器的 view</a> 使用下面几个 metadata 属性：它会在 tr 上附加上 <code>"pointer"</code> 属性，值 <code>true</code> 表示由鼠标或者触摸点击触发的选区 transaction，
以及一个 <code>"uiEvent"</code> 属性，值可能是 <code>"paste"</code>, <code>"cut"</code> 或者 <code>"drop"</code>。</p>
<dl><dt id="state.Transaction.time"><code><strong><a href="#state.Transaction.time">time</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The timestamp associated with this transaction, in the same
format as Date.now()." lang="cn">与当前 transaction 关联的时间戳，与 <code>Date.now()</code> 格式相同。</p>
</dd><dt id="state.Transaction.storedMarks"><code><strong><a href="#state.Transaction.storedMarks">storedMarks</a></strong>: ?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="The stored marks set by this transaction, if any." lang="cn">当前 transaction 设置的 stored marks，如果有的话。</p>
</dd><dt id="state.Transaction.selection"><code><strong><a href="#state.Transaction.selection">selection</a></strong>: <a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="The transaction's current selection. This defaults to the editor
selection mapped through the steps in the
transaction, but can be overwritten with
setSelection." lang="cn">该 transaction 的选区。默认是编辑器当前选区经过该 transaction <a href="#state.Selection.map">mapped</a> 后的选区，不过也会被 <a href="#state.Transaction.setSelection"><code>setSelection</code></a> 方法给手动设置。</p>
</dd><dt id="state.Transaction.setSelection"><code><strong><a href="#state.Transaction.setSelection">setSelection</a></strong>(<span class="param">selection:</span>&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Update the transaction's current selection. Will determine the
selection that the editor gets when the transaction is applied." lang="cn">更新当前 transaction 的选区。其会决定 transaction 应用后编辑器的选区。</p>
</dd><dt id="state.Transaction.selectionSet"><code><strong><a href="#state.Transaction.selectionSet">selectionSet</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Whether the selection was explicitly updated by this transaction." lang="cn">选区是否被该 transaction 显式更新过。</p>
<p type="comment"><span>注: </span>即在当前 transaction 中是否显式调用过 setSelection，一个 tr 在应用到 state 之前会 <code>流过</code> 所有的 plugin 的 apply 方法，因此这对于判断其他插件是否显式设置过选区很有用。</p>
</dd><dt id="state.Transaction.setStoredMarks"><code><strong><a href="#state.Transaction.setStoredMarks">setStoredMarks</a></strong>(<span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Set the current stored marks." lang="cn">设置 stored marks。</p>
</dd><dt id="state.Transaction.ensureMarks"><code><strong><a href="#state.Transaction.ensureMarks">ensureMarks</a></strong>(<span class="param">marks:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Make sure the current stored marks or, if that is null, the marks
at the selection, match the given set of marks. Does nothing if
this is already the case." lang="cn">确保 transaction 设置的 stored marks 或者如果 transaction 没有设置 stored marks 的话，确保光标位置的 marks，与参数给定的 marks 一致。
如果一致的话什么也不做。</p>
<p type="comment"><span>注: </span>如果不一致的话，就让它们一致--这也是「确保」的含义。</p>
</dd><dt id="state.Transaction.addStoredMark"><code><strong><a href="#state.Transaction.addStoredMark">addStoredMark</a></strong>(<span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Add a mark to the set of stored marks." lang="cn">在已经设置的 stored marks 集合中增加一个 mark。</p>
</dd><dt id="state.Transaction.removeStoredMark"><code><strong><a href="#state.Transaction.removeStoredMark">removeStoredMark</a></strong>(<span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a> | <a href="#model.MarkType"><span class="type">MarkType</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Remove a mark or mark type from the set of stored marks." lang="cn">在已经设置的 stored marks 集合中移除一个 mark 或者移除一种 mark。</p>
</dd><dt id="state.Transaction.storedMarksSet"><code><strong><a href="#state.Transaction.storedMarksSet">storedMarksSet</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Whether the stored marks were explicitly set for this transaction." lang="cn">当前 transaction 是否显式设置了 stored marks。</p>
</dd><dt id="state.Transaction.setTime"><code><strong><a href="#state.Transaction.setTime">setTime</a></strong>(<span class="param">time:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Update the timestamp for the transaction." lang="cn">更新该 transaction 的时间戳。</p>
</dd><dt id="state.Transaction.replaceSelection"><code><strong><a href="#state.Transaction.replaceSelection">replaceSelection</a></strong>(<span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Replace the current selection with the given slice." lang="cn">用给定的 slice 替换当前选区。</p>
</dd><dt id="state.Transaction.replaceSelectionWith"><code><strong><a href="#state.Transaction.replaceSelectionWith">replaceSelectionWith</a></strong>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">inheritMarks:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Replace the selection with the given node. When inheritMarks is
true and the content is inline, it inherits the marks from the
place where it is inserted." lang="cn">用给定的 node 替换当前选区。如果 <code>inheritMarks</code> 是 true 并且 node 的内容是 inline 的话，插入的内容将会继承插入点位置的 marks。</p>
</dd><dt id="state.Transaction.deleteSelection"><code><strong><a href="#state.Transaction.deleteSelection">deleteSelection</a></strong>() →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Delete the selection." lang="cn">删除选区。</p>
<p type="comment"><span>注: </span>选区被删除了，其内容也一起被删除。</p>
</dd><dt id="state.Transaction.insertText"><code><strong><a href="#state.Transaction.insertText">insertText</a></strong>(<span class="param">text:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">from:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = from</span>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Replace the given range, or the selection if no range is given,
with a text node containing the given string." lang="cn">用包含给定文本的文本节点替换给定的 range，如果没有给定 range 的话则替换选区。</p>
<p type="comment"><span>注: </span>range 就是用 from 和 to 表示的一个范围。</p>
</dd><dt id="state.Transaction.setMeta"><code><strong><a href="#state.Transaction.setMeta">setMeta</a></strong>(<span class="param">key:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a> | <a href="#state.Plugin"><span class="type">Plugin</span></a> | <a href="#state.PluginKey"><span class="type">PluginKey</span></a>, <span class="param">value:</span>&nbsp;<span class="prim">any</span>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Store a metadata property in this transaction, keyed either by
name or by plugin." lang="cn">在该 transaction 上储存一个 metadata 信息，可以以 name 或者 plugin 来区分。</p>
<p type="comment"><span>注: </span>因为一个 transaction 可能会被不同的 plugin 设置不同的 metadata 信息，因此需要区分。key 可以传 PluginKey，或者简单一个字符串。</p>
</dd><dt id="state.Transaction.getMeta"><code><strong><a href="#state.Transaction.getMeta">getMeta</a></strong>(<span class="param">key:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a> | <a href="#state.Plugin"><span class="type">Plugin</span></a> | <a href="#state.PluginKey"><span class="type">PluginKey</span></a>) →&nbsp;<span class="prim">any</span></code></dt>

<dd>
<p data-en="Retrieve a metadata property for a given name or plugin." lang="cn">用给定的 name 或者 plugin key 来获取设置的 metadata 信息。</p>
<p type="comment"><span>注: </span>给定的 name 或者 plugin key 就是上面 setMeta 设置的 key，获取的就是 setMeta 设置的 value。</p>
</dd><dt id="state.Transaction.isGeneric"><code><strong><a href="#state.Transaction.isGeneric">isGeneric</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Returns true if this transaction doesn't contain any metadata,
and can thus safely be extended." lang="cn">如果该 transaction 没有包含任何 metadata 信息则返回 true，如此以来就可以被安全的扩展。</p>
<p type="comment"><span>注: </span>有些场景需要对 transaction 做一些额外处理，如合并多个 step，此时如果某个 step 有 metadata 信息，则说明该 step 对某个 plugin 可能有其他的用途，就不能简单的合并 step。</p>
</dd><dt id="state.Transaction.scrollIntoView"><code><strong><a href="#state.Transaction.scrollIntoView">scrollIntoView</a></strong>() →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Indicate that the editor should scroll the selection into view
when updated to the state produced by this transaction." lang="cn">当该 transaction 更新完 state 后，让编辑器将选区滚动到视图窗口之内。</p>
<p type="comment"><span>注: </span>类似 chrome devtools 中，Elements 下对某个元素右键的 「Scroll into view」</p>
</dd></dl>
<h3 id="state.Selection"><a href="#state.Selection">Selection</a></h3>

<p data-en="A ProseMirror selection can be one of several types. This module
defines types for classical text selections
(of which cursors are a special case) and node
selections, where a specific document node is
selected. It is possible to extend the editor with custom selection
types." lang="cn">一个 ProseMirror selection 可以是多种不同类型的选区。这个模块定义了一个基础文本选区 <a href="#state.TextSelection">text selections</a>（当然，光标是其中的一个特殊状态，即 selection 的内容为空）
和节点选区 <a href="#state.NodeSelection"><em>node</em> selections</a> ，表示一个文档节点被选中。可以通过扩展 selection 父类来实现自定义的 selection 类型。</p>
<h4 id="state.Selection">
  <a href="#state.Selection">Selection</a> <span class="kind">class</span></h4>
<p data-en="Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly." lang="cn">编辑器选区的超类。所有的选区类型都扩展自它。不应该直接实例化。</p>
<dl><dt id="state.Selection.constructor"><code>new <strong><a href="#state.Selection.constructor">Selection</a></strong>(<span class="param">$anchor:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">$head:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">ranges:</span>&nbsp;?⁠[<a href="#state.SelectionRange"><span class="type">SelectionRange</span></a>])</code></dt>

<dd>
<p data-en="Initialize a selection with the head and anchor and ranges. If no
ranges are given, constructs a single range across $anchor and
$head." lang="cn">用给定的 head 和 anchor 和 ranges 初始化一个选区。如果没有 ranges 给定，则构造一个包含 <code>$anchor</code> 和 <code>$head</code> 位置的 range。</p>
</dd><dt id="state.Selection.ranges"><code><strong><a href="#state.Selection.ranges">ranges</a></strong>: [<a href="#state.SelectionRange"><span class="type">SelectionRange</span></a>]</code></dt>

<dd>
<p data-en="The ranges covered by the selection." lang="cn">选区覆盖到的 ranges。</p>
</dd><dt id="state.Selection.$anchor"><code><strong><a href="#state.Selection.$anchor">$anchor</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="The resolved anchor of the selection (the side that stays in
place when the selection is modified)." lang="cn">选区 resolved 过的 anchor 位置（即当选区变化的时候，其不动的一侧）。</p>
</dd><dt id="state.Selection.$head"><code><strong><a href="#state.Selection.$head">$head</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="The resolved head of the selection (the side that moves when
the selection is modified)." lang="cn">选区 resolved 过的 head 位置（即当选区变化时，移动的一侧）。</p>
<p type="comment"><span>注: </span>「选区变化时」可能是用户造成的，如用户用鼠标从左到右选择，则选区起始（左侧）是 anchor，即「锚点」；选区右侧（鼠标所在位置）是 head，即动点。</p>
</dd><dt id="state.Selection.anchor"><code><strong><a href="#state.Selection.anchor">anchor</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The selection's anchor, as an unresolved position." lang="cn">选区的 anchor 的位置。</p>
</dd><dt id="state.Selection.head"><code><strong><a href="#state.Selection.head">head</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The selection's head." lang="cn">选区的 head 的位置。</p>
</dd><dt id="state.Selection.from"><code><strong><a href="#state.Selection.from">from</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The lower bound of the selection's main range." lang="cn">选区位置较小一侧的位置。</p>
<p type="comment"><span>注: </span>无论选区是如何选的，一般情况下 from 是选区的左侧起始位置。</p>
</dd><dt id="state.Selection.to"><code><strong><a href="#state.Selection.to">to</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The upper bound of the selection's main range." lang="cn">选区位置较大的一侧。</p>
<p type="comment"><span>注: </span>无论选区是如何选的，一般情况下 to 是选区的右侧结束位置。</p>
<p type="comment"><span>注: </span>均不考虑多个选区的情况，而且似乎 chrome 等浏览器也不支持多选区，只是在一些编辑器中为了编辑方便，有多个选区的存在。</p>
</dd><dt id="state.Selection.$from"><code><strong><a href="#state.Selection.$from">$from</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="The resolved lower  bound of the selection's main range." lang="cn">resolve 过的选区的位置较小的一侧。</p>
</dd><dt id="state.Selection.$to"><code><strong><a href="#state.Selection.$to">$to</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="The resolved upper bound of the selection's main range." lang="cn">resolve 过的选区的位置较大的一侧。</p>
</dd><dt id="state.Selection.empty"><code><strong><a href="#state.Selection.empty">empty</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Indicates whether the selection contains any content." lang="cn">表示选区是否包含任何内容。</p>
</dd><dt id="state.Selection.eq"><code><strong><a href="#state.Selection.eq">eq</a></strong>(<a href="#state.Selection"><span class="type">Selection</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether the selection is the same as another selection." lang="cn">测试当前选区与另一个选区是否相等。</p>
</dd><dt id="state.Selection.map"><code><strong><a href="#state.Selection.map">map</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">mapping:</span>&nbsp;<a href="#transform.Mappable"><span class="type">Mappable</span></a>) →&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Map this selection through a mappable thing. doc
should be the new document to which we are mapping." lang="cn">通过一个 <a href="#transform.Mappable">mappable</a> 对象来 map 当前选区。 <code>doc</code> 参数应该是我们正在 mapping 的新的 document。</p>
<p type="comment"><span>注: </span>一般通过 <code>tr.doc</code> 拿到将要 mapping 到的新的 document。</p>
</dd><dt id="state.Selection.content"><code><strong><a href="#state.Selection.content">content</a></strong>() →&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="Get the content of this selection as a slice." lang="cn">获取选区内容的 slice 形式。</p>
</dd><dt id="state.Selection.replace"><code><strong><a href="#state.Selection.replace">replace</a></strong>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>, <span class="param">content:</span>&nbsp;?⁠<a href="#model.Slice"><span class="type">Slice</span></a><span class="defaultvalue"> = Slice.empty</span>)</code></dt>

<dd>
<p data-en="Replace the selection with a slice or, if no slice is given,
delete the selection. Will append to the given transaction." lang="cn">用给定的 slice 替换当前选区，如果没有给 slice，则删除选区。该操作会附加到给定 transaction 最后。</p>
<p type="comment"><span>注: </span>替换后会将新的选区（光标）放到插入的内容的右侧。如果插入的内容是一个 inline 节点，则向右寻找该节点后面的位置。
如果不是 inline 节点，则向左寻找。</p>
<p type="comment"><span>注: </span>英文原文档有多处使用了「backward」、「forward」、「back」之类的字眼，但是在不同的上下文中，其含义是不同的，因此此处意译为了「向左」或者「向右」，
不习惯的可以鼠标悬浮查看原英文文档。</p>
</dd><dt id="state.Selection.replaceWith"><code><strong><a href="#state.Selection.replaceWith">replaceWith</a></strong>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>, <span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>)</code></dt>

<dd>
<p data-en="Replace the selection with the given node, appending the changes
to the given transaction." lang="cn">用给定的 node 替换当前选区，该操作会附加到给定的 transaction 最后。</p>
</dd><dt id="state.Selection.toJSON"><code><strong><a href="#state.Selection.toJSON">toJSON</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Convert the selection to a JSON representation. When implementing
this for a custom selection class, make sure to give the object a
type property whose value matches the ID under which you
registered your class." lang="cn">将当前选区转换成 JSON 表示的格式。当在自己实现的 selection 类中实现此方法的时候，需要确保给这个返回的对象一个 <code>type</code> 属性，
属性值是你 <a href="#state.Selection%5EjsonID">注册</a> selection 时候的 ID。</p>
</dd><dt id="state.Selection.getBookmark"><code><strong><a href="#state.Selection.getBookmark">getBookmark</a></strong>() →&nbsp;<a href="#state.SelectionBookmark"><span class="type">SelectionBookmark</span></a></code></dt>

<dd>
<p data-en="Get a bookmark for this selection,
which is a value that can be mapped without having access to a
current document, and later resolved to a real selection for a
given document again. (This is used mostly by the history to
track and restore old selections.) The default implementation of
this method just converts the selection to a text selection and
returns the bookmark for that." lang="cn">获取一个选区的 <a href="#state.SelectionBookmark">bookmark</a>，它是一个无需访问当前 document 即可被 mapped
然后再在 mapped 后通过给定一个 document 再解析成一个真实选区的值。（这个方法最可能被用在 history 中，以进行
选区追踪和恢复旧选区）该方法的默认实现仅仅是转换当前选区为一个文本选区，然后返回文本选区的 bookmark。</p>
</dd><dt id="state.Selection.visible"><code><strong><a href="#state.Selection.visible">visible</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Controls whether, when a selection of this type is active in the
browser, the selected range should be visible to the user. Defaults
to true." lang="cn">控制该选区类型在浏览器中被激活的时候是否对用户可见。默认是 <code>true</code>。</p>
</dd><dt id="state.Selection^findFrom"><code>static <strong><a href="#state.Selection^findFrom">findFrom</a></strong>(<span class="param">$pos:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">dir:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">textOnly:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;?⁠<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Find a valid cursor or leaf node selection starting at the given
position and searching back if dir is negative, and forward if
positive. When textOnly is true, only consider cursor
selections. Will return null when no valid selection position is
found." lang="cn">在给定的位置寻找一个可用的光标或叶节点选区，如果 <code>dir</code> 参数是负的则往左寻找，如果是正的则向右寻找。当 <code>textOnly</code> 是 true 的时候，则只考虑光标选区。
如果没有可用的选区位置，则返回 null。</p>
<p type="comment"><span>注: </span>此方法对在粘贴或者一番操作后，不知道应该将光标放到哪个合适的位置时的情况尤为有用，它会自动寻找一个合适的位置，而不用手动 setSelection，对此种情况还有用的一个方法是下面的 near 方法。</p>
</dd><dt id="state.Selection^near"><code>static <strong><a href="#state.Selection^near">near</a></strong>(<span class="param">$pos:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">bias:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 1</span>) →&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Find a valid cursor or leaf node selection near the given
position. Searches forward first by default, but if bias is
negative, it will search backwards first." lang="cn">在给定的位置寻找一个可用的光标或者叶节点选区。默认向右搜索，如果 <code>bias</code> 是负，则会优先向左搜索。</p>
</dd><dt id="state.Selection^atStart"><code>static <strong><a href="#state.Selection^atStart">atStart</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Find the cursor or leaf node selection closest to the start of
the given document. Will return an
AllSelection if no valid position
exists." lang="cn">寻找一个给定文档最开始的光标或叶节点选区。如果没有可用的位置存在，则返回 <a href="#state.AllSelection"><code>AllSelection</code></a>。</p>
</dd><dt id="state.Selection^atEnd"><code>static <strong><a href="#state.Selection^atEnd">atEnd</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Find the cursor or leaf node selection closest to the end of the
given document." lang="cn">寻找一个给定文档最末尾的光标或者叶节点选区。</p>
</dd><dt id="state.Selection^fromJSON"><code>static <strong><a href="#state.Selection^fromJSON">fromJSON</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">json:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Deserialize the JSON representation of a selection. Must be
implemented for custom classes (as a static class method)." lang="cn">反序列化一个选区的 JSON 表示。必须在自定义的 selection 类中实现该方法（作为一个静态类方法）。</p>
</dd><dt id="state.Selection^jsonID"><code>static <strong><a href="#state.Selection^jsonID">jsonID</a></strong>(<span class="param">id:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">selectionClass:</span>&nbsp;<span class="prim">constructor</span>&lt;<a href="#state.Selection"><span class="type">Selection</span></a>&gt;)</code></dt>

<dd>
<p data-en="To be able to deserialize selections from JSON, custom selection
classes must register themselves with an ID string, so that they
can be disambiguated. Try to pick something that's unlikely to
clash with classes from other modules." lang="cn">为了能够从 JSON 中反序列化一个选区，自定义的 selection 类必须用一个字符串 ID 来注册自己，以消除歧义。
尽量要用一个不会与其他模块的类名冲突的字符串。</p>
</dd></dl>
<h4 id="state.TextSelection">
  <a href="#state.TextSelection">TextSelection</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#state.Selection"><span class="type">Selection</span></a></code></span></h4>
<p data-en="A text selection represents a classical editor selection, with
a head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position)." lang="cn">一个文本选区代表一个典型的编辑器选区，其有一个 head（移动的一侧）和一个 anchor（不动的一侧），二者都
指向一个文本块节点。它可以是空的（此时表示一个正常的光标位置）。</p>
<p type="comment"><span>注: </span>文本块节点，即文本节点的直接父节点。如定义了 doc &gt; p &gt; text，则文本块节点即 p 节点。</p>
<dl><dt id="state.TextSelection.constructor"><code>new <strong><a href="#state.TextSelection.constructor">TextSelection</a></strong>(<span class="param">$anchor:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">$head:</span>&nbsp;?⁠<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a><span class="defaultvalue"> = $anchor</span>)</code></dt>

<dd>
<p data-en="Construct a text selection between the given points." lang="cn">构造一个包含给定两点的文本选区。</p>
</dd><dt id="state.TextSelection.$cursor"><code><strong><a href="#state.TextSelection.$cursor">$cursor</a></strong>: ?⁠<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="Returns a resolved position if this is a cursor selection (an
empty text selection), and null otherwise." lang="cn">如果当前选区是一个光标选区（一个空的文本选区），则返回其 resolved 过的位置，否则返回 null。</p>
</dd><dt id="state.TextSelection^create"><code>static <strong><a href="#state.TextSelection^create">create</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">anchor:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">head:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = anchor</span>) →&nbsp;<a href="#state.TextSelection"><span class="type">TextSelection</span></a></code></dt>

<dd>
<p data-en="Create a text selection from non-resolved positions." lang="cn">用一个非 resolved 过的位置作为参数来创建一个文本选区。</p>
</dd><dt id="state.TextSelection^between"><code>static <strong><a href="#state.TextSelection^between">between</a></strong>(<span class="param">$anchor:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">$head:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">bias:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Return a text selection that spans the given positions or, if
they aren't text positions, find a text selection near them.
bias determines whether the method searches forward (default)
or backwards (negative number) first. Will fall back to calling
Selection.near when the document
doesn't contain a valid text position." lang="cn">返回一个跨越给定 anchor 和 head 位置的选区，如果它们不是一个文本位置，则调用 findFrom 就近寻找一个可用的文本选区。
<code>bias</code> 决定就近向哪个方向寻找，默认是向左，值为负时是向右。如果文档不包含一个可用的文本位置，
则调用 <a href="#state.Selection%5Enear"><code>Selection.near</code></a> 方法。</p>
</dd></dl>
<h4 id="state.NodeSelection">
  <a href="#state.NodeSelection">NodeSelection</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#state.Selection"><span class="type">Selection</span></a></code></span></h4>
<p data-en="A node selection is a selection that points at a single node.
All nodes marked selectable can be
the target of a node selection. In such a selection, from and
to point directly before and after the selected node, anchor
equals from, and head equals to.." lang="cn">一个 node （节点）选区是一个指向单独节点的选区。所有的配置为 <a href="#model.NodeSpec.selectable">selectable</a>
的 node 节点都可以是一个 node 选区的目标。在这个类型的选区中，<code>from</code> 和 <code>to</code> 直接指向选择节点的前面和后面，
<code>anchor</code> 等于 <code>from</code>，<code>head</code> 等于 <code>to</code>。</p>
<p type="comment"><span>注: </span>node 选区就是当选中一个节点的时候的选区类型。</p>
<dl><dt id="state.NodeSelection.constructor"><code>new <strong><a href="#state.NodeSelection.constructor">NodeSelection</a></strong>(<span class="param">$pos:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>)</code></dt>

<dd>
<p data-en="Create a node selection. Does not verify the validity of its
argument." lang="cn">新建一个 node 选区。不会验证参数的可用性。</p>
<p type="comment"><span>注: </span>因为不会验证参数的可用性，所以需要保证参数 $pos 是一个 resolved 过的可用 pos。</p>
</dd><dt id="state.NodeSelection.node"><code><strong><a href="#state.NodeSelection.node">node</a></strong>: <a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The selected node." lang="cn">当前选择的 node。</p>
</dd><dt id="state.NodeSelection^create"><code>static <strong><a href="#state.NodeSelection^create">create</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#state.NodeSelection"><span class="type">NodeSelection</span></a></code></dt>

<dd>
<p data-en="Create a node selection from non-resolved positions." lang="cn">以一个未 resolved 过的位置来新建一个 node 选区。</p>
</dd><dt id="state.NodeSelection^isSelectable"><code>static <strong><a href="#state.NodeSelection^isSelectable">isSelectable</a></strong>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Determines whether the given node may be selected as a node
selection." lang="cn">判断给的节点是否可以被选中作为一个 node 选区。</p>
</dd></dl>
<h4 id="state.AllSelection">
  <a href="#state.AllSelection">AllSelection</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#state.Selection"><span class="type">Selection</span></a></code></span></h4>
<p data-en="A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document)." lang="cn">代表了选中整个文档的选区类型（此时可能用文本选区类型来表示不是必要的，比如当一个文档开头或者结尾有一个叶节点的时候）。</p>
<dl><dt id="state.AllSelection.constructor"><code>new <strong><a href="#state.AllSelection.constructor">AllSelection</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>)</code></dt>

<dd>
<p data-en="Create an all-selection over the given document." lang="cn">创建一个覆盖给定文档的 AllSelection 选区类型。</p>
</dd></dl>
<h4 id="state.SelectionRange">
  <a href="#state.SelectionRange">SelectionRange</a> <span class="kind">class</span></h4>
<p data-en="Represents a selected range in a document." lang="cn">表示文档中的一个选区范围。</p>
<dl><dt id="state.SelectionRange.constructor"><code>new <strong><a href="#state.SelectionRange.constructor">SelectionRange</a></strong>(<span class="param">$from:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">$to:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>)</code></dt>

<dd></dd><dt id="state.SelectionRange.$from"><code><strong><a href="#state.SelectionRange.$from">$from</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="The lower bound of the range." lang="cn">选区范围位置较小的一侧。</p>
</dd><dt id="state.SelectionRange.$to"><code><strong><a href="#state.SelectionRange.$to">$to</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="The upper bound of the range." lang="cn">选区范围位置较大的一侧。</p>
</dd></dl>
<h4 id="state.SelectionBookmark">
  <a href="#state.SelectionBookmark">SelectionBookmark</a> <span class="kind">interface</span></h4>
<p data-en="A lightweight, document-independent representation of a selection.
You can define a custom bookmark type for a custom selection class
to make the history handle it well." lang="cn">一个轻量的，文档无关的选区形式。你可以对一个自定义选区类来自定义一个 bookmark 类型，使 history 正确处理它（自定义选区的 bookmark）。</p>
<dl><dt id="state.SelectionBookmark.map"><code><strong><a href="#state.SelectionBookmark.map">map</a></strong>(<span class="param">mapping:</span>&nbsp;<a href="#transform.Mapping"><span class="type">Mapping</span></a>) →&nbsp;<a href="#state.SelectionBookmark"><span class="type">SelectionBookmark</span></a></code></dt>

<dd>
<p data-en="Map the bookmark through a set of changes." lang="cn">在一系列的文档修改后 map 该 bookmark 到一个新的 bookmark。</p>
</dd><dt id="state.SelectionBookmark.resolve"><code><strong><a href="#state.SelectionBookmark.resolve">resolve</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Resolve the bookmark to a real selection again. This may need to
do some error checking and may fall back to a default (usually
TextSelection.between) if
mapping made the bookmark invalid." lang="cn">将该 bookmark 再解析成一个真实选区。可能需要做一些错误检查，并且如果 mapping 后该 bookmark 变得不可用的话，则会回滚到
默认行为（通常是 <a href="#state.TextSelection%5Ebetween"><code>TextSelection.between</code></a>）。</p>
</dd></dl>
<h3 id="state.Plugin_System"><a href="#state.Plugin_System">Plugin System</a></h3>

<p data-en="To make it easy to package and enable extra editor functionality,
ProseMirror has a plugin system." lang="cn">为了让打包和扩展编辑器功能变得更容易，ProseMirror 提供了一个 Plugin 系统。</p>
<h4 id="state.PluginSpec">
  <a href="#state.PluginSpec">PluginSpec</a> <span class="kind">interface</span></h4>
<p data-en="This is the type passed to the Plugin
constructor. It provides a definition for a plugin." lang="cn">这是一个传递给 <a href="#state.Plugin"><code>Plugin</code></a> 构造函数的类型。它提供了插件的配置。</p>
<dl><dt id="state.PluginSpec.props"><code><strong><a href="#state.PluginSpec.props">props</a></strong>: ?⁠<a href="#view.EditorProps"><span class="type">EditorProps</span></a></code></dt>

<dd>
<p data-en="The view props added by this plugin. Props
that are functions will be bound to have the plugin instance as
their this binding." lang="cn">该插件设置的 <a href="#view.EditorProps">视图属性</a>。属性如果是函数，则函数的 <code>this</code> 将绑定到当前实例。</p>
<p type="comment"><span>注: </span>对象属性是函数的话一般叫做对象的方法。</p>
</dd><dt id="state.PluginSpec.state"><code><strong><a href="#state.PluginSpec.state">state</a></strong>: ?⁠<a href="#state.StateField"><span class="type">StateField</span></a>&lt;<span class="prim">any</span>&gt;</code></dt>

<dd>
<p data-en="Allows a plugin to define a state field, an
extra slot in the state object in which it can keep its own data." lang="cn">允许插件定义一个 <a href="#state.StateField">state 字段</a>，一个在编辑器整体 state 对象上的额外的插槽，其可以持有自己的插件 state。</p>
</dd><dt id="state.PluginSpec.key"><code><strong><a href="#state.PluginSpec.key">key</a></strong>: ?⁠<a href="#state.PluginKey"><span class="type">PluginKey</span></a></code></dt>

<dd>
<p data-en="Can be used to make this a keyed plugin. You can have only one
plugin with a given key in a given state, but it is possible to
access the plugin's configuration and state through the key,
without having access to the plugin instance object." lang="cn">可以被用来唯一确定一个 plugin。在一个给定的 state 你只能有一个给定 key 的 plugin。
你可以通过这个 key 而不用访问插件实例来访问该插件的配置和 state。</p>
</dd><dt id="state.PluginSpec.view"><code><strong><a href="#state.PluginSpec.view">view</a></strong>: ?⁠<span class="fn">fn</span>(<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="When the plugin needs to interact with the editor view, or
set something up in the DOM, use this field. The function
will be called when the plugin's state is associated with an
editor view." lang="cn">当插件需要与编辑器视图交互的时候，或者需要在 DOM 上设置一些东西的时候，使用这个字段。
当插件的 state 与编辑器 view 有关联的时候将会调用该函数。</p>
<dl><dt id="state.PluginSpec.view^returns"><code><strong><a href="#state.PluginSpec.view^returns">returns</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Should return an object with the following optional
properties:" lang="cn">应该返回有下列可选属性的对象：</p>
<dl><dt id="state.PluginSpec.view^returns.update"><code><strong><a href="#state.PluginSpec.view^returns.update">update</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">prevState:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>)</code></dt>

<dd>
<p data-en="Called whenever the view's state is updated." lang="cn">编辑器 view 一更新就调用该函数。</p>
<p type="comment"><span>注: </span>编辑器 view 更新可能是用户的操作如输入内容，或者编辑器的操作，如由事件触发的 transaction 更新视图，
此处可以拿到编辑器的 view 和应用 transaction 之前的 state。</p>
</dd><dl><dt id="state.PluginSpec.view^returns.destroy"><code><strong><a href="#state.PluginSpec.view^returns.destroy">destroy</a></strong>: ?⁠<span class="fn">fn</span>()</code></dt>

<dd>
<p data-en="Called when the view is destroyed or receives a state
with different plugins." lang="cn">当 state 对象被重新配置而不再含该插件或者编辑器视图被销毁的时候调用该函数。</p>
<p type="comment"><span>注: </span>页面重载等情况会销毁编辑器的 view。</p>
</dd></dl></dl></dd></dl></dd><dt id="state.PluginSpec.filterTransaction"><code><strong><a href="#state.PluginSpec.filterTransaction">filterTransaction</a></strong>: ?⁠<span class="fn">fn</span>(<a href="#state.Transaction"><span class="type">Transaction</span></a>, <a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When present, this will be called before a transaction is
applied by the state, allowing the plugin to cancel it (by
returning false)." lang="cn">如果有该函数，则该函数会在一个 transaction 被应用到 state 之前调用，以允许插件有机会取消该 transaction（通过返回 false）</p>
</dd><dt id="state.PluginSpec.appendTransaction"><code><strong><a href="#state.PluginSpec.appendTransaction">appendTransaction</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">transactions:</span>&nbsp;[<a href="#state.Transaction"><span class="type">Transaction</span></a>], <span class="param">oldState:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">newState:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;?⁠<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Allows the plugin to append another transaction to be applied
after the given array of transactions. When another plugin
appends a transaction after this was called, it is called again
with the new state and new transactions—but only the new
transactions, i.e. it won't be passed transactions that it
already saw." lang="cn">允许这个插件附加另一个 transaction 到将要被应用的 transactions 数组的末尾上去。
当另一个 plugin 又附加了一个 transaction 且其在当前 plugin 之后调用，
则当前 plugin 的该函数会再调用一次。但是仅含新的 transaction 和新的 state。也即是，它不会再将之前处理过的 transaction 再处理一次。</p>
</dd></dl>
<h4 id="state.StateField">
  <a href="#state.StateField">StateField</a> <span class="kind">interface</span></h4>
<p data-en="A plugin spec may provide a state field (under its
state property) of this type, which
describes the state it wants to keep. Functions provided here are
always called with the plugin instance as their this binding." lang="cn">插件可能会提供一个该配置类型的 state 字段（在它的 <a href="#state.PluginSpec.state"><code>state</code></a> 属性上）。
它描述了插件想要持有的 state。该字段下的方法调用的时候，其 <code>this</code> 指向插件实例。</p>
<dl><dt id="state.StateField.init"><code><strong><a href="#state.StateField.init">init</a></strong>(<span class="param">config:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">instance:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<span class="prim">T</span></code></dt>

<dd>
<p data-en="Initialize the value of the field. config will be the object
passed to EditorState.create. Note
that instance is a half-initialized state instance, and will
not have values for plugin fields initialized after this one." lang="cn">初始化插件的 state。<code>config</code> 是传递给 <a href="#state.EditorState%5Ecreate"><code>EditorState.create</code></a> 的对象。
记住：<code>instance</code> 是一个半初始化的 state 实例，在当前插件之后初始化的插件在此时将不会有值。</p>
<p type="comment"><span>注: </span>因此在新建 state 的时候，插件的顺序至关重要。</p>
</dd><dt id="state.StateField.apply"><code><strong><a href="#state.StateField.apply">apply</a></strong>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>, <span class="param">value:</span>&nbsp;<span class="prim">T</span>, <span class="param">oldState:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">newState:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<span class="prim">T</span></code></dt>

<dd>
<p data-en="Apply the given transaction to this state field, producing a new
field value. Note that the newState argument is again a partially
constructed state does not yet contain the state from plugins
coming after this one." lang="cn">应用给定的 transaction 到插件的 state 字段，以产生一个新的 state。
记住，<code>newState</code> 参数再一次的，是一个部分构造的 state，它不会包含当前插件之后还未初始化的插件的 state。</p>
</dd><dt id="state.StateField.toJSON"><code><strong><a href="#state.StateField.toJSON">toJSON</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">value:</span>&nbsp;<span class="prim">T</span>) →&nbsp;<span class="prim">any</span></code></dt>

<dd>
<p data-en="Convert this field to JSON. Optional, can be left off to disable
JSON serialization for the field." lang="cn">将当前字段值转换成 JSON。当然，你也可以留空以禁用当前插件 state 的序列化。</p>
<p type="comment"><span>注: </span>所谓转成 JSON，在该文档所有对象的 toJSON 方法都是转成一个 plain object，而不是 JSON.stringify 得到的对象。</p>
</dd><dt id="state.StateField.fromJSON"><code><strong><a href="#state.StateField.fromJSON">fromJSON</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">config:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">value:</span>&nbsp;<span class="prim">any</span>, <span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<span class="prim">T</span></code></dt>

<dd>
<p data-en="Deserialize the JSON representation of this field. Note that the
state argument is again a half-initialized state." lang="cn">反序列化给定的该字段的 JSON 表示对象。记住：<code>state</code> 参数还是一个半序列化的 state 对象。</p>
</dd></dl>
<h4 id="state.Plugin">
  <a href="#state.Plugin">Plugin</a> <span class="kind">class</span></h4>
<p data-en="Plugins bundle functionality that can be added to an editor.
They are part of the editor state and
may influence that state and the view that contains it." lang="cn">Plugins 可以被添加到 editor 中，它们是 <a href="#state.EditorState">编辑器 state</a> 的一部分，并且能够影响包含它的 state 和 view。</p>
<dl><dt id="state.Plugin.constructor"><code>new <strong><a href="#state.Plugin.constructor">Plugin</a></strong>(<span class="param">spec:</span>&nbsp;<a href="#state.PluginSpec"><span class="type">PluginSpec</span></a>)</code></dt>

<dd>
<p data-en="Create a plugin." lang="cn">创建一个 plugin。</p>
</dd><dt id="state.Plugin.props"><code><strong><a href="#state.Plugin.props">props</a></strong>: <a href="#view.EditorProps"><span class="type">EditorProps</span></a></code></dt>

<dd>
<p data-en="The props exported by this plugin." lang="cn">当前插件导出的 <a href="#view.EditorProps">属性</a></p>
</dd><dt id="state.Plugin.spec"><code><strong><a href="#state.Plugin.spec">spec</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="The plugin's spec object." lang="cn">当前插件的 <a href="#state.PluginSpec">配置对象</a>。</p>
</dd><dt id="state.Plugin.getState"><code><strong><a href="#state.Plugin.getState">getState</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<span class="prim">any</span></code></dt>

<dd>
<p data-en="Extract the plugin's state field from an editor state." lang="cn">从编辑器的 state 上获取当前插件的 state。</p>
</dd></dl>
<h4 id="state.PluginKey">
  <a href="#state.PluginKey">PluginKey</a> <span class="kind">class</span></h4>
<p data-en="A key is used to [tag]tag
plugins in a way that makes it possible to find them, given an
editor state. Assigning a key does mean only one plugin of that
type can be active in a state." lang="cn">一个插件 key 用来 [标记]<a href="#state.PluginSpec.key">tag</a> 一个插件，以能够在通过搜索编辑器的 state 来方便的找到它。</p>
<dl><dt id="state.PluginKey.constructor"><code>new <strong><a href="#state.PluginKey.constructor">PluginKey</a></strong>(<span class="param">name:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a><span class="defaultvalue"> = "key"</span>)</code></dt>

<dd>
<p data-en="Create a plugin key." lang="cn">新建一个 plugin key</p>
</dd><dt id="state.PluginKey.get"><code><strong><a href="#state.PluginKey.get">get</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;?⁠<a href="#state.Plugin"><span class="type">Plugin</span></a></code></dt>

<dd>
<p data-en="Get the active plugin with this key, if any, from an editor
state." lang="cn">用 key 从 state 获取到 key 对应的激活的插件。</p>
</dd><dt id="state.PluginKey.getState"><code><strong><a href="#state.PluginKey.getState">getState</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;?⁠<span class="prim">any</span></code></dt>

<dd>
<p data-en="Get the plugin's state from an editor state." lang="cn">从编辑器的 state 中获取插件的 state。</p>
</dd></dl>
</section><section id=part_view>
    <h2 class=module id=view>
      <a href="#view">prosemirror-view <span class=kind>module</span></a>
    </h2><p>ProseMirror 的 view 模块用来在 DOM 中展示给定的 <a href="#state.EditorState">编辑器的 state</a>，同时处理用户触发的事件。</p>
<p>当使用该模块的时候，要首先确认下已经加载了 <code>style/prosemirror.css</code> 模块作为样式表。</p>
<h4 id="view.EditorView">
  <a href="#view.EditorView">EditorView</a> <span class="kind">class</span></h4>
<p data-en="An editor view manages the DOM structure that represents an
editable document. Its state and behavior are determined by its
props." lang="cn">一个编辑器视图负责整个可编辑文档。它的 state 和行为由 props 决定。</p>
<p type="comment"><span>注: </span>新建编辑器的第一步就是 new 一个 EditorView。</p>
<dl><dt id="view.EditorView.constructor"><code>new <strong><a href="#view.EditorView.constructor">EditorView</a></strong>(<span class="param">place:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a> | <span class="fn">fn</span>(<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>) | {<span class="prop">mount:&nbsp;</span><a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>}, <span class="param">props:</span>&nbsp;<a href="#view.DirectEditorProps"><span class="type">DirectEditorProps</span></a>)</code></dt>

<dd>
<p data-en="Create a view. place may be a DOM node that the editor should
be appended to, a function that will place it into the document,
or an object whose mount property holds the node to use as the
document container. If it is null, the editor will not be added
to the document." lang="cn">新建一个 view 视图，<code>place</code> 参数可能是一个 DOM 节点，表示编辑器的挂载点，或者一个函数，则编辑器将会被挂载在文档根节点
或者一个对象，它的 <code>mount</code> 属性的值表示编辑器的挂载 DOM，而如果是 <code>null</code>，编辑器将不会被放到文档中。</p>
<p type="comment"><span>注: </span><code>place</code> 是一个函数的时候，函数的参数是通过 document.createElement('div') 新建的一个 DOM 节点，
该节点将会作为函数的唯一参数传入，该节点还未被放入真实文档中，需要你手动放入。</p>
</dd><dt id="view.EditorView.state"><code><strong><a href="#view.EditorView.state">state</a></strong>: <a href="#state.EditorState"><span class="type">EditorState</span></a></code></dt>

<dd>
<p data-en="The view's current state." lang="cn">编辑器当前的 <a href="#state.EditorState">state</a>。</p>
</dd><dt id="view.EditorView.dom"><code><strong><a href="#view.EditorView.dom">dom</a></strong>: <a href="https://developer.mozilla.org/en/docs/DOM/Element"><span class="type">dom.Element</span></a></code></dt>

<dd>
<p data-en="An editable DOM node containing the document. (You probably
should not directly interfere with its content.)" lang="cn">一个包含编辑器文档的可编辑 DOM 节点。（你不应该直接操作该节点的内容）</p>
</dd><dt id="view.EditorView.editable"><code><strong><a href="#view.EditorView.editable">editable</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Indicates whether the editor is currently editable." lang="cn">指示当前编辑器是否 <a href="#view.EditorProps.editable">可编辑</a></p>
</dd><dt id="view.EditorView.dragging"><code><strong><a href="#view.EditorView.dragging">dragging</a></strong>: ?⁠{<span class="prop">slice:&nbsp;</span><a href="#model.Slice"><span class="type">Slice</span></a>, <span class="prop">move:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>}</code></dt>

<dd>
<p data-en="When editor content is being dragged, this object contains
information about the dragged slice and whether it is being
copied or moved. At any other time, it is null." lang="cn">当编辑器的内容被拖拽的时候，这个对象包含有拖拽内容相关的信息及该内容是否被复制还是被移动。在其他时候，该对象是 null。</p>
</dd><dt id="view.EditorView.composing"><code><strong><a href="#view.EditorView.composing">composing</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">boolean</span></a></code></dt>

<dd>
<p data-en="Holds true when a
composition
is active." lang="cn">当 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide">composition</a> 事件触发的时候，该值为 true。</p>
<p type="comment"><span>注: </span>composition 事件与 CJK 输入法有关，也与浏览器实现有关，Safari 和 Chrome 中的 composition 触发顺序就不一样，以及一些其他差异。
这导致了一些使用 ProseMirror 的编辑器在 Safari 上的表现比较诡异，论坛中也有很多针对 Safari 反馈的 bug，大多跟 composition 有关。</p>
</dd><dt id="view.EditorView.props"><code><strong><a href="#view.EditorView.props">props</a></strong>: <a href="#view.DirectEditorProps"><span class="type">DirectEditorProps</span></a></code></dt>

<dd>
<p data-en="The view's current props." lang="cn">编辑器 view 的 <a href="#view.EditorProps">props（属性）</a>。</p>
<p type="comment"><span>注: </span>props 是一个 getter 属性，每次通过 view.props 访问到的 props 带的一定是最新的 state。</p>
</dd><dt id="view.EditorView.update"><code><strong><a href="#view.EditorView.update">update</a></strong>(<span class="param">props:</span>&nbsp;<a href="#view.DirectEditorProps"><span class="type">DirectEditorProps</span></a>)</code></dt>

<dd>
<p data-en="Update the view's props. Will immediately cause an update to
the DOM." lang="cn">更新 view 的 props。将会立即引起 DOM 的更新。</p>
</dd><dt id="view.EditorView.setProps"><code><strong><a href="#view.EditorView.setProps">setProps</a></strong>(<span class="param">props:</span>&nbsp;<a href="#view.DirectEditorProps"><span class="type">DirectEditorProps</span></a>)</code></dt>

<dd>
<p data-en="Update the view by updating existing props object with the object
given as argument. Equivalent to view.update(Object.assign({}, view.props, props))." lang="cn">用给定的参数来更新已有的 props 对象，以达到更新 view 的目的。等同于 <code>view.update(Object.assign({}, view.props, props))</code>。</p>
</dd><dt id="view.EditorView.updateState"><code><strong><a href="#view.EditorView.updateState">updateState</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>)</code></dt>

<dd>
<p data-en="Update the editor's state prop, without touching any of the
other props." lang="cn">单独更新编辑器 props 的 <code>state</code> 属性。</p>
</dd><dt id="view.EditorView.someProp"><code><strong><a href="#view.EditorView.someProp">someProp</a></strong>(<span class="param">propName:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">f:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">prop:</span>&nbsp;<span class="prim">any</span>) →&nbsp;<span class="prim">any</span>) →&nbsp;<span class="prim">any</span></code></dt>

<dd>
<p data-en="Goes over the values of a prop, first those provided directly,
then those from plugins (in order), and calls f every time a
non-undefined value is found. When f returns a truthy value,
that is immediately returned. When f isn't provided, it is
treated as the identity function (the prop value is returned
directly)." lang="cn">遍历给定属性名所有的值，在编辑器 props 中的属性优先，然后按照插件书写的顺序遍历插件的 props 上的该属性，获取它的值，
若遇到该属性的值不是 undefined 的话就调用 <code>f</code> 函数。当 <code>f</code> 函数返回一个真值，那么该 somePorp 函数则立即返回该属性值。如果 <code>f</code> 函数
未提供，则将其当成是一个拥有固定返回值的函数（即遍历到第一个给定属性且有值的话则直接返回该值）</p>
<p type="comment"><span>注: </span>若提供了 f 函数，则 f 函数执行的时候，参数即为遍历到的 prop 的值（一般是个函数），
若 f 函数返回了真值，则 someProp 函数的返回值即为 f 函数本身，并停止遍历；若 f 函数返回了非真值， 则继续遍历，直到遇到真值才返回。
若 f 函数未提供，则如果 prop 的值不为 undefined，则直接返回该值。</p>
<p type="comment"><span>注: </span>一般用法是 view.someProp('handleResize', v =&gt; v(view, state, slice, other))，这里的 v 即为你写的 prop 属性值。</p>
</dd><dt id="view.EditorView.hasFocus"><code><strong><a href="#view.EditorView.hasFocus">hasFocus</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Query whether the view has focus." lang="cn">查询当前 view 是否被 focus。</p>
</dd><dt id="view.EditorView.focus"><code><strong><a href="#view.EditorView.focus">focus</a></strong>()</code></dt>

<dd>
<p data-en="Focus the editor." lang="cn">focus 编辑器。</p>
<p type="comment"><span>注: </span>这个过程会用到特性检测，即检查 dom.focus({preventScroll: true}) 是否支持。</p>
</dd><dt id="view.EditorView.root"><code><strong><a href="#view.EditorView.root">root</a></strong>: <a href="https://developer.mozilla.org/en/docs/DOM/document"><span class="type">dom.Document</span></a> | <a href="https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment"><span class="type">dom.DocumentFragment</span></a></code></dt>

<dd>
<p data-en="Get the document root in which the editor exists. This will
usually be the top-level document, but might be a shadow
DOM
root if the editor is inside one." lang="cn">获取编辑器所在的根节点。通常情况下是顶级节点 <code>document</code>，但是也可能是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM">shadow DOM</a>
根节点，如果编辑器在它内部的话。</p>
</dd><dt id="view.EditorView.posAtCoords"><code><strong><a href="#view.EditorView.posAtCoords">posAtCoords</a></strong>(<span class="param">coords:</span>&nbsp;{<span class="prop">left:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">top:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}) →&nbsp;?⁠{<span class="prop">pos:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">inside:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Given a pair of viewport coordinates, return the document
position that corresponds to them. May return null if the given
coordinates aren't inside of the editor. When an object is
returned, its pos property is the position nearest to the
coordinates, and its inside property holds the position of the
inner node that the position falls inside of, or -1 if it is at
the top level, not in any node." lang="cn">给定一对儿视口坐标信息，返回该坐标在文档中的位置。如果给定的坐标不在编辑器中，则会返回 null。
当返回一个对象时，<code>pos</code> 属性是离坐标最近的位置，<code>inside</code> 属性指示坐标落在的节点的内部节点的位置，
或者未为 -1，表示该坐标落在了顶级节点的位置，不在任何节点之内。</p>
<p type="comment"><span>注: </span>inside 属性举例：如果 table 结构是 table &gt; td+ &gt; p* &gt; text*，则若 pos 落在了 text 内部，则 inside 就是 text 开头的位置；如果落在了 p 之前的位置(before)，那就是 td 起始的位置(start)。</p>
<p type="comment"><span>注: </span>这个方法非常有用，实际开发的时候会被大量用到，尤其是在处理事件相关的时候，需要 event 的 clientX 和 clientY 的坐标信息，以获得元素的位置信息。</p>
<p type="comment"><span>注: </span>位置信息指的是编辑器内部的位置计数系统，是一个数字，如果想获取位置信息的更多内容，需要 resolve 一下，将其变成 resolvedPos，详见指南。</p>
</dd><dt id="view.EditorView.coordsAtPos"><code><strong><a href="#view.EditorView.coordsAtPos">coordsAtPos</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">side:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 1</span>) →&nbsp;{<span class="prop">left:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">right:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">top:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">bottom:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Returns the viewport rectangle at a given document position.
left and right will be the same number, as this returns a
flat cursor-ish rectangle. If the position is between two things
that aren't directly adjacent, side determines which element is
used. When < 0, the element before the position is used,
otherwise the element after." lang="cn">返回给定文档位置的相对于视口的坐标及大小信息。<code>left</code> 和 <code>right</code> 总是相同，因为该函数返回的是一个光标的的位置和大小信息。
如果该位置在两个并不直接相邻的元素之间，则 <code>side</code> 参数决定了这两个元素哪个元素被使用，当 <code>side</code> 小于 0 的时候，使用位置前面（左边）的元素，否则是后面的元素。</p>
<p type="comment"><span>注: </span>光标只有高度没有宽度，因此只有 top 和 bottom 及 height 信息；left 和 right 总是一样的，width 总是 0.</p>
<p type="comment"><span>注: </span>这个方法也很常用，不过一般情况下你不会用到 DOM 的坐标信息。</p>
</dd><dt id="view.EditorView.domAtPos"><code><strong><a href="#view.EditorView.domAtPos">domAtPos</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">side:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 0</span>) →&nbsp;{<span class="prop">node:&nbsp;</span><a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="prop">offset:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Find the DOM position that corresponds to the given document
position. When side is negative, find the position as close as
possible to the content before the position. When positive,
prefer positions close to the content after the position. When
zero, prefer as shallow a position as possible." lang="cn">返回给定位置的 DOM 节点。如果 <code>side</code> 参数是负的，则寻找离 position 最近的前面（左边的元素）
否则就寻找离位置最近的右边的元素。如果是 0，则会更倾向于返回一个较浅（？）的位置。</p>

<p data-en="Note that you should not mutate the editor's
internal DOM, only inspect it (and even that is usually not
necessary)." lang="cn">记住：你 <strong>绝对不应该</strong> 直接修改编辑器内部的 DOM，而只能查看它（虽然即使是检查它也是不必要的）</p>
<p type="comment"><span>注: </span><code>查看它</code> 的意思是只能获取 DOM 的信息，而不要设置。</p>
</dd><dt id="view.EditorView.nodeDOM"><code><strong><a href="#view.EditorView.nodeDOM">nodeDOM</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a></code></dt>

<dd>
<p data-en="Find the DOM node that represents the document node after the
given position. May return null when the position doesn't point
in front of a node or if the node is inside an opaque node view." lang="cn">寻找给定位置的 DOM 节点。如果位置不指向一个 node 前面或者该 node 是一个不透明的 node view 的话，则返回 null。</p>

<p data-en="This is intended to be able to call things like
getBoundingClientRect on that DOM node. Do not mutate the
editor DOM directly, or add styling this way, since that will be
immediately overriden by the editor as it redraws the node." lang="cn">该方法设计的目的是让你能够在 DOM 上调用类似 <code>getBoundingClientRect</code> 方法。<strong>绝对不要</strong> 直接修改编辑器的 DOM 元素，也不要通过这种方式添加样式之类的，因为你的修改可能随着节点的重绘被立即覆盖掉。</p>
<p type="comment"><span>注: </span>domAtPos 获取的是给定位置的 DOM 宽高和坐标信息，nodeDOM 获取的是给定位置的 DOM。你可以通过 nodeDOM 获取到 DOM 后再手动获取位置信息。</p>
</dd><dt id="view.EditorView.posAtDOM"><code><strong><a href="#view.EditorView.posAtDOM">posAtDOM</a></strong>(<span class="param">node:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="param">offset:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">bias:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = -1</span>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Find the document position that corresponds to a given DOM
position. (Whenever possible, it is preferable to inspect the
document structure directly, rather than poking around in the
DOM, but sometimes—for example when interpreting an event
target—you don't have a choice.)" lang="cn">返回给定 DOM 的位置信息。（它会尽可能的优先选择直接检查文档结构来获取位置信息，而不是用四处寻找逐个探测的方式，但是有些情况下，比如给定的是一个事件 target，那你别无选择只能逐个 target 的进行测试）</p>
<p type="comment"><span>注: </span>这句话的意思是，如果你直接通过 ProseMirror 的接口，如 nodeDOM，通过 pos 获取到了 DOM，然后通过该方法相当于是一个逆过程，以获取到 pos。然而，如果你传给该函数的参数是来自于 event.target
那么 ProseMirror 只能通过挨个节点检查的方式，来确定它在 ProseMirror 的位置。</p>

<p data-en="The bias parameter can be used to influence which side of a DOM
node to use when the position is inside a leaf node." lang="cn">如果位置落在了一个叶子节点，那么 <code>bias</code> 参数可以用来决定使用叶子节点的哪一侧。</p>
<p type="comment"><span>注: </span>bias &gt; 0 是右侧，否则是左侧，默认是左侧。</p>
</dd><dt id="view.EditorView.endOfTextblock"><code><strong><a href="#view.EditorView.endOfTextblock">endOfTextblock</a></strong>(<span class="param">dir:</span>&nbsp;<span class="string">"up"</span> | <span class="string">"down"</span> | <span class="string">"left"</span> | <span class="string">"right"</span> | <span class="string">"forward"</span> | <span class="string">"backward"</span>, <span class="param">state:</span>&nbsp;?⁠<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Find out whether the selection is at the end of a textblock when
moving in a given direction. When, for example, given &quot;left&quot;,
it will return true if moving left from the current cursor
position would leave that position's parent textblock. Will apply
to the view's current state by default, but it is possible to
pass a different state." lang="cn">返回如果光标往给定方向移动的话，当前光标是否是一个文本 block 的末尾。例如，当给定方向为 <code>「left」</code> 的话，如果光标向左移动一个单位的距离将会离开文本 block，则会返回 true。
默认使用的是view 当前的 state，也可以传入一个不同的 state。</p>
<p type="comment"><span>注: </span>文本 block，一般情况下指的是 paragraph 这种的，以 text 为直接子元素的节点。该方法的移动给定方向后检测的位置是 state.selection.$head。</p>
</dd><dt id="view.EditorView.destroy"><code><strong><a href="#view.EditorView.destroy">destroy</a></strong>()</code></dt>

<dd>
<p data-en="Removes the editor from the DOM and destroys all node
views." lang="cn">从 DOM 中移除编辑器，并销毁所有的 <a href="#view.NodeView">node views</a>。</p>
</dd><dt id="view.EditorView.dispatch"><code><strong><a href="#view.EditorView.dispatch">dispatch</a></strong>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)</code></dt>

<dd>
<p data-en="Dispatch a transaction. Will call
dispatchTransaction
when given, and otherwise defaults to applying the transaction to
the current state and calling
updateState with the result.
This method is bound to the view instance, so that it can be
easily passed around." lang="cn">派发一个 transaction。会调用 <a href="#view.DirectEditorProps.dispatchTransaction"><code>dispatchTransaction</code></a> （如果设置了的话），否则默认应用该 transaction 到当前 state，
然后将其结果（新的 state）作为参数，传入 <a href="#view.EditorView.updateState"><code>updateState</code></a> 方法。该方法被绑定在 view 对象上，因此可以容易地被调用。</p>
<p type="comment"><span>注: </span>必须调用 view.dispatch(transaction) 才可以触发一个更改。该方法一般情况下用在事件响应函数里面，但是你也可以用在任何能访问到 view 的地方。
反过来说，比如在 plugin 的 state 的 apply 内，你访问不到 view，也就不能 dispatch 一个 tr。如果你强行在其内 dispatch 了一个 tr（如通过将 view 放到 window 作为全局访问的方法），那么会导致循环调用以致内存溢出。</p>
</dd></dl>
<h3 id="view.Props"><a href="#view.Props">Props</a></h3>
<h4 id="view.EditorProps">
  <a href="#view.EditorProps">EditorProps</a> <span class="kind">interface</span></h4>
<p data-en="Props are configuration values that can be passed to an editor view
or included in a plugin. This interface lists the supported props." lang="cn">Props 就是一些可以传递给编辑器的 view，或者用在插件中的值。这个接口列出了支持的 props。</p>

<p data-en="The various event-handling functions may all return true to
indicate that they handled the given event. The view will then take
care to call preventDefault on the event, except with
handleDOMEvents, where the handler itself is responsible for that." lang="cn">不同的事件处理函数可能都返回 <code>true</code> 表示它们处理了相应的事件。view 将会在事件发生时帮你调用 <code>preventDefault</code>。但是 <code>handleDOMEvents</code>
中的事件需要你负责去手动调用。</p>

<p data-en="How a prop is resolved depends on the prop. Handler functions are
called one at a time, starting with the base props and then
searching through the plugins (in order of appearance) until one of
them returns true. For some props, the first plugin that yields a
value gets precedence." lang="cn">不同的 prop 有不同的处理方式。prop 是函数的话则会在某个时刻调用：最开始的时候是寻找在 view 上的 prop，然后按照 plugin 书写的顺序查找其上的 prop，按顺序调用，直到它们中的某一个返回了 true 才终止。
而对于其他一些 porps，会使用遇到的第一个 prop 返回的值。</p>
<dl><dt id="view.EditorProps.handleDOMEvents"><code><strong><a href="#view.EditorProps.handleDOMEvents">handleDOMEvents</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/DOM/event"><span class="type">dom.Event</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>&gt;</code></dt>

<dd>
<p data-en="Can be an object mapping DOM event type names to functions that
handle them. Such functions will be called before any handling
ProseMirror does of events fired on the editable DOM element.
Contrary to the other event handling props, when returning true
from such a function, you are responsible for calling
preventDefault yourself (or not, if you want to allow the
default behavior)." lang="cn">其是一个对象，键是 DOM 事件名，值是事件处理函数。事件处理函数将会先于 ProseMirror 处理任何发生在可编辑 DOM 元素上的事件之前调用。
与其他事件处理函数（此处指的是下面这些 ProseMirror 自己的事件处理函数）相反的是，当该函数返回 true 的时候，你需要手动调用 <code>preventDefault</code>（或者不调用，如果你想允许默认行为发生的话）</p>
<p type="comment"><span>注: </span>可以理解为，handleDOMEvents 中定义的事件比较原始，一切都需要你自己来掌控。之所以其内定义的事件处理函数会发生于 ProseMirror 事件处理之前，一个原因我猜是因为
如果 ProseMirror 事件处理完了之后再调用用户定义的事件处理函数，则需要再处理一遍 DOM 的更新。</p>
</dd><dt id="view.EditorProps.handleKeyDown"><code><strong><a href="#view.EditorProps.handleKeyDown">handleKeyDown</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/KeyboardEvent"><span class="type">dom.KeyboardEvent</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called when the editor receives a keydown event." lang="cn">当编辑器接收到一个 <code>keydown</code> 事件的时候调用。</p>
</dd><dt id="view.EditorProps.handleKeyPress"><code><strong><a href="#view.EditorProps.handleKeyPress">handleKeyPress</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/KeyboardEvent"><span class="type">dom.KeyboardEvent</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Handler for keypress events." lang="cn">当编辑器接收到一个 <code>keypress</code> 事件的时候调用。</p>
</dd><dt id="view.EditorProps.handleTextInput"><code><strong><a href="#view.EditorProps.handleTextInput">handleTextInput</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">text:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Whenever the user directly input text, this handler is called
before the input is applied. If it returns true, the default
behavior of actually inserting the text is suppressed." lang="cn">无论何时用户直接输入了文字的时候，该处理函数将会在输入内容应用到 DOM 之前调用。如果该函数返回 <code>true</code>，则用户输入文本到编辑器的默认行为将会被阻止。</p>
<p type="comment"><span>注: </span>该方法通常用来拦截输入，然后生成新的输入，如自动转换 markdown 语法，或者按下某个键执行特殊操作的时候比较有用。</p>
</dd><dt id="view.EditorProps.handleClickOn"><code><strong><a href="#view.EditorProps.handleClickOn">handleClickOn</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">nodePos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/MouseEvent"><span class="type">dom.MouseEvent</span></a>, <span class="param">direct:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called for each node around a click, from the inside out. The
direct flag will be true for the inner node." lang="cn">为每一个点击事件冒泡路径上的节点从内到外都调用一遍该函数。如果是内部节点，则 <code>direct</code> 将会是 true。</p>
</dd><dt id="view.EditorProps.handleClick"><code><strong><a href="#view.EditorProps.handleClick">handleClick</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/MouseEvent"><span class="type">dom.MouseEvent</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called when the editor is clicked, after handleClickOn handlers
have been called." lang="cn">当编辑器被点击的时候调用，函数执行顺序位于 <code>handleClickOn</code> 函数之后。</p>
</dd><dt id="view.EditorProps.handleDoubleClickOn"><code><strong><a href="#view.EditorProps.handleDoubleClickOn">handleDoubleClickOn</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">nodePos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/MouseEvent"><span class="type">dom.MouseEvent</span></a>, <span class="param">direct:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called for each node around a double click." lang="cn">同<code>handleClickOn</code>，只是针对双击事件。</p>
</dd><dt id="view.EditorProps.handleDoubleClick"><code><strong><a href="#view.EditorProps.handleDoubleClick">handleDoubleClick</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/MouseEvent"><span class="type">dom.MouseEvent</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called when the editor is double-clicked, after handleDoubleClickOn." lang="cn">同 <code>handleClick</code> 只是针对双击事件。</p>
</dd><dt id="view.EditorProps.handleTripleClickOn"><code><strong><a href="#view.EditorProps.handleTripleClickOn">handleTripleClickOn</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">nodePos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/MouseEvent"><span class="type">dom.MouseEvent</span></a>, <span class="param">direct:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called for each node around a triple click." lang="cn">同<code>handleClickOn</code>，只是针对三击事件。</p>
</dd><dt id="view.EditorProps.handleTripleClick"><code><strong><a href="#view.EditorProps.handleTripleClick">handleTripleClick</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/MouseEvent"><span class="type">dom.MouseEvent</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called when the editor is triple-clicked, after handleTripleClickOn." lang="cn">同 <code>handleClick</code> 只是针对三击事件</p>
</dd><dt id="view.EditorProps.handlePaste"><code><strong><a href="#view.EditorProps.handlePaste">handlePaste</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent"><span class="type">dom.ClipboardEvent</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Can be used to override the behavior of pasting. slice is the
pasted content parsed by the editor, but you can directly access
the event to get at the raw content." lang="cn">可以用来覆盖默认的粘贴行为。<code>slice</code> 是被编辑器格式化后的粘贴内容，不过你也可以通过直接访问事件对象来获取原始的粘贴内容。</p>
<p type="comment"><span>注: </span>粘贴事件中的数据位于 event.dataTransfer 对象上。</p>
</dd><dt id="view.EditorProps.handleDrop"><code><strong><a href="#view.EditorProps.handleDrop">handleDrop</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/DOM/event"><span class="type">dom.Event</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>, <span class="param">moved:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called when something is dropped on the editor. moved will be
true if this drop moves from the current selection (which should
thus be deleted)." lang="cn">当有东西被放入编辑器的时候调用。如果是从当前编辑器选区放入的，则 <code>moved</code> 参数会是 true（因此选区的内容应该被删除）。</p>
</dd><dt id="view.EditorProps.handleScrollToSelection"><code><strong><a href="#view.EditorProps.handleScrollToSelection">handleScrollToSelection</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called when the view, after updating its state, tries to scroll
the selection into view. A handler function may return false to
indicate that it did not handle the scrolling and further
handlers or the default behavior should be tried." lang="cn">当 view 更新了 state 之后，尝试将选区滚动到视图中的时候调用该函数。该函数可能返回 false，表示它不处理滚动；或者返回 true，表示让默认行为发生。</p>
</dd><dt id="view.EditorProps.createSelectionBetween"><code><strong><a href="#view.EditorProps.createSelectionBetween">createSelectionBetween</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">anchor:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">head:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>) →&nbsp;?⁠<a href="#state.Selection"><span class="type">Selection</span></a></code></dt>

<dd>
<p data-en="Can be used to override the way a selection is created when
reading a DOM selection between the given anchor and head." lang="cn">在给定的起点和终点新建一个选区。</p>
</dd><dt id="view.EditorProps.domParser"><code><strong><a href="#view.EditorProps.domParser">domParser</a></strong>: ?⁠<a href="#model.DOMParser"><span class="type">DOMParser</span></a></code></dt>

<dd>
<p data-en="The parser to use when reading editor changes
from the DOM. Defaults to calling
DOMParser.fromSchema on the
editor's schema." lang="cn"><a href="#model.DOMParser">parser</a> 用来从 DOM 中读取编辑器的变化。默认情况下（如果不设置的话）调用 <a href="#model.DOMParser%5EfromSchema"><code>DOMParser.fromSchema</code></a> 方法，参数是编辑器的 schema。</p>
</dd><dt id="view.EditorProps.transformPastedHTML"><code><strong><a href="#view.EditorProps.transformPastedHTML">transformPastedHTML</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">html:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Can be used to transform pasted HTML text, before it is parsed,
for example to clean it up." lang="cn">可以被用来在 HTML 文本被 parser <em>之前</em> 转换一下。</p>
</dd><dt id="view.EditorProps.clipboardParser"><code><strong><a href="#view.EditorProps.clipboardParser">clipboardParser</a></strong>: ?⁠<a href="#model.DOMParser"><span class="type">DOMParser</span></a></code></dt>

<dd>
<p data-en="The parser to use when reading content from
the clipboard. When not given, the value of the
domParser prop is used." lang="cn">用来从粘贴板中读取内容后 <a href="#model.DOMParser">parser</a> 。如果没有给，则使用 <a href="#view.EditorProps.domParser"><code>domParser</code></a> 属性。</p>
</dd><dt id="view.EditorProps.transformPastedText"><code><strong><a href="#view.EditorProps.transformPastedText">transformPastedText</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">text:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">plain:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Transform pasted plain text. The plain flag will be true when
the text is pasted as plain text." lang="cn">转换粘贴的纯文本。如果粘贴的文本是纯文本的话，<code>plain</code> 将会是 true。</p>
</dd><dt id="view.EditorProps.clipboardTextParser"><code><strong><a href="#view.EditorProps.clipboardTextParser">clipboardTextParser</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">text:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">$context:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">plain:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="A function to parse text from the clipboard into a document
slice. Called after
transformPastedText.
The default behavior is to split the text into lines, wrap them
in <p> tags, and call
clipboardParser on it.
The plain flag will be true when the text is pasted as plain text." lang="cn">将粘贴板中的文本 parse 成文档 slice。将会在 <a href="#view.EditorProps.transformPastedText"><code>transformPastedText</code></a> 之后调用。
默认行为是将文本分割成多行，然后使用 <code>&lt;p&gt;</code> 标签包裹之，然后再对其调用 [clipboardParser<code>](#view.EditorProps.clipboardParser)。如果粘贴的内容是纯文本，则</code>plain` 将会是 true。</p>
</dd><dt id="view.EditorProps.transformPasted"><code><strong><a href="#view.EditorProps.transformPasted">transformPasted</a></strong>: ?⁠<span class="fn">fn</span>(<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="Can be used to transform pasted content before it is applied to
the document." lang="cn">可以用来在将粘贴的内容应用到文档之前转换一下。</p>
</dd><dt id="view.EditorProps.nodeViews"><code><strong><a href="#view.EditorProps.nodeViews">nodeViews</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">getPos:</span>&nbsp;<span class="fn">fn</span>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">decorations:</span>&nbsp;[<a href="#view.Decoration"><span class="type">Decoration</span></a>], <span class="param">innerDecorations:</span>&nbsp;<a href="#view.DecorationSource"><span class="type">DecorationSource</span></a>) →&nbsp;<a href="#view.NodeView"><span class="type">NodeView</span></a>&gt;</code></dt>

<dd>
<p data-en="Allows you to pass custom rendering and behavior logic for nodes
and marks. Should map node and mark names to constructor
functions that produce a NodeView object
implementing the node's display behavior. For nodes, the third
argument getPos is a function that can be called to get the
node's current position, which can be useful when creating
transactions to update it. For marks, the third argument is a
boolean that indicates whether the mark's content is inline." lang="cn">允许你为 node 或者 marks 自定义渲染和行为逻辑。该对象键是 node 或者 mark 名，值是对应的构造函数。
构造函数返回一个 <a href="#view.NodeView"><code>NodeView</code></a> 对象，来实现节点的展示逻辑。
对于 nodes 来说，第三个参数 <code>getPos</code> 是一个函数，调用它可以获取 node 当前的位置，这对于创建一个 transaction 然后更新它很有用。
对于 marks 来说，第三个参数是一个 boolean 值，指示 mark 的内容是否是 inline 的。</p>

<p data-en="decorations is an array of node or inline decorations that are
active around the node. They are automatically drawn in the
normal way, and you will usually just want to ignore this, but
they can also be used as a way to provide context information to
the node view without adding it to the document itself." lang="cn"><code>decoration</code> 是一个在当前 node 周围激活的 node decoration 或者 inline decoration 数组。
他们会自动绘制，通常情况下你可以忽略它们，不过它们也可以用来为 node view 提供上下文信息，而不是将它们添加到文档中。</p>
<p type="comment"><span>注: </span>最后一句话的意思是，在 plugin.props 的 decoration 属性上，你可以通过构造 decoration 的时候添加一些额外的信息，然后在 node view 中拿到这些信息来搞事情。</p>

<p data-en="innerDecorations holds the decorations for the node's content.
You can safely ignore this if your view has no content or a
contentDOM property, since the editor will draw the decorations
on the content. But if you, for example, want to create a nested
editor with the content, it may make sense to provide it with the
inner decorations." lang="cn"><code>innerDecorations</code> 指向节点内容的装饰器。如果你的 view 没有内容或者没有 <code>contentDOM</code> 属性的话，你可以安全的忽略它，因为
编辑器将会把该 decorations 绘制到其内容上。不过如果你的 view 有内容，比如，用该内容创建一个嵌套的 editor，那么提供给其内部元素的内部 decorations 就是有用的。</p>
<p type="comment"><span>注: </span>这个 <code>innerDecorations</code> 是新增的参数，之前是没有这个参数的，可以看下原仓库的修改记录。</p>
</dd><dt id="view.EditorProps.clipboardSerializer"><code><strong><a href="#view.EditorProps.clipboardSerializer">clipboardSerializer</a></strong>: ?⁠<a href="#model.DOMSerializer"><span class="type">DOMSerializer</span></a></code></dt>

<dd>
<p data-en="The DOM serializer to use when putting content onto the
clipboard. If not given, the result of
DOMSerializer.fromSchema
will be used." lang="cn">该函数用来序列化 DOM，然后将其放入粘贴板。如果没有给定，则会使用 <a href="#model.DOMSerializer%5EfromSchema"><code>DOMSerializer.fromSchema</code></a> 方法返回的结果。</p>
</dd><dt id="view.EditorProps.clipboardTextSerializer"><code><strong><a href="#view.EditorProps.clipboardTextSerializer">clipboardTextSerializer</a></strong>: ?⁠<span class="fn">fn</span>(<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="A function that will be called to get the text for the current
selection when copying text to the clipboard. By default, the
editor will use textBetween on the
selected range." lang="cn">当复制内容到粘贴板的时候，该方法将会被调用以用来获取选区内的文本。默认情况下，编辑器会在选区范围使用 <a href="#model.Node.textBetween"><code>textBetween</code></a> 方法。</p>
</dd><dt id="view.EditorProps.decorations"><code><strong><a href="#view.EditorProps.decorations">decorations</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;?⁠<a href="#view.DecorationSource"><span class="type">DecorationSource</span></a></code></dt>

<dd>
<p data-en="A set of document decorations to show in the
view." lang="cn">一个展示在 view 上的 <a href="#view.Decoration">document decorations（文档装饰器）</a> 集合。</p>
<p type="comment"><span>注: </span>之前该方法返回 DecorationSet，现在返回 DecorationSource，有兴趣的可以研究下区别。</p>
</dd><dt id="view.EditorProps.editable"><code><strong><a href="#view.EditorProps.editable">editable</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When this returns false, the content of the view is not directly
editable." lang="cn">当它返回 false，那么 view 的内容不能直接编辑。</p>
<p type="comment"><span>注: </span>不能直接编辑的意思就是用户不能将光标放入进去，然后编辑。但是仍然可以通过 dispatch transaction 进行编辑。</p>
</dd><dt id="view.EditorProps.attributes"><code><strong><a href="#view.EditorProps.attributes">attributes</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>&gt; | <span class="fn">fn</span>(<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>&gt;</code></dt>

<dd>
<p data-en="Control the DOM attributes of the editable element. May be either
an object or a function going from an editor state to an object.
By default, the element will get a class &quot;ProseMirror&quot;, and
will have its contentEditable attribute determined by the
editable prop. Additional classes
provided here will be added to the class. For other attributes,
the value provided first (as in
someProp) will be used." lang="cn">控制可编辑元素上的 DOM attributes。可以是一个对象，或者是一个函数接收编辑器的 state，然后返回一个对象。
默认情况下，元素将会被设置一个 <code>「ProseMirror」</code> 类名，以及一个由 <a href="#view.EditorProps.editable"><code>editable</code> prop</a> 决定的 <code>contentEditable</code> attributes。
在此处提供的其他类名将会被附加上去。对于其他 attributes，最先提供的将会被使用（就像 <a href="#view.EditorView.someProp"><code>someProp</code></a> 一样）。</p>
<p type="comment"><span>注: </span>原文中的 prop 和 attribute 我个人觉得应该分开翻译而不能都翻译成 <code>属性</code>，但是找不到合适的中文进行区分，
部分翻译资料（如上古时期的 jQuery），将 attr 和 prop 分别翻译成「属性」和「特性」，在此处感觉也不是很妥当，因此索性不翻译了。</p>
</dd><dt id="view.EditorProps.scrollThreshold"><code><strong><a href="#view.EditorProps.scrollThreshold">scrollThreshold</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a> | {<span class="prop">top:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">right:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">bottom:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">left:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Determines the distance (in pixels) between the cursor and the
end of the visible viewport at which point, when scrolling the
cursor into view, scrolling takes place. Defaults to 0." lang="cn">当滚动光标位置到视口的时候，决定光标与视口尾部的距离（单位是像素）多大才开始滚动。默认是 0。</p>
</dd><dt id="view.EditorProps.scrollMargin"><code><strong><a href="#view.EditorProps.scrollMargin">scrollMargin</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a> | {<span class="prop">top:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">right:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">bottom:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">left:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Determines the extra space (in pixels) that is left above or
below the cursor when it is scrolled into view. Defaults to 5." lang="cn">当光标滚动到视口中的时候，决定光标离视口上下方的距离，默认是 5（像素为单位）。</p>
</dd></dl>
<h4 id="view.DirectEditorProps">
  <a href="#view.DirectEditorProps">DirectEditorProps</a> <span class="kind">interface</span> <span class="extends">extends <code><a href="#view.EditorProps"><span class="type">EditorProps</span></a></code></span></h4>
<p data-en="The props object given directly to the editor view supports two
fields that can't be used in plugins:" lang="cn">直接在 view 中使用的 props 对象有两个字段不能被用在 plugin 的 props 字段上：</p>
<dl><dt id="view.DirectEditorProps.state"><code><strong><a href="#view.DirectEditorProps.state">state</a></strong>: <a href="#state.EditorState"><span class="type">EditorState</span></a></code></dt>

<dd>
<p data-en="The current state of the editor." lang="cn">编辑器当前的 state。</p>
<p type="comment"><span>注: </span>plugin 有自己的 state 字段，其与 props 平级，因此不作为 props 的属性。</p>
</dd><dt id="view.DirectEditorProps.dispatchTransaction"><code><strong><a href="#view.DirectEditorProps.dispatchTransaction">dispatchTransaction</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)</code></dt>

<dd>
<p data-en="The callback over which to send transactions (state updates)
produced by the view. If you specify this, you probably want to
make sure this ends up calling the view's
updateState method with a new
state that has the transaction
applied. The callback will be bound to have
the view instance as its this binding." lang="cn">view dispatch 一个 transaction 后（更新 state 前），transaction 会先经过此回调函数。
如果你设置了该函数，你应该需要保证该函数以调用 view 的 <a href="#view.EditorView.updateState"><code>updateState</code></a> 方法结束。
<code>updateState</code> 方法接受一个 <a href="#state.EditorState.apply">applied</a> 过该 transaction 的 state 作为参数。回调的 <code>this</code> 绑定到 view 实例上。</p>
</dd></dl>
<h4 id="view.NodeView">
  <a href="#view.NodeView">NodeView</a> <span class="kind">interface</span></h4>
<p data-en="By default, document nodes are rendered using the result of the
toDOM method of their spec, and managed
entirely by the editor. For some use cases, such as embedded
node-specific editing interfaces, you want more control over
the behavior of a node's in-editor representation, and need to
define a custom node view." lang="cn">默认情况下，文档节点使用它们 schema 配置对象中的 <a href="#model.NodeSpec.toDOM"><code>toDOM</code></a>
方法来渲染，然后完全由编辑器管理状态。而对于一些使用场景，比如为特定节点嵌入编辑界面等情况，
你可能想要更加细粒度的控制一个节点在编辑器中的表现形式，因此，你需要 <a href="#view.EditorProps.nodeViews">define</a> 一个自定义的 node view。</p>

<p data-en="Mark views only support dom and contentDOM, and don't support
any of the node view methods." lang="cn">Mark 的 view 仅仅支持 <code>dom</code> 和 <code>contentDOM</code>，而且不支持任何 node view 的方法。</p>

<p data-en="Objects returned as node views must conform to this interface." lang="cn">node views 们返回的对象必须保证有以下接口：</p>
<dl><dt id="view.NodeView.dom"><code><strong><a href="#view.NodeView.dom">dom</a></strong>: ?⁠<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a></code></dt>

<dd>
<p data-en="The outer DOM node that represents the document node. When not
given, the default strategy is used to create a DOM node." lang="cn">表示该文档节点的外层 DOM 节点。如果没有给出，那么默认的策略是创建一个 DOM 节点。</p>
</dd><dt id="view.NodeView.contentDOM"><code><strong><a href="#view.NodeView.contentDOM">contentDOM</a></strong>: ?⁠<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a></code></dt>

<dd>
<p data-en="The DOM node that should hold the node's content. Only meaningful
if the node view also defines a dom property and if its node
type is not a leaf node type. When this is present, ProseMirror
will take care of rendering the node's children into it. When it
is not present, the node view itself is responsible for rendering
(or deciding not to render) its child nodes." lang="cn">应该持有节点的内容的 DOM 节点。只有当定义了 <code>dom</code> 属性且节点类型不是叶子节点的时候才有意义。
当它设置的时候，ProseMirror 将会将节点的子节点渲染到该 DOM 中作为它的子节点；
如果没有设置，node view 本身有责任渲染（或者决定不渲染）它的子节点。</p>
</dd><dt id="view.NodeView.update"><code><strong><a href="#view.NodeView.update">update</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">decorations:</span>&nbsp;[<a href="#view.Decoration"><span class="type">Decoration</span></a>], <span class="param">innerDecorations:</span>&nbsp;<a href="#view.DecorationSource"><span class="type">DecorationSource</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When given, this will be called when the view is updating itself.
It will be given a node (possibly of a different type), an array
of active decorations around the node (which are automatically
drawn, and the node view may ignore if it isn't interested in
them), and a decoration source that
represents any decorations that apply to the content of the node
(which again may be ignored). It should return true if it was
able to update to that node, and false otherwise. If the node
view has a contentDOM property (or no dom property), updating
its child nodes will be handled by ProseMirror." lang="cn">当 node view 更新自身的时候会调用该节点的此方法。它接受一个 node（可能是与当前不同的类型）、
一个激活的 decorations 数组（它会自行渲染，如果 node view 对它的新的不感兴趣的话可以忽略）作为参数。
如果 node 需要被更新，则返回 true，否则返回 false。如果 node view 有一个 <code>contentDOM</code> 属性（或者 <code>dom</code>
属性），则它的子节点的更新将交给 ProseMirror 来控制。</p>
</dd><dt id="view.NodeView.selectNode"><code><strong><a href="#view.NodeView.selectNode">selectNode</a></strong>: ?⁠<span class="fn">fn</span>()</code></dt>

<dd>
<p data-en="Can be used to override the way the node's selected status (as a
node selection) is displayed." lang="cn">可以用来覆盖节点选中的展示状态（作为一个节点选区）。</p>
</dd><dt id="view.NodeView.deselectNode"><code><strong><a href="#view.NodeView.deselectNode">deselectNode</a></strong>: ?⁠<span class="fn">fn</span>()</code></dt>

<dd>
<p data-en="When defining a selectNode method, you should also provide a
deselectNode method to remove the effect again." lang="cn">当定义一个 <code>selectNode</code> 方法，你应该同时提供一个 <code>deselectNode</code> 方法去移除前者所做的效果。</p>
</dd><dt id="view.NodeView.setSelection"><code><strong><a href="#view.NodeView.setSelection">setSelection</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">anchor:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">head:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">root:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/document"><span class="type">dom.Document</span></a>)</code></dt>

<dd>
<p data-en="This will be called to handle setting the selection inside the
node. The anchor and head positions are relative to the start
of the node. By default, a DOM selection will be created between
the DOM positions corresponding to those positions, but if you
override it you can do something else." lang="cn">该方法将会被调用以用来处理节点内部选区的设置。<code>anchor</code> 和 <code>head</code> 位置相对于节点的起始位置。
默认情况下，将会在与这些位置相对应的 DOM 位置之间创建 DOM 选区，不过你可以通过覆盖该行为来做一些其他的事情。</p>
</dd><dt id="view.NodeView.stopEvent"><code><strong><a href="#view.NodeView.stopEvent">stopEvent</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/DOM/event"><span class="type">dom.Event</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Can be used to prevent the editor view from trying to handle some
or all DOM events that bubble up from the node view. Events for
which this returns true are not handled by the editor." lang="cn">可以用来阻止编辑器处理一些或者所有的源自 node view 的 DOM 事件。返回 true 表示编辑器不处理该事件。</p>
</dd><dt id="view.NodeView.ignoreMutation"><code><strong><a href="#view.NodeView.ignoreMutation">ignoreMutation</a></strong>: ?⁠<span class="fn">fn</span>(<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord"><span class="type">dom.MutationRecord</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Called when a DOM
mutation
or a selection change happens within the view. When the change is
a selection change, the record will have a type property of
&quot;selection&quot; (which doesn't occur for native mutation records).
Return false if the editor should re-read the selection or
re-parse the range around the mutation, true if it can safely be
ignored." lang="cn">当一个 DOM <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">mutation（突变）</a>
的时候调用，或者在 node view 内一个选区改变的时候调用。当是选区改变的时候，record 将会有一个值为 <code>「selection」</code> 的 <code>type</code>
属性（原生的 mutation records 没有）。返回 false 表示编辑器应该重新读取选区或者重新 parse 突变附近的 DOM，
返回 true 表示该突变可以被安全的忽略掉。</p>
</dd><dt id="view.NodeView.destroy"><code><strong><a href="#view.NodeView.destroy">destroy</a></strong>: ?⁠<span class="fn">fn</span>()</code></dt>

<dd>
<p data-en="Called when the node view is removed from the editor or the whole
editor is destroyed. (Not available for marks.)" lang="cn">当整个编辑器被销毁或者当前 node view 被移除的时候调用（对 marks 的 view 不可用）。</p>
<p>View descriptions are data structures that describe the DOM that is
used to represent the editor's content. They are used for:</p>
<ul>
<li>
<p>Incremental redrawing when the document changes</p>
</li>
<li>
<p>Figuring out what part of the document a given DOM position
corresponds to</p>
</li>
<li>
<p>Wiring in custom implementations of the editing interface for a
given node</p>
</li>
</ul>
<p>They form a doubly-linked mutable tree, starting at <code>view.docView</code>.</p>
</dd></dl>
<h3 id="view.Decorations"><a href="#view.Decorations">Decorations</a></h3>
<p>装饰器是用来影响文档的展现但是又不实际改变文档内容的一种方式。</p>
<p>（<code>展现</code>指的是视图层的东西如对话框等不是用户输入的内容，文档内容是指用户输入的内容--译者注）</p>
<h4 id="view.Decoration">
  <a href="#view.Decoration">Decoration</a> <span class="kind">class</span></h4>
<p data-en="Decoration objects can be provided to the view through the
decorations prop. They come in
several variants—see the static members of this class for details." lang="cn">Decoration（装饰器）对象可以通过 <a href="#view.EditorProps.decorations"><code>decoration</code> 属性</a>提供给 view。
它们有多个不同的变体，有关的详细信息，参见此类的静态成员。</p>
<p type="comment"><span>注: </span>Decoration 有三种，widget 挂件装饰器；inline 行内装饰器；node 节点装饰器；</p>
<dl><dt id="view.Decoration.from"><code><strong><a href="#view.Decoration.from">from</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The start position of the decoration." lang="cn">decoration 开始的位置</p>
</dd><dt id="view.Decoration.to"><code><strong><a href="#view.Decoration.to">to</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The end position. Will be the same as from for widget
decorations." lang="cn">decoration 结束的位置。如果是 <a href="#view.Decoration%5Ewidget">widget decorations</a> 的话，该值将会和 <code>from</code> 一致。</p>
</dd><dt id="view.Decoration.spec"><code><strong><a href="#view.Decoration.spec">spec</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="The spec provided when creating this decoration. Can be useful
if you've stored extra information in that object." lang="cn">当创建 decoration 的时候提供的配置。用来存储一些额外的信息非常有用。</p>
</dd><dt id="view.Decoration^widget"><code>static <strong><a href="#view.Decoration^widget">widget</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">toDOM:</span>&nbsp;<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">getPos:</span>&nbsp;<span class="fn">fn</span>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a> | <a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="param">spec:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#view.Decoration"><span class="type">Decoration</span></a></code></dt>

<dd>
<p data-en="Creates a widget decoration, which is a DOM node that's shown in
the document at the given position. It is recommended that you
delay rendering the widget by passing a function that will be
called when the widget is actually drawn in a view, but you can
also directly pass a DOM node. getPos can be used to find the
widget's current document position." lang="cn">创建一个 widget decorations，它是一个显示在给定位置的 DOM 节点。推荐的方式是通过传递一个函数来返回 decoration，以实现当该 decoration
绘制在 view 的时候延迟渲染的目的，不过你也可以直接传递一个 DOM 节点。<code>getPos</code> 方法用来获取 widget 在当前文档的位置。</p>
<dl><dt id="view.Decoration^widget^spec"><code><strong><a href="#view.Decoration^widget^spec">spec</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="These options are supported:" lang="cn">支持以下可选参数：</p>
<dl><dt id="view.Decoration^widget^spec.side"><code><strong><a href="#view.Decoration^widget^spec.side">side</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Controls which side of the document position this widget is
associated with. When negative, it is drawn before a cursor
at its position, and content inserted at that position ends
up after the widget. When zero (the default) or positive, the
widget is drawn after the cursor and content inserted there
ends up before the widget." lang="cn">控制该 widget 与文档位置的哪一侧相关。当是负数的时候，它绘制在给定位置光标的之前，
并且在该位置插入的内容在 widget 之后。当非负（默认）的时候，widget 绘制在给定位置光标之后，用户输入的内容会插入到该位置之前。</p>

<p data-en="When there are multiple widgets at a given position, their
side values determine the order in which they appear. Those
with lower values appear first. The ordering of widgets with
the same side value is unspecified." lang="cn">当在同一个位置有多个 widget 的时候，他们的 <code>side</code> 决定了它们出现的顺序。较小的值出现在前面。
相同 <code>side</code> 值的话先后位置不确定。</p>
<p type="comment"><span>注: </span>相同 <code>side</code> 值 widget 出现的先后位置不确定，原因跟某些算法排序的 <code>稳定</code> 概念类似。</p>

<p data-en="When marks is null, side also determines the marks that
the widget is wrapped in—those of the node before when
negative, those of the node after when positive." lang="cn">当 <code>marks</code> 是 null 的时候，<code>side</code> 同样决定 widget 包裹的 marks。节点之前的是负的，节点之后的是正的。</p>
</dd><dl><dt id="view.Decoration^widget^spec.marks"><code><strong><a href="#view.Decoration^widget^spec.marks">marks</a></strong>: ?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="The precise set of marks to draw around the widget." lang="cn">绘制在 widget 周围的 marks。</p>
</dd><dl><dt id="view.Decoration^widget^spec.stopEvent"><code><strong><a href="#view.Decoration^widget^spec.stopEvent">stopEvent</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/DOM/event"><span class="type">dom.Event</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Can be used to control which DOM events, when they bubble out
of this widget, the editor view should ignore." lang="cn">可以用来控制编辑器应该忽略从 widget 冒泡出来的哪些 DOM 事件。</p>
</dd><dl><dt id="view.Decoration^widget^spec.ignoreSelection"><code><strong><a href="#view.Decoration^widget^spec.ignoreSelection">ignoreSelection</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When set (defaults to false), selection changes inside the
widget are ignored, and don't cause ProseMirror to try and
re-sync the selection with its selection state." lang="cn">当设置的时候（默认是 false），在 widget 内的选区变化将被忽略，
这样的话该变化就不会让 ProseMirror 尝试重新同步该选区和 state 的选区。</p>
</dd><dl><dt id="view.Decoration^widget^spec.key"><code><strong><a href="#view.Decoration^widget^spec.key">key</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="When comparing decorations of this type (in order to decide
whether it needs to be redrawn), ProseMirror will by default
compare the widget DOM node by identity. If you pass a key,
that key will be compared instead, which can be useful when
you generate decorations on the fly and don't want to store
and reuse DOM nodes. Make sure that any widgets with the same
key are interchangeable—if widgets differ in, for example,
the behavior of some event handler, they should get
different keys." lang="cn">当比较此种类型的 decorations 的时候（以决定它是否应该被重绘），ProseMirror
将会默认通过 widget DOM 节点来识别。如果你传递了一个 key，那它就会用 key 来对比。
这对于你仅仅想在内存中创建 decorations 而不真正绘制 DOM 结构很有用。确保任何具有相同 key 的 widget
是可互换的--比如，如果 widget 的一些事件处理函数不一样，即使 DOM 结构相同，也应该有不同的 key。</p>
</dd></dl></dl></dl></dl></dl></dd></dl></dd><dt id="view.Decoration^inline"><code>static <strong><a href="#view.Decoration^inline">inline</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">attrs:</span>&nbsp;<a href="#view.DecorationAttrs"><span class="type">DecorationAttrs</span></a>, <span class="param">spec:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#view.Decoration"><span class="type">Decoration</span></a></code></dt>

<dd>
<p data-en="Creates an inline decoration, which adds the given attributes to
each inline node between from and to." lang="cn">创建一个内联的 decoration，它会在 <code>from</code> 和 <code>to</code> 之间的每一个内联节点上添加给定的 attributes。</p>
<dl><dt id="view.Decoration^inline^spec"><code><strong><a href="#view.Decoration^inline^spec">spec</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="These options are recognized:" lang="cn">支持一下可选参数：</p>
<dl><dt id="view.Decoration^inline^spec.inclusiveStart"><code><strong><a href="#view.Decoration^inline^spec.inclusiveStart">inclusiveStart</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Determines how the left side of the decoration is
mapped when content is
inserted directly at that position. By default, the decoration
won't include the new content, but you can set this to true
to make it inclusive." lang="cn">决定如果内容直接插入在这个位置的时候，decoration 的左侧如何 <a href="#transform.Position_Mapping">mapped</a>。
默认情况下，decoration 不会包括新的内容，不过你可以设置为 <code>true</code> 来让它影响新内容。</p>
</dd><dl><dt id="view.Decoration^inline^spec.inclusiveEnd"><code><strong><a href="#view.Decoration^inline^spec.inclusiveEnd">inclusiveEnd</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Determines how the right side of the decoration is mapped.
See
inclusiveStart." lang="cn">决定 decoration 的右侧如何被 mapped。具体看 <a href="#view.Decoration%5Einline%5Espec.inclusiveStart"><code>inclusiveStart</code></a>。</p>
</dd></dl></dl></dd></dl></dd><dt id="view.Decoration^node"><code>static <strong><a href="#view.Decoration^node">node</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">attrs:</span>&nbsp;<a href="#view.DecorationAttrs"><span class="type">DecorationAttrs</span></a>, <span class="param">spec:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#view.Decoration"><span class="type">Decoration</span></a></code></dt>

<dd>
<p data-en="Creates a node decoration. from and to should point precisely
before and after a node in the document. That node, and only that
node, will receive the given attributes." lang="cn">创建一个 node decoration。<code>from</code> 和 <code>to</code> 应该精确的指向在文档中的某个节点的前面和后面。该节点，也只有该节点，会受到给定的 attributes。</p>
<dl><dt id="view.Decoration^node^spec"><code><strong><a href="#view.Decoration^node^spec">spec</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Optional information to store with the decoration. It
is also used when comparing decorators for equality." lang="cn">decoration 存储的可选的信息。也用来比较 decorators（装饰器们）是否相等。</p>
</dd></dl></dd></dl>
<h4 id="view.DecorationAttrs">
  <a href="#view.DecorationAttrs">DecorationAttrs</a> <span class="kind">interface</span></h4>
<p data-en="A set of attributes to add to a decorated node. Most properties
simply directly correspond to DOM attributes of the same name,
which will be set to the property's value. These are exceptions:" lang="cn">一个被用来添加到被装饰的节点附近的 attributes 集合。大多数 properties
的名字与同名的 DOM attributes 一样，以用来被设置为属性值。下面几个是特例：</p>
<dl><dt id="view.DecorationAttrs.class"><code><strong><a href="#view.DecorationAttrs.class">class</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="A CSS class name or a space-separated set of class names to be
added to the classes that the node already had." lang="cn">会被 <em>添加</em> 到节点已有的类名上的 CSS 的类名，或者用空格分隔的 css 类名集合。</p>
</dd><dt id="view.DecorationAttrs.style"><code><strong><a href="#view.DecorationAttrs.style">style</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="A string of CSS to be added to the node's existing style property." lang="cn">会被 <em>添加</em> 到节点已有的 <code>style</code> 属性上的 CSS 字符串。</p>
</dd><dt id="view.DecorationAttrs.nodeName"><code><strong><a href="#view.DecorationAttrs.nodeName">nodeName</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="When non-null, the target node is wrapped in a DOM element of
this type (and the other attributes are applied to this element)." lang="cn">如果该值为非 null，则目标节点将会用该类型的节点包裹住（同时其他的属性会被应用到该元素上）。</p>
</dd></dl>
<h4 id="view.DecorationSet">
  <a href="#view.DecorationSet">DecorationSet</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#view.DecorationSource"><span class="type">DecorationSource</span></a></code></span></h4>
<p data-en="A collection of decorations, organized in
such a way that the drawing algorithm can efficiently use and
compare them. This is a persistent data structure—it is not
modified, updates create a new value." lang="cn">一个 <a href="#view.Decoration">decorations</a> 集合，用这种数据结构组织它们可以让绘制算法高效的对比和渲染它们。
它是一个不可突变的数据结构，它不改变，更新会产生新的值。</p>
<dl><dt id="view.DecorationSet.find"><code><strong><a href="#view.DecorationSet.find">find</a></strong>(<span class="param">start:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">end:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">predicate:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">spec:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;[<a href="#view.Decoration"><span class="type">Decoration</span></a>]</code></dt>

<dd>
<p data-en="Find all decorations in this set which touch the given range
(including decorations that start or end directly at the
boundaries) and match the given predicate on their spec. When
start and end are omitted, all decorations in the set are
considered. When predicate isn't given, all decorations are
assumed to match." lang="cn">找到给定范围涉及到的所有的 decoration 集合（包括开始或结束位置在边界的 decorations），
然后用给定的 predicate 函数来检测是否匹配，该函数参数是 decoration 的配置对象。
若 <code>start</code> 和 <code>end</code> 省略，则集合中所有的 decoration 将会被检测。如果 <code>predicate</code> 没有给出，则所有的 decorations 将会 match。</p>
</dd><dt id="view.DecorationSet.map"><code><strong><a href="#view.DecorationSet.map">map</a></strong>(<span class="param">mapping:</span>&nbsp;<a href="#transform.Mapping"><span class="type">Mapping</span></a>, <span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">options:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#view.DecorationSet"><span class="type">DecorationSet</span></a></code></dt>

<dd>
<p data-en="Map the set of decorations in response to a change in the
document." lang="cn">Map decorations 的集合以响应文档修改。</p>
<dl><dt id="view.DecorationSet.map^options"><code><strong><a href="#view.DecorationSet.map^options">options</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="An optional set of options." lang="cn">有如下参数可选：</p>
<dl><dt id="view.DecorationSet.map^options.onRemove"><code><strong><a href="#view.DecorationSet.map^options.onRemove">onRemove</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">decorationSpec:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>)</code></dt>

<dd>
<p data-en="When given, this function will be called for each decoration
that gets dropped as a result of the mapping, passing the
spec of that decoration." lang="cn">当设置该函数的时候，该函数会对在 mapping 过程中被移除的 decoration 调用该函数，传递 decoration 的配置对象。</p>
</dd></dl></dd></dl></dd><dt id="view.DecorationSet.add"><code><strong><a href="#view.DecorationSet.add">add</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">decorations:</span>&nbsp;[<a href="#view.Decoration"><span class="type">Decoration</span></a>]) →&nbsp;<a href="#view.DecorationSet"><span class="type">DecorationSet</span></a></code></dt>

<dd>
<p data-en="Add the given array of decorations to the ones in the set,
producing a new set. Needs access to the current document to
create the appropriate tree structure." lang="cn">在当前 decorations 集合中增加给定数组中的 decorations，以产生一个新的集合。
需要传递当前文档 doc 以创建合适的树状结构。</p>
</dd><dt id="view.DecorationSet.remove"><code><strong><a href="#view.DecorationSet.remove">remove</a></strong>(<span class="param">decorations:</span>&nbsp;[<a href="#view.Decoration"><span class="type">Decoration</span></a>]) →&nbsp;<a href="#view.DecorationSet"><span class="type">DecorationSet</span></a></code></dt>

<dd>
<p data-en="Create a new set that contains the decorations in this set, minus
the ones in the given array." lang="cn">用当前的 decorations 集合减去给定数组中的 decorations，得到一个新的 decorations 集合。</p>
</dd><dt id="view.DecorationSet^create"><code>static <strong><a href="#view.DecorationSet^create">create</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">decorations:</span>&nbsp;[<a href="#view.Decoration"><span class="type">Decoration</span></a>]) →&nbsp;<a href="#view.DecorationSet"><span class="type">DecorationSet</span></a></code></dt>

<dd>
<p data-en="Create a set of decorations, using the structure of the given
document." lang="cn">用给定文档的结构，创建一个 decorations 集合。</p>
</dd><dt id="view.DecorationSet^empty"><code>static <strong><a href="#view.DecorationSet^empty">empty</a></strong>: <a href="#view.DecorationSet"><span class="type">DecorationSet</span></a></code></dt>

<dd>
<p data-en="The empty set of decorations." lang="cn">decorations 的空集合。</p>
</dd></dl>
<h4 id="view.DecorationSource">
  <a href="#view.DecorationSource">DecorationSource</a> <span class="kind">interface</span></h4>
<p data-en="An object that can provide
decorations. Implemented by DecorationSet,
and passed to node views." lang="cn">一个可以提供 <a href="#view.EditorProps.decorations">decorations</a> 的对象。被 <a href="#view.DecorationSet"><code>DecorationSet</code></a> 实现，会被传给 <a href="#view.EditorProps.nodeViews">node views</a> 方法。</p>
<dl></dl>
</section><section id=part_model>
    <h2 class=module id=model>
      <a href="#model">prosemirror-model <span class=kind>module</span></a>
    </h2>
<p data-en="This module defines ProseMirror's content model, the data structures used to represent and work with documents." lang="cn">这个模块定义了 ProseMirror 的内容模型，它的数据结构被用来表示文档和其内的节点并让它们按预期工作。</p>
<h3 id="model.Document_Structure"><a href="#model.Document_Structure">Document Structure</a></h3>

<p data-en="A ProseMirror document is a tree. At each level, a node
describes the type of the content, and holds a
fragment containing its children." lang="cn">一个 ProseMirror 的文档是一个树状结构。在每个层级中，一个 <a href="#model.Node">node</a>
描述了内容的类型，同时通过 <a href="#model.Fragment">fragment</a> 来保持对其子节点的引用。</p>
<h4 id="model.Node">
  <a href="#model.Node">Node</a> <span class="kind">class</span></h4>
<p data-en="This class represents a node in the tree that makes up a
ProseMirror document. So a document is an instance of Node, with
children that are also instances of Node." lang="cn">这个类表示 ProseMirror 中组成文档树的节点，因此一个文档就是一个 <code>Node</code> 的实例，以及它的子节点同样是 <code>Node</code> 的实例。</p>

<p data-en="Nodes are persistent data structures. Instead of changing them, you
create new ones with the content you want. Old ones keep pointing
at the old document shape. This is made cheaper by sharing
structure between the old and new data as much as possible, which a
tree shape like this (without back pointers) makes easy." lang="cn">节点都是一些持久化的数据结构。每次更新会创建一个新的节点与一些你想要的内容，而不是改变旧的节点。旧的节点始终保持旧文档的引用。
这使得在旧的和新的数据之间共享结构变得容易，因为像这样的树状结构没有「向后的指针」（？）</p>

<p data-en="Do not directly mutate the properties of a Node object. See
the guide for more information." lang="cn"><strong>不要</strong> 直接修改 <code>Node</code> 对象的属性。查看 <a href="https://xheldon.com/prosemirror-guide-chinese.html#documents">中文指南</a>获取更多信息。</p>
<dl><dt id="model.Node.type"><code><strong><a href="#model.Node.type">type</a></strong>: <a href="#model.NodeType"><span class="type">NodeType</span></a></code></dt>

<dd>
<p data-en="The type of node that this is." lang="cn">当前节点的类型。</p>
</dd><dt id="model.Node.attrs"><code><strong><a href="#model.Node.attrs">attrs</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="An object mapping attribute names to values. The kind of
attributes allowed and required are
determined by the node type." lang="cn">一个键值对。允许的和需要的 attributes <a href="#model.NodeSpec.attrs">取决于</a> 节点类型。</p>
</dd><dt id="model.Node.content"><code><strong><a href="#model.Node.content">content</a></strong>: <a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="A container holding the node's children." lang="cn">一个持有节点子元素的容器。</p>
<p type="comment"><span>注: </span>该容器是 Fragment 类型</p>
</dd><dt id="model.Node.marks"><code><strong><a href="#model.Node.marks">marks</a></strong>: [<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="The marks (things like whether it is emphasized or part of a
link) applied to this node." lang="cn">应用到当前节点的 marks（marks 是一些类似于加粗或者链接一样的节点）</p>
</dd><dt id="model.Node.text"><code><strong><a href="#model.Node.text">text</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="For text nodes, this contains the node's text content." lang="cn">对于文本节点，它包含了节点的文本内容。</p>
</dd><dt id="model.Node.nodeSize"><code><strong><a href="#model.Node.nodeSize">nodeSize</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The size of this node, as defined by the integer-based indexing
scheme. For text nodes, this is the
amount of characters. For other leaf nodes, it is one. For
non-leaf nodes, it is the size of the content plus two (the start
and end token)." lang="cn">表示该节点的大小，由基于整数的 <a href="https://xheldon.com/prosemirror-guide-chinese.html#indexing">indexing scheme</a> 决定。
对于文本节点，它是字符数，对于其他叶子节点，是 1。对于非叶子节点，它是其内容的大小加上 2（开始和结束标签）。</p>
<p type="comment"><span>注: </span>indexing scheme 链接指向中文翻译指南，请搜索 Document 一节 下的 Indexing 一节。</p>
</dd><dt id="model.Node.childCount"><code><strong><a href="#model.Node.childCount">childCount</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The number of children that the node has." lang="cn">该节点拥有的子节点个数。</p>
</dd><dt id="model.Node.child"><code><strong><a href="#model.Node.child">child</a></strong>(<span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Get the child node at the given index. Raises an error when the
index is out of range." lang="cn">获取给定 index 处的子节点。如果 index 超出范围，则返回错误。</p>
</dd><dt id="model.Node.maybeChild"><code><strong><a href="#model.Node.maybeChild">maybeChild</a></strong>(<span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Get the child node at the given index, if it exists." lang="cn">获取给定 index 处的子节点，如果存在的话。</p>
<p type="comment"><span>注: </span>不存在返回 undefined。</p>
</dd><dt id="model.Node.forEach"><code><strong><a href="#model.Node.forEach">forEach</a></strong>(<span class="param">f:</span>&nbsp;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">offset:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>))</code></dt>

<dd>
<p data-en="Call f for every child node, passing the node, its offset
into this parent node, and its index." lang="cn">对每个子节点调用 <code>f</code> 函数，参数是子节点、子节点相对于当前节点的偏移以及它的 index。</p>
</dd><dt id="model.Node.nodesBetween"><code><strong><a href="#model.Node.nodesBetween">nodesBetween</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">f:</span>&nbsp;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">parent:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>, <span class="param">startPos:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 0</span>)</code></dt>

<dd>
<p data-en="Invoke a callback for all descendant nodes recursively between
the given two positions that are relative to start of this node's
content. The callback is invoked with the node, its
parent-relative position, its parent node, and its child index.
When the callback returns false for a given node, that node's
children will not be recursed over. The last parameter can be
used to specify a starting position to count from." lang="cn">在相对于当前节点内容开始位置的两个位置之间对所有的后代节点递归的调用 <code>f</code> 回调。
回调的参数是后代节点、后代节点开始位置相对于当前节点的偏移、后代节点的父节点、以及它在父节点中的 index。</p>
</dd><dt id="model.Node.descendants"><code><strong><a href="#model.Node.descendants">descendants</a></strong>(<span class="param">f:</span>&nbsp;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">parent:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>)</code></dt>

<dd>
<p data-en="Call the given callback for every descendant node. Doesn't
descend into a node when the callback returns false." lang="cn">对每一个后代节点调用给定的回调函数 <code>f</code>。当回调处理一个节点的时候返回 false ，则后续不会继续对该节点的子节点再调用该回调了。</p>
<p type="comment"><span>注: </span>上述递归都是深度优先。</p>
</dd><dt id="model.Node.textContent"><code><strong><a href="#model.Node.textContent">textContent</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Concatenates all the text nodes found in this fragment and its
children." lang="cn">该节点的所有文本内容连接为一个字符串返回。</p>
</dd><dt id="model.Node.textBetween"><code><strong><a href="#model.Node.textBetween">textBetween</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">blockSeparator:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">leafText:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Get all text between positions from and to. When
blockSeparator is given, it will be inserted whenever a new
block node is started. When leafText is given, it'll be
inserted for every non-text leaf node encountered." lang="cn">获取 <code>from</code> 和 <code>to</code> 之间的所有文本内容。当 <code>blockSeparator</code> 给定的时候，它将会插入到每一个新的块级节点开始的地方。
当 <code>leafText</code> 给定的时候，它将会插入到遇到的每一个非文本叶子节点后面。</p>
</dd><dt id="model.Node.firstChild"><code><strong><a href="#model.Node.firstChild">firstChild</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Returns this node's first child, or null if there are no
children." lang="cn">返回节点的第一个子节点，如果没有则是 <code>null</code>。</p>
</dd><dt id="model.Node.lastChild"><code><strong><a href="#model.Node.lastChild">lastChild</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Returns this node's last child, or null if there are no
children." lang="cn">返回节点的最后一个子节点，如果没有则是 <code>null</code>。</p>
</dd><dt id="model.Node.eq"><code><strong><a href="#model.Node.eq">eq</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether two nodes represent the same piece of document." lang="cn">测试两个节点是否表示的是文档中相同的部分。</p>
<p type="comment"><span>注: </span>比较的手段是先比较节点的引用，如果相等直接为 true；否则比较 markup 是否相等，如果不是则返回 false，如果是再递归比较二者的子节点。</p>
<p type="comment"><span>注: </span>markup 指的是节点类型、节点 attributes、和其上的 marks。</p>
</dd><dt id="model.Node.sameMarkup"><code><strong><a href="#model.Node.sameMarkup">sameMarkup</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Compare the markup (type, attributes, and marks) of this node to
those of another. Returns true if both have the same markup." lang="cn">比较当前与给定节点的 markup（包含类型、attributes 和 marks）是否相等。如果相同返回 <code>true</code>。</p>
</dd><dt id="model.Node.hasMarkup"><code><strong><a href="#model.Node.hasMarkup">hasMarkup</a></strong>(<span class="param">type:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Check whether this node's markup correspond to the given type,
attributes, and marks." lang="cn">检查节点是否有给定的类型、attributes 和 marks。</p>
</dd><dt id="model.Node.copy"><code><strong><a href="#model.Node.copy">copy</a></strong>(<span class="param">content:</span>&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a><span class="defaultvalue"> = null</span>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Create a new node with the same markup as this node, containing
the given content (or empty, if no content is given)." lang="cn">新建一个与当前节点有相同 markup 的节点，包含给定的内容（如果没有给定内容则为空）。</p>
</dd><dt id="model.Node.mark"><code><strong><a href="#model.Node.mark">mark</a></strong>(<span class="param">marks:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Create a copy of this node, with the given set of marks instead
of the node's own marks." lang="cn">新建一个当前节点的副本，包含给定的 marks，而不是当前节点原始的 marks。</p>
</dd><dt id="model.Node.cut"><code><strong><a href="#model.Node.cut">cut</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Create a copy of this node with only the content between the
given positions. If to is not given, it defaults to the end of
the node." lang="cn">创建一个当前节点的副本，该节点仅包含给定位置范围的内容。如果 <code>to</code> 没有给定，则默认是当前节点的结束位置。</p>
</dd><dt id="model.Node.slice"><code><strong><a href="#model.Node.slice">slice</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = this.content.size</span>) →&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="Cut out the part of the document between the given positions, and
return it as a Slice object." lang="cn">剪切文档给定位置范围的部分，然后作为 <code>Slice</code> 对象返回。</p>
</dd><dt id="model.Node.replace"><code><strong><a href="#model.Node.replace">replace</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Replace the part of the document between the given positions with
the given slice. The slice must 'fit', meaning its open sides
must be able to connect to the surrounding content, and its
content nodes must be valid children for the node they are placed
into. If any of this is violated, an error of type
ReplaceError is thrown." lang="cn">用给定的 slice 替换给定位置范围的文档内容。slice 必须「适合」该位置范围，也就是说，slice 打开的两侧必须能够正确的连接它两侧被切开的周围的内容，
同时它的子节点也必须符合放入位置的祖先节点的 scheme 约束。如果有任何违背，那么将会抛出一个 <a href="#model.ReplaceError"><code>ReplaceError</code></a>。</p>
</dd><dt id="model.Node.nodeAt"><code><strong><a href="#model.Node.nodeAt">nodeAt</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Find the node directly after the given position." lang="cn">返回给定位置右侧的节点。</p>
<p>@commetn 「右侧」为紧挨着给定位置的右侧节点，不存在则为 null。</p>
</dd><dt id="model.Node.childAfter"><code><strong><a href="#model.Node.childAfter">childAfter</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;{<span class="prop">node:&nbsp;</span>?⁠<a href="#model.Node"><span class="type">Node</span></a>, <span class="prop">index:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">offset:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Find the (direct) child node after the given offset, if any,
and return it along with its index and offset relative to this
node." lang="cn">如果有的话，返回给定偏移量后面的直接子节点，同时返回它的 index 以及相对于当前节点的偏移。</p>
</dd><dt id="model.Node.childBefore"><code><strong><a href="#model.Node.childBefore">childBefore</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;{<span class="prop">node:&nbsp;</span>?⁠<a href="#model.Node"><span class="type">Node</span></a>, <span class="prop">index:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">offset:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Find the (direct) child node before the given offset, if any,
and return it along with its index and offset relative to this
node." lang="cn">如果有的话，返回给定偏移量前面的直接子节点，同时返回它的 index 以及相对于当前节点的偏移。</p>
</dd><dt id="model.Node.resolve"><code><strong><a href="#model.Node.resolve">resolve</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="Resolve the given position in the document, returning an
object with information about its context." lang="cn">resolve 文档中给定的位置，返回一个关于此位置上下文信息的 <a href="#model.ResolvedPos">object</a>。</p>
</dd><dt id="model.Node.rangeHasMark"><code><strong><a href="#model.Node.rangeHasMark">rangeHasMark</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">type:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a> | <a href="#model.MarkType"><span class="type">MarkType</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether a given mark or mark type occurs in this document
between the two given positions." lang="cn">测试文档中给定的位置范围内是否有给定的 mark 或者 mark 类型。</p>
</dd><dt id="model.Node.isBlock"><code><strong><a href="#model.Node.isBlock">isBlock</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this is a block (non-inline node)" lang="cn">是否是一个块级节点（非内联节点的都是块级节点）。</p>
</dd><dt id="model.Node.isTextblock"><code><strong><a href="#model.Node.isTextblock">isTextblock</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this is a textblock node, a block node with inline
content." lang="cn">是否是一个文本块节点（textblock），即有内联内容的块级节点。</p>
</dd><dt id="model.Node.inlineContent"><code><strong><a href="#model.Node.inlineContent">inlineContent</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this node allows inline content." lang="cn">节点是否允许内联内容。</p>
</dd><dt id="model.Node.isInline"><code><strong><a href="#model.Node.isInline">isInline</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this is an inline node (a text node or a node that can
appear among text)." lang="cn">节点是否是内联节点（文本节点或者能够出现在文本之间的节点都是内联节点）。</p>
</dd><dt id="model.Node.isText"><code><strong><a href="#model.Node.isText">isText</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this is a text node." lang="cn">是否是文本节点。</p>
</dd><dt id="model.Node.isLeaf"><code><strong><a href="#model.Node.isLeaf">isLeaf</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this is a leaf node." lang="cn">是否是一个叶子节点。</p>
</dd><dt id="model.Node.isAtom"><code><strong><a href="#model.Node.isAtom">isAtom</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this is an atom, i.e. when it does not have directly
editable content. This is usually the same as isLeaf, but can
be configured with the atom property on
a node's spec (typically used when the node is displayed as an
uneditable node view)." lang="cn">是否是一个原子节点，例如，它没有一个直接可编辑的内容。它的值通常与 <code>isLeaf</code> 一样，不过可以通过节点配置对象上的 <a href="#model.NodeSpec.atom"><code>atom</code> 属性</a> 进行设置。
（典型的使用场景是节点展示成一个不可编辑的 <a href="#view.NodeView">node view</a>）。</p>
</dd><dt id="model.Node.toString"><code><strong><a href="#model.Node.toString">toString</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Return a string representation of this node for debugging
purposes." lang="cn">为了 debug 目的获取当前节点的字符串表示。</p>
</dd><dt id="model.Node.contentMatchAt"><code><strong><a href="#model.Node.contentMatchAt">contentMatchAt</a></strong>(<span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#model.ContentMatch"><span class="type">ContentMatch</span></a></code></dt>

<dd>
<p data-en="Get the content match in this node at the given index." lang="cn">获取当前节点给定 index 的 content match。</p>
<p type="comment"><span>注: </span>content match 在 ProseMirror 中也是一个专有名词。</p>
</dd><dt id="model.Node.canReplace"><code><strong><a href="#model.Node.canReplace">canReplace</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">replacement:</span>&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a><span class="defaultvalue"> = Fragment.empty</span>, <span class="param">start:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 0</span>, <span class="param">end:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether replacing the range between from and to (by
child index) with the given replacement fragment (which defaults
to the empty fragment) would leave the node's content valid. You
can optionally pass start and end indices into the
replacement fragment." lang="cn">测试用给定的 fragment（默认是空的 fragment） 替换 <code>from</code> 到 <code>to</code>（from 和 to 是子节点位置 index） 之间的内容是否合法（即符合 schema 约束）。
你可以可选的传入 <code>start</code> 和 <code>end</code>（start 和 end 都是子节点的位置 index）以只用 fragment 的一部分替换。</p>
</dd><dt id="model.Node.canReplaceWith"><code><strong><a href="#model.Node.canReplaceWith">canReplaceWith</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">type:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether replacing the range from to to (by index) with a
node of the given type would leave the node's content valid." lang="cn">测试用给定的节点类型替换当前节点 <code>from</code> 到 <code>to</code> index 之间的子元素是否合法。</p>
</dd><dt id="model.Node.canAppend"><code><strong><a href="#model.Node.canAppend">canAppend</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether the given node's content could be appended to this
node. If that node is empty, this will only return true if there
is at least one node type that can appear in both nodes (to avoid
merging completely incompatible nodes)." lang="cn">测试给定节点的内容可以被附加到当前节点最后。如果给定节点是空的，那么只有当至少一个节点类型能够出现在这两个节点之内的时候才会返回 true（以避免合并完全不兼容的节点）。</p>
</dd><dt id="model.Node.check"><code><strong><a href="#model.Node.check">check</a></strong>()</code></dt>

<dd>
<p data-en="Check whether this node and its descendants conform to the
schema, and raise error when they do not." lang="cn">检查当前节点和节点的所有后代是否符合当前节点的 schema，如果不符合的话会抛出一个错误。</p>
</dd><dt id="model.Node.toJSON"><code><strong><a href="#model.Node.toJSON">toJSON</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Return a JSON-serializeable representation of this node." lang="cn">返回一个当前节点 JSON 序列化的表示。</p>
<p type="comment"><span>注: </span>不像我们认为的 JSON 序列化后与 <code>stringify</code> 过一样是个字符串，这里的序列化后是个对象。</p>
</dd><dt id="model.Node^fromJSON"><code>static <strong><a href="#model.Node^fromJSON">fromJSON</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>, <span class="param">json:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Deserialize a node from its JSON representation." lang="cn">从一个节点 JSON 序列化的对象中反序列化出 Node 节点。</p>
</dd></dl>
<h4 id="model.Fragment">
  <a href="#model.Fragment">Fragment</a> <span class="kind">class</span></h4>
<p data-en="A fragment represents a node's collection of child nodes." lang="cn">一个 fragment 表示了节点的子节点集合。</p>

<p data-en="Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy." lang="cn">像 nodes 一样，fragment 也是一个持久化数据结构，你不应该直接修改他们或者他们的内容，而应该创建一个新的实例。下面的 API 就是用来试图将这件事变得容易。</p>
<dl><dt id="model.Fragment.size"><code><strong><a href="#model.Fragment.size">size</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The size of the fragment, which is the total of the size of its
content nodes." lang="cn">fragment 的大小，也即它的内容节点大小的总和。</p>
</dd><dt id="model.Fragment.nodesBetween"><code><strong><a href="#model.Fragment.nodesBetween">nodesBetween</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">f:</span>&nbsp;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">start:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">parent:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>, <span class="param">nodeStart:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 0</span>)</code></dt>

<dd>
<p data-en="Invoke a callback for all descendant nodes between the given two
positions (relative to start of this fragment). Doesn't descend
into a node when the callback returns false." lang="cn">对相对于 fragment 开始位置的两个位置范围内的节点调用 <code>f</code> 回调。如果某个节点的回调返回 <code>false</code>，则不会对该节点的内部节点再调用该回调了。</p>
</dd><dt id="model.Fragment.descendants"><code><strong><a href="#model.Fragment.descendants">descendants</a></strong>(<span class="param">f:</span>&nbsp;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">parent:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>)</code></dt>

<dd>
<p data-en="Call the given callback for every descendant node. The callback
may return false to prevent traversal of a given node's children." lang="cn">对所有的后代元素递归调用给定的回调。如果某个节点回调返回 <code>false</code> 表示阻止再对该节点的子节点调用回调。</p>
</dd><dt id="model.Fragment.textBetween"><code><strong><a href="#model.Fragment.textBetween">textBetween</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">blockSeparator:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">leafText:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd><p>Extract the text between <code>from</code> and <code>to</code>. See the same method on
<a href="#model.Node.textBetween"><code>Node</code></a>.</p>
</dd><dt id="model.Fragment.append"><code><strong><a href="#model.Fragment.append">append</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>) →&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="Create a new fragment containing the combined content of this
fragment and the other." lang="cn">创建一个包含当前 fragment 内容和给定 fragment 内容的新的 fragment。</p>
</dd><dt id="model.Fragment.cut"><code><strong><a href="#model.Fragment.cut">cut</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="Cut out the sub-fragment between the two given positions." lang="cn">从 fragment 剪切出给定范围的一个子 fragment。</p>
</dd><dt id="model.Fragment.replaceChild"><code><strong><a href="#model.Fragment.replaceChild">replaceChild</a></strong>(<span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="Create a new fragment in which the node at the given index is
replaced by the given node." lang="cn">将 fragment 中的给定 index 位置的节点用给定节点替换掉后，创建一个新的 fragment。</p>
</dd><dt id="model.Fragment.eq"><code><strong><a href="#model.Fragment.eq">eq</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Compare this fragment to another one." lang="cn">将当前 fragment 与另一个 fragment 比较，看是否相等。。</p>
<p type="comment"><span>注: </span>先比较 fragment 的内容大小，再逐个对内容节点调用节点的 eq 方法进行比较，一旦发现不一样的则返回 false，否则返回 true。</p>
</dd><dt id="model.Fragment.firstChild"><code><strong><a href="#model.Fragment.firstChild">firstChild</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The first child of the fragment, or null if it is empty." lang="cn">返回当前 fragment 的第一个子节点，如果是空则为 <code>null</code>。</p>
</dd><dt id="model.Fragment.lastChild"><code><strong><a href="#model.Fragment.lastChild">lastChild</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The last child of the fragment, or null if it is empty." lang="cn">返回当前 fragment 的最后一个节点，如果是空则为 <code>null</code>。</p>
</dd><dt id="model.Fragment.childCount"><code><strong><a href="#model.Fragment.childCount">childCount</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The number of child nodes in this fragment." lang="cn">当前 fragment 的子节点数量。</p>
</dd><dt id="model.Fragment.child"><code><strong><a href="#model.Fragment.child">child</a></strong>(<span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Get the child node at the given index. Raise an error when the
index is out of range." lang="cn">获取 fragment 在给定 index 的子节点。如果 index 超出范围则抛出一个错误。</p>
</dd><dt id="model.Fragment.maybeChild"><code><strong><a href="#model.Fragment.maybeChild">maybeChild</a></strong>(<span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Get the child node at the given index, if it exists." lang="cn">获取给定 index 的子节点，如果存在的话。</p>
</dd><dt id="model.Fragment.forEach"><code><strong><a href="#model.Fragment.forEach">forEach</a></strong>(<span class="param">f:</span>&nbsp;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">offset:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>))</code></dt>

<dd>
<p data-en="Call f for every child node, passing the node, its offset
into this parent node, and its index." lang="cn">为每一个子节点调用 <code>f</code> 函数，参数是子节点、子节点相对于当前节点的偏移、以及子节点的 index。</p>
</dd><dt id="model.Fragment.findDiffStart"><code><strong><a href="#model.Fragment.findDiffStart">findDiffStart</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Find the first position at which this fragment and another
fragment differ, or null if they are the same." lang="cn">寻找当前 fragment 和给定 fragment 的第一个不同的位置，如果它们相同的话返回 <code>null</code>。</p>
</dd><dt id="model.Fragment.findDiffEnd"><code><strong><a href="#model.Fragment.findDiffEnd">findDiffEnd</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>) →&nbsp;?⁠{<span class="prop">a:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">b:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}</code></dt>

<dd>
<p data-en="Find the first position, searching from the end, at which this
fragment and the given fragment differ, or null if they are the
same. Since this position will not be the same in both nodes, an
object with two separate positions is returned." lang="cn">从后往前搜索，寻找当前 fragment 和给定 fragment 的第一个不同的位置，如果相同则返回 <code>null</code>。
因为该位置在两个节点中可能是不同的，因此该函数返回的是一个对象，带有两个不同的位置。</p>
<p type="comment"><span>注: </span>对象是 {a: number, b: number}。</p>
</dd><dt id="model.Fragment.toString"><code><strong><a href="#model.Fragment.toString">toString</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Return a debugging string that describes this fragment." lang="cn">返回一个用来 debug 的 string 以描述该 fragment。</p>
</dd><dt id="model.Fragment.toJSON"><code><strong><a href="#model.Fragment.toJSON">toJSON</a></strong>() →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Create a JSON-serializeable representation of this fragment." lang="cn">返回该 fragment 序列化后的 JSON 表示。</p>
</dd><dt id="model.Fragment^fromJSON"><code>static <strong><a href="#model.Fragment^fromJSON">fromJSON</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>, <span class="param">value:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd><p>Deserialize a fragment from its JSON representation.</p>
<p>从该 fragment 的 JSON 表示中反序列化（parse）一个 fragment。</p>
</dd><dt id="model.Fragment^fromArray"><code>static <strong><a href="#model.Fragment^fromArray">fromArray</a></strong>(<span class="param">array:</span>&nbsp;[<a href="#model.Node"><span class="type">Node</span></a>]) →&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="Build a fragment from an array of nodes. Ensures that adjacent
text nodes with the same marks are joined together." lang="cn">用一个节点数组构建一个 fragment。带有相同 marks 的相邻文本节点会被合并到一起。</p>
</dd><dt id="model.Fragment^from"><code>static <strong><a href="#model.Fragment^from">from</a></strong>(<span class="param">nodes:</span>&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a> | <a href="#model.Node"><span class="type">Node</span></a> | [<a href="#model.Node"><span class="type">Node</span></a>]) →&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="Create a fragment from something that can be interpreted as a set
of nodes. For null, it returns the empty fragment. For a
fragment, the fragment itself. For a node or array of nodes, a
fragment containing those nodes." lang="cn">用给定的类节点集合的对象中创建一个 fragment。如果是 <code>null</code> 则返回空 fragment。
如果是 fragment 则返回该 fragment 自身。如果是一个节点或者一个节点数组，则返回一个包含这些节点的 fragment。</p>
</dd><dt id="model.Fragment^empty"><code>static <strong><a href="#model.Fragment^empty">empty</a></strong>: <a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node)." lang="cn">一个空的 fragment。没有包含任何节点的 fragment 都指向该对象（而不是为每个 fragment 都创建一个空的 fragment）。</p>
</dd></dl>
<h4 id="model.Mark">
  <a href="#model.Mark">Mark</a> <span class="kind">class</span></h4>
<p data-en="A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a type
and optionally a set of attributes that provide further information
(such as the target of the link). Marks are created through a
Schema, which controls which types exist and which
attributes they have." lang="cn">Mark 是可以被附加到节点上的一小段信息，比如加粗行内代码或者加粗链接字体。它有一个可选的 attributes 集合以提供更多信息
（比如链接的 target 信息等）。Marks 通过 <code>Schema</code> 创建，它控制哪些 marks 存在于哪些节点以及拥有哪些 attributes。</p>
<dl><dt id="model.Mark.type"><code><strong><a href="#model.Mark.type">type</a></strong>: <a href="#model.MarkType"><span class="type">MarkType</span></a></code></dt>

<dd>
<p data-en="The type of this mark." lang="cn">当前 mark 的 type。</p>
</dd><dt id="model.Mark.attrs"><code><strong><a href="#model.Mark.attrs">attrs</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="The attributes associated with this mark." lang="cn">与此 mark 相关的 attributes。</p>
</dd><dt id="model.Mark.addToSet"><code><strong><a href="#model.Mark.addToSet">addToSet</a></strong>(<span class="param">set:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="Given a set of marks, create a new set which contains this one as
well, in the right position. If this mark is already in the set,
the set itself is returned. If any marks that are set to be
exclusive with this mark are present,
those are replaced by this one." lang="cn">将当前 marks 加入到给定 marks 集合的右侧（后面）后返回新的 marks 集合。如果当前 marks 已经存在于给定集合当中
那么给定集合自身会被返回。如果给定集合中有任何 marsk 配置对象的 <a href="#model.MarkSpec.excludes">exclusive</a> 属性值中有当前 mark，那么它会被用当前 mark 替换掉。</p>
</dd><dt id="model.Mark.removeFromSet"><code><strong><a href="#model.Mark.removeFromSet">removeFromSet</a></strong>(<span class="param">set:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="Remove this mark from the given set, returning a new set. If this
mark is not in the set, the set itself is returned." lang="cn">从给定的 marks 集合中移除当前 mark。如果当前 mark 不在集合中，那么给定集合本身会被返回。</p>
</dd><dt id="model.Mark.isInSet"><code><strong><a href="#model.Mark.isInSet">isInSet</a></strong>(<span class="param">set:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether this mark is in the given set of marks." lang="cn">测试是否当前 mark 在给定 marks 集合中。</p>
</dd><dt id="model.Mark.eq"><code><strong><a href="#model.Mark.eq">eq</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether this mark has the same type and attributes as
another mark." lang="cn">测试当前 mark 与给定 mark 是否有相同的类型和 attributes。</p>
</dd><dt id="model.Mark.toJSON"><code><strong><a href="#model.Mark.toJSON">toJSON</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Convert this mark to a JSON-serializeable representation." lang="cn">返回当前 mark 的 JSON 序列化的表示。</p>
</dd><dt id="model.Mark^fromJSON"><code>static <strong><a href="#model.Mark^fromJSON">fromJSON</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>, <span class="param">json:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a></code></dt>

<dd></dd><dt id="model.Mark^sameSet"><code>static <strong><a href="#model.Mark^sameSet">sameSet</a></strong>(<span class="param">a:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>], <span class="param">b:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether two sets of marks are identical." lang="cn">测试两个 marks 集合是否一样。</p>
<p type="comment"><span>注: </span>marks 集合是否相同的比较是是先测试 marks 集合中的 mark 数量，然后逐个调用 mark 的 eq 进行比较。</p>
</dd><dt id="model.Mark^setFrom"><code>static <strong><a href="#model.Mark^setFrom">setFrom</a></strong>(<span class="param">marks:</span>&nbsp;?⁠<a href="#model.Mark"><span class="type">Mark</span></a> | [<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="Create a properly sorted mark set from null, a single mark, or an
unsorted array of marks." lang="cn">用给定的参数，新建一个 stored marks 集合，该参数可能是 null、单独一个 mark或者一个未排序的 marks 数组。</p>
</dd><dt id="model.Mark^none"><code>static <strong><a href="#model.Mark^none">none</a></strong>: [<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="The empty set of marks." lang="cn">marks 的空集合。</p>
</dd></dl>
<h4 id="model.Slice">
  <a href="#model.Slice">Slice</a> <span class="kind">class</span></h4>
<p data-en="A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are ‘open’ (cut through)." lang="cn">一个 slice 表示从大的文档中切出去的一小段片段。它不仅存储着 fragment，还有它两侧的节点「开放」的深度（切割节点产生的）。</p>
<dl><dt id="model.Slice.constructor"><code>new <strong><a href="#model.Slice.constructor">Slice</a></strong>(<span class="param">content:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>, <span class="param">openStart:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">openEnd:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>)</code></dt>

<dd>
<p data-en="Create a slice. When specifying a non-zero open depth, you must
make sure that there are nodes of at least that depth at the
appropriate side of the fragment—i.e. if the fragment is an empty
paragraph node, openStart and openEnd can't be greater than 1." lang="cn">新建一个 slice。当指定一个非零的开放深度的时候，你必须保证该 slice 的 fragment 至少在这个深度存在节点。
例如，如果节点是一个空的段落节点，那么 <code>openStart</code> 和 <code>openEnd</code> 不能大于 1。</p>

<p data-en="It is not necessary for the content of open nodes to conform to
the schema's content constraints, though it should be a valid
start/end/middle for such a node, depending on which sides are
open." lang="cn">开放节点的内容无需一定要符合 schema 的内容限制，因为对于开放节点来说，它的内容应该被在一个有效的开始/结束/中间位置开放，而这具体取决于节点的哪一侧被打开。</p>
<p type="comment"><span>注: </span>这句话举个例子比较好理解，如果 schema 内容限制 li 不能包含 p，但如果一个 slice 的 fragment 结构是 <code>&lt;li&gt;&lt;p&gt;123&lt;/p&gt;&lt;p&gt;456&lt;/p&gt;&lt;/li&gt;</code>，openStart 是 2，openEnd 也是 2
那么该 slice 切割（打开/开放）出来的节点就会形如 <code>123&lt;/p&gt;&lt;p&gt;456</code>, 因此也是一个有效的 slice，可以被放到文档中需要的地方去（如另个一 p 标签内）。</p>
</dd><dt id="model.Slice.content"><code><strong><a href="#model.Slice.content">content</a></strong>: <a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="The slice's content." lang="cn">该 slice 的内容片段。</p>
<p type="comment"><span>注: </span>该内容片段以 Fragment 的实例形式存在。</p>
</dd><dt id="model.Slice.openStart"><code><strong><a href="#model.Slice.openStart">openStart</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The open depth at the start." lang="cn">开始位置的开放深度。</p>
</dd><dt id="model.Slice.openEnd"><code><strong><a href="#model.Slice.openEnd">openEnd</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The open depth at the end." lang="cn">结束位置的开放深度。</p>
</dd><dt id="model.Slice.size"><code><strong><a href="#model.Slice.size">size</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The size this slice would add when inserted into a document." lang="cn">当将插入 slice 到文档中时，插入的内容大小。</p>
</dd><dt id="model.Slice.eq"><code><strong><a href="#model.Slice.eq">eq</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Tests whether this slice is equal to another slice." lang="cn">测试当前 slice 是否与另一个 slice 相等。</p>
<p type="comment"><span>注: </span>相等比较是比较 slice 的内容，也即调用 fragment 的 eq 方法比较的，而且需要满足 openStart 相等和 openEnd 相等。</p>
</dd><dt id="model.Slice.toJSON"><code><strong><a href="#model.Slice.toJSON">toJSON</a></strong>() →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Convert a slice to a JSON-serializable representation." lang="cn">返回当前 slice 的 JSON 序列化的表示。</p>
</dd><dt id="model.Slice^fromJSON"><code>static <strong><a href="#model.Slice^fromJSON">fromJSON</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>, <span class="param">json:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="Deserialize a slice from its JSON representation." lang="cn">从 slice 的 JSON 表示形式反序列化出一个 slice。</p>
</dd><dt id="model.Slice^maxOpen"><code>static <strong><a href="#model.Slice^maxOpen">maxOpen</a></strong>(<span class="param">fragment:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>, <span class="param">openIsolating:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a><span class="defaultvalue"> = true</span>) →&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="Create a slice from a fragment by taking the maximum possible
open value on both side of the fragment." lang="cn">从一个 fragment 新建一个 slice，该 slice 两侧的的打开值尽可能的大。</p>
</dd><dt id="model.Slice^empty"><code>static <strong><a href="#model.Slice^empty">empty</a></strong>: <a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="The empty slice." lang="cn">空的 Slice。</p>
</dd></dl>
<h4 id="model.ReplaceError">
  <a href="#model.ReplaceError">ReplaceError</a> <span class="kind">class</span> <span class="extends">extends <code><a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error"><span class="type">Error</span></a></code></span></h4>
<p data-en="Error type raised by Node.replace when
given an invalid replacement." lang="cn">一种调用 <a href="#model.Node.replace"><code>Node.replace</code></a> 方法时如果给定替换内容不可用的话会返回的错误类型。</p>
<dl></dl>
<h3 id="model.Resolved_Positions"><a href="#model.Resolved_Positions">Resolved Positions</a></h3>

<p data-en="Positions in a document can be represented as integer
offsets. But you'll often want to use a
more convenient representation." lang="cn">在文档中的位置可以表示为一个整数的 <a href="https://xheldon.com/prosemirror-guide-chinese.html#indexing">offsets</a>。不过你经常会想要使用一种更方便表达形式来使用位置信息。</p>
<h4 id="model.ResolvedPos">
  <a href="#model.ResolvedPos">ResolvedPos</a> <span class="kind">class</span></h4>
<p data-en="You can resolve a position to get more
information about it. Objects of this class represent such a
resolved position, providing various pieces of context information,
and some helper methods." lang="cn">你可以 <a href="#model.Node.resolve"><em>resolve</em></a> 一个位置以得到该位置的更多信息。该类的对象就是表示这样一种 resolve 过的位置，
它提供一些上下文信息，以及一些有用的工具函数。</p>

<p data-en="Throughout this interface, methods that take an optional depth
parameter will interpret undefined as this.depth and negative
numbers as this.depth + value." lang="cn">通过这个接口，对于那些接受可选参数 <code>depth</code> 的方法来说，如果没有传入该参数则默认会是 <code>this.depth</code>，如果是负数则会是 <code>this.depth + value</code>。</p>
<dl><dt id="model.ResolvedPos.pos"><code><strong><a href="#model.ResolvedPos.pos">pos</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The position that was resolved." lang="cn">被 resolve 的位置。</p>
</dd><dt id="model.ResolvedPos.depth"><code><strong><a href="#model.ResolvedPos.depth">depth</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The number of levels the parent node is from the root. If this
position points directly into the root node, it is 0. If it
points into a top-level paragraph, 1, and so on." lang="cn">从根节点开始算，它的父节点的深度。如果位置直接指向根节点，则是 0。如果它指向一个顶级节点如段落，则是 1，以此类推。</p>
</dd><dt id="model.ResolvedPos.parentOffset"><code><strong><a href="#model.ResolvedPos.parentOffset">parentOffset</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The offset this position has into its parent node." lang="cn">该位置相对于父节点的偏移量。</p>
</dd><dt id="model.ResolvedPos.parent"><code><strong><a href="#model.ResolvedPos.parent">parent</a></strong>: <a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The parent node that the position points into. Note that even if
a position points into a text node, that node is not considered
the parent—text nodes are ‘flat’ in this model, and have no content." lang="cn">该位置指向的父级节点。记住，即使一个位置指向的是文本节点，那该节点也不认为是父级，因为文本节点在 ProseMirror 世界里是 「扁平」的，它没有内容。</p>
</dd><dt id="model.ResolvedPos.doc"><code><strong><a href="#model.ResolvedPos.doc">doc</a></strong>: <a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The root node in which the position was resolved." lang="cn">该位置被 resolve 的根节点。</p>
</dd><dt id="model.ResolvedPos.node"><code><strong><a href="#model.ResolvedPos.node">node</a></strong>(<span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The ancestor node at the given level. p.node(p.depth) is the
same as p.parent." lang="cn">在给定深度的祖先节点。p.node(p.depth)<code>与</code>p.parent` 相同。</p>
</dd><dt id="model.ResolvedPos.index"><code><strong><a href="#model.ResolvedPos.index">index</a></strong>(<span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The index into the ancestor at the given level. If this points at
the 3rd node in the 2nd paragraph on the top level, for example,
p.index(0) is 1 and p.index(1) is 2." lang="cn">在给定深度的祖先节点的 index。例如，如果该位置指向顶级节点的第二个段落的第三个节点，那么 <code>p.index(0)</code> 是 1，<code>p.index(1)</code> 是 2。</p>
</dd><dt id="model.ResolvedPos.indexAfter"><code><strong><a href="#model.ResolvedPos.indexAfter">indexAfter</a></strong>(<span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The index pointing after this position into the ancestor at the
given level." lang="cn">在给定深度的祖先节点后面节点的 index。</p>
</dd><dt id="model.ResolvedPos.start"><code><strong><a href="#model.ResolvedPos.start">start</a></strong>(<span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The (absolute) position at the start of the node at the given
level." lang="cn">给定深度的祖先节点的开始位置（绝对位置）。</p>
<p type="comment"><span>注: </span>绝对位置是相对于 doc 根节点的位置，一般都是用它来定位。</p>
</dd><dt id="model.ResolvedPos.end"><code><strong><a href="#model.ResolvedPos.end">end</a></strong>(<span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The (absolute) position at the end of the node at the given
level." lang="cn">给定深度的祖先节点的结束位置（绝对位置）。</p>
</dd><dt id="model.ResolvedPos.before"><code><strong><a href="#model.ResolvedPos.before">before</a></strong>(<span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The (absolute) position directly before the wrapping node at the
given level, or, when depth is this.depth + 1, the original
position." lang="cn">在给定深度的祖先节点之前的（绝对）位置，或者，如果 <code>depth</code> 是 <code>this.depth + 1</code> 的话，则是原始的位置。</p>
</dd><dt id="model.ResolvedPos.after"><code><strong><a href="#model.ResolvedPos.after">after</a></strong>(<span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The (absolute) position directly after the wrapping node at the
given level, or the original position when depth is this.depth + 1." lang="cn">在给定深度的祖先节点之后的（绝对）位置，或者如果 <code>depth</code> 是 <code>this.depth + 1</code> 的话则是原始的位置。</p>
<p type="comment"><span>注: </span>「before 之前」、「start 开始」、「after 之后」、「end 结束」位置的区别：有以下结构 <code>&lt;p&gt;123&lt;/p&gt;</code>，则（I表示「这个」位置） <code>I&lt;p&gt;123&lt;/p&gt;</code> 表示 <code>before</code>；
<code>&lt;p&gt;I123&lt;/p&gt;</code> 表示 <code>start</code>；<code>&lt;p&gt;123I&lt;/p&gt;</code> 表示 <code>end</code>；<code>&lt;p&gt;123&lt;/p&gt;I</code> 表示 <code>after</code>。</p>
</dd><dt id="model.ResolvedPos.textOffset"><code><strong><a href="#model.ResolvedPos.textOffset">textOffset</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="When this position points into a text node, this returns the
distance between the position and the start of the text node.
Will be zero for positions that point between nodes." lang="cn">当位置指向一个文本节点，该函数返回当前位置到文本节点开始位置的距离。如果指向节点之间则是 0。</p>
</dd><dt id="model.ResolvedPos.nodeAfter"><code><strong><a href="#model.ResolvedPos.nodeAfter">nodeAfter</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Get the node directly after the position, if any. If the position
points into a text node, only the part of that node after the
position is returned." lang="cn">获取紧挨着该位置后的节点，如果有的话。如果位置指向一个文本节点，则只有在文本节点中该位置之后的内容会被返回。</p>
</dd><dt id="model.ResolvedPos.nodeBefore"><code><strong><a href="#model.ResolvedPos.nodeBefore">nodeBefore</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Get the node directly before the position, if any. If the
position points into a text node, only the part of that node
before the position is returned." lang="cn">获取紧挨着该位置前的节点，如果有的话。如果位置指向一个文本节点，则只有在文本节点中该位置之前的内容会被返回。</p>
</dd><dt id="model.ResolvedPos.posAtIndex"><code><strong><a href="#model.ResolvedPos.posAtIndex">posAtIndex</a></strong>(<span class="param">index:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Get the position at the given index in the parent node at the
given depth (which defaults to this.depth)." lang="cn">获取在给定深度的祖先节点的给定 index 的位置（深度默认是 <code>this.depth</code>)。</p>
</dd><dt id="model.ResolvedPos.marks"><code><strong><a href="#model.ResolvedPos.marks">marks</a></strong>() →&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="Get the marks at this position, factoring in the surrounding
marks' inclusive property. If the
position is at the start of a non-empty node, the marks of the
node after it (if any) are returned." lang="cn">充分考虑 marks 们的 <a href="#model.MarkSpec.inclusive"><code>inclusive</code></a> 属性后，获取当前位置的最终的 marks。如果该位置是在一个非空节点的起始位置，则会返回该位置之后节点的 marks（如果有的话）。</p>
<p type="comment"><span>注: </span>如果位置在一个空元素内，则返回空的数组（即 Mark 的静态属性，Mark.none)。如果是在一个文本节点中，则简单返回文本节点的 marks。
如果在一个非空节点的起始位置（before 为空），则考虑该位置之后节点的 marks。最后（此时只剩一种情况，也即在一个非文本节点的末尾位置）考虑排除那些设置了 <code>inclusive</code> 属性为 false 的 marks 们。</p>
</dd><dt id="model.ResolvedPos.marksAcross"><code><strong><a href="#model.ResolvedPos.marksAcross">marksAcross</a></strong>(<span class="param">$end:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>) →&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="Get the marks after the current position, if any, except those
that are non-inclusive and not present at position $end. This
is mostly useful for getting the set of marks to preserve after a
deletion. Will return null if this position is at the end of
its parent node or its parent node isn't a textblock (in which
case no marks should be preserved)." lang="cn">获取在当前位置之后的 marks，如果有的话，会排除那些 inclusive 为 false 以及没有出现在 <code>$end</code> 位置的 marks 们。
这个方法最有用的场景是在执行删除操作后获取需要保留的 marks 集合。如果该位置在它的父级节点的结束的地方或者它的父级节点不是一个文本 block，则会返回 null（此时不应该有任何 marks 被保留）。</p>
</dd><dt id="model.ResolvedPos.sharedDepth"><code><strong><a href="#model.ResolvedPos.sharedDepth">sharedDepth</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The depth up to which this position and the given (non-resolved)
position share the same parent nodes." lang="cn">返回在给定位置和当前位置拥有的相同父级节点所在的最大深度。</p>
</dd><dt id="model.ResolvedPos.blockRange"><code><strong><a href="#model.ResolvedPos.blockRange">blockRange</a></strong>(<span class="param">other:</span>&nbsp;?⁠<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a><span class="defaultvalue"> = this</span>, <span class="param">pred:</span>&nbsp;?⁠<span class="fn">fn</span>(<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;?⁠<a href="#model.NodeRange"><span class="type">NodeRange</span></a></code></dt>

<dd>
<p data-en="Returns a range based on the place where this position and the
given position diverge around block content. If both point into
the same textblock, for example, a range around that textblock
will be returned. If they point into different blocks, the range
around those blocks in their shared ancestor is returned. You can
pass in an optional predicate that will be called with a parent
node to see if a range into that parent is acceptable." lang="cn">根据当前位置与给定位置围绕块级节点的周围看返回相应的 Range。例如，如果两个位置都指向一个文本 block，则文本 block 的 range 会被返回；
如果它们指向不同的块级节点，则包含这些块级节点的深度最大的共同祖先节点 range 将会被返回。你可以传递一个指示函数，来决定该祖先节点是否可接受。</p>
</dd><dt id="model.ResolvedPos.sameParent"><code><strong><a href="#model.ResolvedPos.sameParent">sameParent</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Query whether the given position shares the same parent node." lang="cn">当前位置和给定位置是否具有相同的父级节点。</p>
</dd><dt id="model.ResolvedPos.max"><code><strong><a href="#model.ResolvedPos.max">max</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>) →&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="Return the greater of this and the given position." lang="cn">返回当前位置和给定位置较大的那个。</p>
</dd><dt id="model.ResolvedPos.min"><code><strong><a href="#model.ResolvedPos.min">min</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>) →&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="Return the smaller of this and the given position." lang="cn">返回当前位置和给定位置较小的那个。</p>
</dd></dl>
<h4 id="model.NodeRange">
  <a href="#model.NodeRange">NodeRange</a> <span class="kind">class</span></h4>
<p data-en="Represents a flat range of content, i.e. one that starts and
ends in the same node." lang="cn">表示一个内容的扁平范围（range），例如，一个开始和结束在相同节点的范围。</p>
<dl><dt id="model.NodeRange.constructor"><code>new <strong><a href="#model.NodeRange.constructor">NodeRange</a></strong>(<span class="param">$from:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">$to:</span>&nbsp;<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a>, <span class="param">depth:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>)</code></dt>

<dd>
<p data-en="Construct a node range. $from and $to should point into the
same node until at least the given depth, since a node range
denotes an adjacent set of nodes in a single parent node." lang="cn">构造一个节点 range。至少深度在 <code>depth</code> 及更小的时候 <code>$from</code> 和 <code>$to</code> 应该始终指向相同的节点，因为一个节点 range 表示具有相同父级节点的相邻节点的集合。</p>
</dd><dt id="model.NodeRange.$from"><code><strong><a href="#model.NodeRange.$from">$from</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="A resolved position along the start of the
content. May have a depth greater than this object's depth
property, since these are the positions that were used to
compute the range, not re-resolved positions directly at its
boundaries." lang="cn">range 的内容开始处 resolve 过的位置。它可能有一个大于该 range 的 <code>depth</code> 属性的深度，因为这些位置是用来计算 range 的，其不会直接在 range 的边界再次 resolve。</p>
</dd><dt id="model.NodeRange.$to"><code><strong><a href="#model.NodeRange.$to">$to</a></strong>: <a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="A position along the end of the content. See
caveat for $from." lang="cn">range 的内容结束处 resolve 过的位置。看一下关于 <a href="#model.NodeRange.$from"><code>$from</code></a> 的警告。</p>
<p type="comment"><span>注: </span>举个例子：有以下结构 <code>&lt;ul&gt;&lt;li&gt;&lt;p&gt;abc&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;123&lt;/p&gt;&lt;p&gt;456&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</code> 则构造一个 NodeRange 的时候，如果 $from 在 1 后面位置，
$to 在 4 后面位置，则 depth 必须是在第二个 li 的开始位置的深度或者更小，因为如果再深的话，$from 和 $to 就没有共同的父级节点，就无法构建一个 NodeRange。
也因此，$from 和 $to 的 depth 属性是有可能大于 NodeRange 的 depth 属性的。</p>
</dd><dt id="model.NodeRange.depth"><code><strong><a href="#model.NodeRange.depth">depth</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The depth of the node that this range points into." lang="cn">该 range 指向的节点的深度。</p>
</dd><dt id="model.NodeRange.start"><code><strong><a href="#model.NodeRange.start">start</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The position at the start of the range." lang="cn">该 range 开始的位置。</p>
</dd><dt id="model.NodeRange.end"><code><strong><a href="#model.NodeRange.end">end</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The position at the end of the range." lang="cn">该 range 结束的位置。</p>
</dd><dt id="model.NodeRange.parent"><code><strong><a href="#model.NodeRange.parent">parent</a></strong>: <a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The parent node that the range points into." lang="cn">该 range 所在的父级节点。</p>
</dd><dt id="model.NodeRange.startIndex"><code><strong><a href="#model.NodeRange.startIndex">startIndex</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The start index of the range in the parent node." lang="cn">该 range 在父级节点中的开始处的 index。</p>
</dd><dt id="model.NodeRange.endIndex"><code><strong><a href="#model.NodeRange.endIndex">endIndex</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The end index of the range in the parent node." lang="cn">该 range 在父级节点中结束处的 index。</p>
</dd></dl>
<h3 id="model.Document_Schema"><a href="#model.Document_Schema">Document Schema</a></h3>

<p data-en="Every ProseMirror document conforms to a
schema, which describes the set of nodes and
marks that it is made out of, along with the relations between those,
such as which node may occur as a child node of which other nodes." lang="cn">每个 ProseMirror 文档都符合一个 <a href="https://xheldon.com/prosemirror-guide-chinese.html#schemas">schema</a> 约束，它描述了节点的集合和 marks，以及它们之间的关系，比如哪些节点可以作为其他节点的子节点等。</p>
<h4 id="model.Schema">
  <a href="#model.Schema">Schema</a> <span class="kind">class</span></h4>
<p data-en="A document schema. Holds node and mark
type objects for the nodes and marks that may
occur in conforming documents, and provides functionality for
creating and deserializing such documents." lang="cn">一个文档的 schema。对可能出现在文档中的 nodes 和 marks 提供相应的 <a href="#model.NodeType">node type</a> 和 <a href="#model.MarkType">mark type</a> 对象，
以及提供相应创建和序列化这样一个文档的函数。</p>
<dl><dt id="model.Schema.constructor"><code>new <strong><a href="#model.Schema.constructor">Schema</a></strong>(<span class="param">spec:</span>&nbsp;<a href="#model.SchemaSpec"><span class="type">SchemaSpec</span></a>)</code></dt>

<dd>
<p data-en="Construct a schema from a schema specification." lang="cn">构造一个 schema 从一个 schema <a href="#model.SchemaSpec">specification（配置对象）</a>中。</p>
</dd><dt id="model.Schema.spec"><code><strong><a href="#model.Schema.spec">spec</a></strong>: <a href="#model.SchemaSpec"><span class="type">SchemaSpec</span></a></code></dt>

<dd>
<p data-en="The spec on which the schema is based,
with the added guarantee that its nodes and marks
properties are
OrderedMap instances
(not raw objects)." lang="cn">当前 schema 所基于的 <a href="#model.SchemaSpec">spec（配置对象）</a>，其中的 <code>nodes</code> 和 <code>marks</code> 属性可以保证是
<a href="https://github.com/marijnh/orderedmap"><code>OrderedMap</code></a> 的实例（不是原始对象）。</p>
</dd><dt id="model.Schema.nodes"><code><strong><a href="#model.Schema.nodes">nodes</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#model.NodeType"><span class="type">NodeType</span></a>&gt;</code></dt>

<dd>
<p data-en="An object mapping the schema's node names to node type objects." lang="cn">一个 schema 中节点名和节点类型对象的键值对映射。</p>
</dd><dt id="model.Schema.marks"><code><strong><a href="#model.Schema.marks">marks</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#model.MarkType"><span class="type">MarkType</span></a>&gt;</code></dt>

<dd>
<p data-en="A map from mark names to mark type objects." lang="cn">一个 mark 名和 mark 类型对象的键值对映射。</p>
</dd><dt id="model.Schema.topNodeType"><code><strong><a href="#model.Schema.topNodeType">topNodeType</a></strong>: <a href="#model.NodeType"><span class="type">NodeType</span></a></code></dt>

<dd>
<p data-en="The type of the default top node
for this schema." lang="cn">当前 schema 的 <a href="#model.SchemaSpec.topNode">默认顶级节点</a> 类型。</p>
</dd><dt id="model.Schema.cached"><code><strong><a href="#model.Schema.cached">cached</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="An object for storing whatever values modules may want to
compute and cache per schema. (If you want to store something
in it, try to use property names unlikely to clash.)" lang="cn">一个用于计算和缓存每个 schema 中的任何类型值的对象。（如果你想要在其上储存一些东西，要保证属性名不会冲突）</p>
</dd><dt id="model.Schema.node"><code><strong><a href="#model.Schema.node">node</a></strong>(<span class="param">type:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a> | <a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">content:</span>&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a> | <a href="#model.Node"><span class="type">Node</span></a> | [<a href="#model.Node"><span class="type">Node</span></a>], <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Create a node in this schema. The type may be a string or a
NodeType instance. Attributes will be extended
with defaults, content may be a Fragment,
null, a Node, or an array of nodes." lang="cn">在 schema 中新建一个节点。<code>type</code> 参数可以是一个字符串或者一个 <code>NodeType</code> 的实例。Attributes 会被以默认值扩展，<code>content</code> 可能是一个 <code>Fragment</code>、
<code>null</code>、<code>Node</code> 或者一个节点数组。</p>
</dd><dt id="model.Schema.text"><code><strong><a href="#model.Schema.text">text</a></strong>(<span class="param">text:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Create a text node in the schema. Empty text nodes are not
allowed." lang="cn">在 schema 中新建一个文本节点。不允许创建空的文本节点。</p>
<p type="comment"><span>注: </span>文本节点和文本块节点不同，注意区分。</p>
</dd><dt id="model.Schema.mark"><code><strong><a href="#model.Schema.mark">mark</a></strong>(<span class="param">type:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a> | <a href="#model.MarkType"><span class="type">MarkType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a></code></dt>

<dd>
<p data-en="Create a mark with the given type and attributes." lang="cn">用给定的类型和 attributes 创建一个 mark。</p>
</dd><dt id="model.Schema.nodeFromJSON"><code><strong><a href="#model.Schema.nodeFromJSON">nodeFromJSON</a></strong>(<span class="param">json:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Deserialize a node from its JSON representation. This method is
bound." lang="cn">从一个 JSON 表达式中反序列化出一个节点。该方法 this 已经绑定当前对象。</p>
<p type="comment"><span>注: </span>JSON 表达式其实并不是 JavaScript 中通常意义上的 JSON 字符串，而是一个普通对象，它及它的键值都是 plain object。该对象由相应的 Node.toJSON 生成。</p>
</dd><dt id="model.Schema.markFromJSON"><code><strong><a href="#model.Schema.markFromJSON">markFromJSON</a></strong>(<span class="param">json:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a></code></dt>

<dd>
<p data-en="Deserialize a mark from its JSON representation. This method is
bound." lang="cn">从一个 JSON 表达式中反序列化出一个 mark。该方法 this 已经绑定当前对象。</p>
<p type="comment"><span>注: </span>该对象由相应的 Mark.toJSON 生成。</p>
</dd></dl>
<h4 id="model.SchemaSpec">
  <a href="#model.SchemaSpec">SchemaSpec</a> <span class="kind">interface</span></h4>
<p data-en="An object describing a schema, as passed to the Schema
constructor." lang="cn">一个描述 schema 的对象，用来传递给 <a href="#model.Schema"><code>Schema</code></a> 构造函数</p>
<p type="comment"><span>注: </span>就是 schema 的配置对象，ProseMirror 中的 xxxSpec 都是 xxx 的配置对象，如 NodeSpec、MarkSpec 等。</p>
<dl><dt id="model.SchemaSpec.nodes"><code><strong><a href="#model.SchemaSpec.nodes">nodes</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#model.NodeSpec"><span class="type">NodeSpec</span></a>&gt; | <a href="https://github.com/marijnh/orderedmap#readme"><span class="type">OrderedMap</span></a>&lt;<a href="#model.NodeSpec"><span class="type">NodeSpec</span></a>&gt;</code></dt>

<dd>
<p data-en="The node types in this schema. Maps names to
NodeSpec objects that describe the node type
associated with that name. Their order is significant—it
determines which parse rules take
precedence by default, and which nodes come first in a given
group." lang="cn">当前 schema 中所有的 node 类型的对象。对象中，键是节点名，对象的键是对应的 <a href="#model.NodeSpec"><code>NodeSpec</code></a>。
节点们在该对象中出现的先后顺序是非常重要的，它决定了默认情况下哪个节点的 <a href="#model.NodeSpec.parseDOM">parse rules</a> 优先进行，
以及哪个节点是一个 group 优先考虑的节点。</p>
</dd><dt id="model.SchemaSpec.marks"><code><strong><a href="#model.SchemaSpec.marks">marks</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#model.MarkSpec"><span class="type">MarkSpec</span></a>&gt; | <a href="https://github.com/marijnh/orderedmap#readme"><span class="type">OrderedMap</span></a>&lt;<a href="#model.MarkSpec"><span class="type">MarkSpec</span></a>&gt;</code></dt>

<dd>
<p data-en="The mark types that exist in this schema. The order in which they
are provided determines the order in which mark
sets are sorted and in which parse
rules are tried." lang="cn">当前 schema 中的所有 mark 类型的对象。它们出现的顺序决定了在 <a href="#model.Mark.addToSet">mark
sets</a> 中的存储顺序，以及 <a href="#model.MarkSpec.parseDOM">parse rules</a> 的处理顺序。</p>
</dd><dt id="model.SchemaSpec.topNode"><code><strong><a href="#model.SchemaSpec.topNode">topNode</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The name of the default top-level node for the schema. Defaults
to &quot;doc&quot;." lang="cn">当前 schema 顶级节点的名字，默认是 <code>"doc"</code>。</p>
</dd></dl>
<h4 id="model.NodeSpec">
  <a href="#model.NodeSpec">NodeSpec</a> <span class="kind">interface</span></h4><dl><dt id="model.NodeSpec.content"><code><strong><a href="#model.NodeSpec.content">content</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The content expression for this node, as described in the schema
guide. When not given,
the node does not allow any content." lang="cn">就像在 <a href="https://xheldon.com/prosemirror-guide-chinese.html#content-expressions">schema guide</a> 中描述的一样，为当前节点的内容表达式。
如果没有给定，则该节点不允许任何内容。</p>
<p type="comment"><span>注: </span>schema guide 链接指向中文翻译指南，请搜索 Schema 下的 Content Expressions 一节。</p>
</dd><dt id="model.NodeSpec.marks"><code><strong><a href="#model.NodeSpec.marks">marks</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The marks that are allowed inside of this node. May be a
space-separated string referring to mark names or groups, &quot;_&quot;
to explicitly allow all marks, or &quot;&quot; to disallow marks. When
not given, nodes with inline content default to allowing all
marks, other nodes default to not allowing marks." lang="cn">当前节点允许的 marks 类型。可能是一个空格分隔的字符串，内容是 mark 的名字或者 group 名。
<code>"_"</code> 表示明确允许所有的 marks，或者 <code>""</code> 表示禁止所有的 marks。如果没有设置该字段，则节点含有的内联内容将会默认允许所有的 marks，
其他不含内联内容的节点将默认不允许所有的 marks。</p>
</dd><dt id="model.NodeSpec.group"><code><strong><a href="#model.NodeSpec.group">group</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The group or space-separated groups to which this node belongs,
which can be referred to in the content expressions for the
schema." lang="cn">当前节点所属的 group，可以出现多个，用空格分隔，可以指向当前 schema 的内容表达式（content expressions）。</p>
</dd><dt id="model.NodeSpec.inline"><code><strong><a href="#model.NodeSpec.inline">inline</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Should be set to true for inline nodes. (Implied for text nodes.)" lang="cn">对于内联节点，应该被设置为 true（文本节点隐式的被设置为 true）。</p>
</dd><dt id="model.NodeSpec.atom"><code><strong><a href="#model.NodeSpec.atom">atom</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Can be set to true to indicate that, though this isn't a leaf
node, it doesn't have directly editable
content and should be treated as a single unit in the view." lang="cn">可以被设置为 true，以表示即使当前节点不是一个 <a href="#model.NodeType.isLeaf">leaf node</a>，但是其也没有直接可编辑内容，
因此在 view 中应该被当成是一个独立的单位对待。</p>
<p type="comment"><span>注: </span>「独立单位对待」指的是，如在计数上，应该是 1；在事件上，内部元素触发的事件应该被视作是该节点触发的，等。</p>
</dd><dt id="model.NodeSpec.attrs"><code><strong><a href="#model.NodeSpec.attrs">attrs</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#model.AttributeSpec"><span class="type">AttributeSpec</span></a>&gt;</code></dt>

<dd>
<p data-en="The attributes that nodes of this type get." lang="cn">当前节点拿到的 attributes。</p>
</dd><dt id="model.NodeSpec.selectable"><code><strong><a href="#model.NodeSpec.selectable">selectable</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Controls whether nodes of this type can be selected as a node
selection. Defaults to true for non-text
nodes." lang="cn">控制当前类型的节点是否能够被作为 <a href="#state.NodeSelection">node selection</a> 所选中。
对于非文本节点来说，默认是 true。</p>
</dd><dt id="model.NodeSpec.draggable"><code><strong><a href="#model.NodeSpec.draggable">draggable</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Determines whether nodes of this type can be dragged without
being selected. Defaults to false." lang="cn">决定在未选中的情况下，当前类型的节点能否被拖拽。默认是 false。</p>
</dd><dt id="model.NodeSpec.code"><code><strong><a href="#model.NodeSpec.code">code</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Can be used to indicate that this node contains code, which
causes some commands to behave differently." lang="cn">指示当前节点包含 code，其会引起一些命令有特别的行为。</p>
<p type="comment"><span>注: </span>「特别的行为」如，在 code 节点中的内容如果是 li 和 文档中的 li 是两个处理逻辑，前者针对 code 块处理；后者针对 li 进行处理。</p>
</dd><dt id="model.NodeSpec.defining"><code><strong><a href="#model.NodeSpec.defining">defining</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Determines whether this node is considered an important parent
node during replace operations (such as paste). Non-defining (the
default) nodes get dropped when their entire content is replaced,
whereas defining nodes persist and wrap the inserted content.
Likewise, in inserted content the defining parents of the
content are preserved when possible. Typically,
non-default-paragraph textblock types, and possibly list items,
are marked as defining." lang="cn">决定当前节点是否在替换操作中被认为是一个重要的父级节点（如粘贴操作）。当节点的内容被整个替换掉的时候，
若该节点的 defining 为 false（默认），则其会被移除，但是 defining 为 true 的节点会保留，然后包裹住替换进来的内容。
同样地，对于 <em>插入的</em> 内容，那些有着 defining 为 true 的父级节点会被尽可能的保留。一般来说，非默认段落的文本块节点类型及 li 元素，defining 应该是 true。</p>
<p type="comment"><span>注: </span>最后一句话讲的是，例如，默认的 paragraph 中，文本块节点，粘贴的时候应该直接替换掉它的父节点，也即另一个文本块。
但是对非默认 paragraph（即你自己定制的 paragraph）的话，在替换内容的时候，就需要保留该 非默认 paragraph 的一些属性，不能直接替换。同理 li 元素，
因为首先选中 li 元素内容，然后粘贴内容是一个很常见的操作，用户的预期是将粘贴内容作为 li 的内容，而不是直接替换掉 li 而粘贴成 paragraph（或其他 block）。</p>
</dd><dt id="model.NodeSpec.isolating"><code><strong><a href="#model.NodeSpec.isolating">isolating</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When enabled (default is false), the sides of nodes of this type
count as boundaries that regular editing operations, like
backspacing or lifting, won't cross. An example of a node that
should probably have this enabled is a table cell." lang="cn">当该属性设置为 true 时（默认是 false），当前类型的节点的两侧将会计算作为边界，于是对于正常的编辑操作如删除、或者提升，将不会被跨越过去。
举个例子，对于 table 的 cell 节点，该属性应该被设置为 true。</p>
<p type="comment"><span>注: </span>「提升」操作指的是，如在一个二级 li 中，一般用户习惯下，按 shift + tab 会将该二级 li 提升到一级 li。</p>
<p type="comment"><span>注: </span>「跨越」指的是，操作会跨过当前节点到达下一个（或者上一个）节点。如删除操作，在段落起始位置继续按删除键，光标会跑到上一个节点的尾部；
在 li 起始位置按删除键，光标会跑到上一个 li 结尾处或者直接删除整个 ul/ol；但是在 table 的 td 中，在 td 起始位置按删除键跑到上一个 td 结尾，
显然不是预期。</p>
</dd><dt id="model.NodeSpec.toDOM"><code><strong><a href="#model.NodeSpec.toDOM">toDOM</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#model.DOMOutputSpec"><span class="type">DOMOutputSpec</span></a></code></dt>

<dd>
<p data-en="Defines the default way a node of this type should be serialized
to DOM/HTML (as used by
DOMSerializer.fromSchema).
Should return a DOM node or an array
structure that describes one, with an
optional number zero (“hole”) in it to indicate where the node's
content should be inserted." lang="cn">定义当前节点的默认序列化成 DOM/HTML 的方式（被<a href="#model.DOMSerializer%5EfromSchema"><code>DOMSerializer.fromSchema</code></a>使用）。
应该返回一个 DOM 节点或者一个描述 ODM 节点的 <a href="#model.DOMOutputSpec">array structure</a>，它带有可选的数字 0 （就是「洞」），
表示节点的内容应该被插在哪个位置。</p>

<p data-en="For text nodes, the default is to create a text DOM node. Though
it is possible to create a serializer where text is rendered
differently, this is not supported inside the editor, so you
shouldn't override that in your text node spec." lang="cn">对于文本节点，默认是创建一个文本 DOM 节点。虽然创建序列化器以将文本节点特殊渲染是可能的，但是当前编辑器并不支持这样做，因此你不应该覆盖文本节点中的该方法。</p>
</dd><dt id="model.NodeSpec.parseDOM"><code><strong><a href="#model.NodeSpec.parseDOM">parseDOM</a></strong>: ?⁠[<a href="#model.ParseRule"><span class="type">ParseRule</span></a>]</code></dt>

<dd>
<p data-en="Associates DOM parser information with this node, which can be
used by DOMParser.fromSchema to
automatically derive a parser. The node field in the rules is
implied (the name of this node will be filled in automatically).
If you supply your own parser, you do not need to also specify
parsing rules in your schema." lang="cn">当前节点相关的 DOM parser 信息，会被 <a href="#model.DOMParser%5EfromSchema"><code>DOMParser.fromSchema</code></a>
使用以自动的衍生出一个 parser。Rule 中的 <code>node</code> 字段是隐式的（节点的名字会自动填充）。如果你在此处提供了自己的 parser，那你就不需要再在 schema 配置的时候提供 parser 了。</p>
<p type="comment"><span>注: </span>配置 Editor view 的时候可以配置一个 Parser 和 Serializer，如果提供，则此处就不用写 parseDOM 了。</p>
</dd><dt id="model.NodeSpec.toDebugString"><code><strong><a href="#model.NodeSpec.toDebugString">toDebugString</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Defines the default way a node of this type should be serialized
to a string representation for debugging (e.g. in error messages)." lang="cn">定义一个该类型节点被序列化成一个字符串形式的默认方法，以做 debugging 用途。</p>
</dd></dl>
<h4 id="model.MarkSpec">
  <a href="#model.MarkSpec">MarkSpec</a> <span class="kind">interface</span></h4><dl><dt id="model.MarkSpec.attrs"><code><strong><a href="#model.MarkSpec.attrs">attrs</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<a href="#model.AttributeSpec"><span class="type">AttributeSpec</span></a>&gt;</code></dt>

<dd>
<p data-en="The attributes that marks of this type get." lang="cn">当前 mark 类型拿到的 attributes。</p>
</dd><dt id="model.MarkSpec.inclusive"><code><strong><a href="#model.MarkSpec.inclusive">inclusive</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Whether this mark should be active when the cursor is positioned
at its end (or at its start when that is also the start of the
parent node). Defaults to true." lang="cn">当光标放到该 mark 的结尾处（或者如果该 mark 开始处同样是父级节点的开始处时，放到 mark 的开始处）时，该 marks 是否应该被激活。默认是 true/</p>
<p type="comment"><span>注: </span>「被激活」的意思是，可以通过 API 获取光标所在的 resolvedPos 信息以查到相关的 marks，对用户来说被激活意味着在该地方输入内容会带上相应的 marks。</p>
</dd><dt id="model.MarkSpec.excludes"><code><strong><a href="#model.MarkSpec.excludes">excludes</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Determines which other marks this mark can coexist with. Should
be a space-separated strings naming other marks or groups of marks.
When a mark is added to a set, all marks
that it excludes are removed in the process. If the set contains
any mark that excludes the new mark but is not, itself, excluded
by the new mark, the mark can not be added an the set. You can
use the value &quot;_&quot; to indicate that the mark excludes all
marks in the schema." lang="cn">决定当前 mark 是否能和其他 marks 共存。应该是由其他 marks 名或者 marks group 组成的以空格分隔的字符串。
当一个 marks 被 <a href="#model.Mark.addToSet">added</a> 到一个集合中时，所有的与此 marks 排斥（excludes）的 marks 将会被在添加过程中移除。
如果当前集合包含任何排斥当前的新 mark 的 mark，但是该新 mark 却不排斥它，则当前新的 mark 不会被添加到集合中。你可以使用 <code>"_"</code> 来表明当前 marks
排斥所有的 schema 中的其他 marks。</p>
<p type="comment"><span>注: </span>该段的主要意思是，第一：假设 A 、B 互斥，则 无论 A 添加到包含 B 的集合，还是 B 添加到 包含 A 的集合，已经在集合中的一方会被移除以添加新的 mark；
第二：若假设 A 排斥 B，B 却不排斥 A，则将 B 添加到包含 A 的集合中去的时候，将不会被添加进去。</p>

<p data-en="Defaults to only being exclusive with marks of the same type. You
can set it to an empty string (or any string not containing the
mark's own name) to allow multiple marks of a given type to
coexist (as long as they have different attributes)." lang="cn">默认是相同类型的 marks 会互斥。你可以将其设置为一个空的字符串（或者任何不包含 mark 自身名字的字符串）
以允许给定相同类型的多个 marks 共存（之哟啊他们有不同的 attributes）。</p>
</dd><dt id="model.MarkSpec.group"><code><strong><a href="#model.MarkSpec.group">group</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The group or space-separated groups to which this mark belongs." lang="cn">当前 mark 所属的 一个 group 或者空格分隔的多个 groups。</p>
</dd><dt id="model.MarkSpec.spanning"><code><strong><a href="#model.MarkSpec.spanning">spanning</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Determines whether marks of this type can span multiple adjacent
nodes when serialized to DOM/HTML. Defaults to true." lang="cn">决定当序列化为 DOM/HTML 的时候，当前类型的 marks 能否应用到相邻的多个节点上去。默认是 true。</p>
</dd><dt id="model.MarkSpec.toDOM"><code><strong><a href="#model.MarkSpec.toDOM">toDOM</a></strong>: ?⁠<span class="fn">fn</span>(<span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>, <span class="param">inline:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="#model.DOMOutputSpec"><span class="type">DOMOutputSpec</span></a></code></dt>

<dd>
<p data-en="Defines the default way marks of this type should be serialized
to DOM/HTML. When the resulting spec contains a hole, that is
where the marked content is placed. Otherwise, it is appended to
the top node." lang="cn">定义当前类型的 marks 序列化为 DOM/HTML 的默认方式。如果结果配置对象包含一个「洞」，则洞的位置就是 mark 内容所在的位置。否则，它会被附加到顶级节点之后。</p>
<p type="comment"><span>注: </span>「否则，它会被附加到顶级节点之后」字面意思吗？有待实验，本人貌似没有印象了。</p>
</dd><dt id="model.MarkSpec.parseDOM"><code><strong><a href="#model.MarkSpec.parseDOM">parseDOM</a></strong>: ?⁠[<a href="#model.ParseRule"><span class="type">ParseRule</span></a>]</code></dt>

<dd>
<p data-en="Associates DOM parser information with this mark (see the
corresponding node spec field). The
mark field in the rules is implied." lang="cn">当前 mark 的相关的 DOM parser 信息（具体请查看相应的 <a href="#model.NodeSpec.parseDOM">node spec field</a>）。
在 Rules 中的 <code>mark</code> 字段是隐式的。</p>
</dd></dl>
<h4 id="model.AttributeSpec">
  <a href="#model.AttributeSpec">AttributeSpec</a> <span class="kind">interface</span></h4>
<p data-en="Used to define attributes on nodes or
marks." lang="cn">用来 <a href="#model.NodeSpec.attrs">define</a> node 或者 marks 的 attributes。</p>
<dl><dt id="model.AttributeSpec.default"><code><strong><a href="#model.AttributeSpec.default">default</a></strong>: ?⁠<span class="prim">any</span></code></dt>

<dd>
<p data-en="The default value for this attribute, to use when no explicit
value is provided. Attributes that have no default must be
provided whenever a node or mark of a type that has them is
created." lang="cn">该 attribute 的默认值，当没有显式提供值的时候使用。如果 attributes 没有默认值，则必须在新建一个 node 或者 mark 的时候提供值。</p>
</dd></dl>
<h4 id="model.NodeType">
  <a href="#model.NodeType">NodeType</a> <span class="kind">class</span></h4>
<p data-en="Node types are objects allocated once per Schema and used to
tag Node instances. They contain information
about the node type, such as its name and what kind of node it
represents." lang="cn">每个 Node Type 只会被 Schema 初始化一次，然后使用它来<a href="#model.Node.type">tag（归类）</a> <code>Node</code> 的实例。
这种对象包含了节点的类型信息，比如名称以及它表示那种节点。</p>
<dl><dt id="model.NodeType.name"><code><strong><a href="#model.NodeType.name">name</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The name the node type has in this schema." lang="cn">该节点类型在 schema 中的名称。</p>
</dd><dt id="model.NodeType.schema"><code><strong><a href="#model.NodeType.schema">schema</a></strong>: <a href="#model.Schema"><span class="type">Schema</span></a></code></dt>

<dd>
<p data-en="A link back to the Schema the node type belongs to." lang="cn">一个指向节点类型所属 <code>Schema</code> 的指针。</p>
</dd><dt id="model.NodeType.spec"><code><strong><a href="#model.NodeType.spec">spec</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="The spec that this type is based on" lang="cn">当前类型的配置对象。</p>
</dd><dt id="model.NodeType.contentMatch"><code><strong><a href="#model.NodeType.contentMatch">contentMatch</a></strong>: <a href="#model.ContentMatch"><span class="type">ContentMatch</span></a></code></dt>

<dd>
<p data-en="The starting match of the node type's content expression." lang="cn">节点类型内容表达式的起始匹配。</p>
<p type="comment"><span>注: </span>sorry，这个 contentMatch 我用的比较少，所以也不知道是什么意思，貌似源码内部使用的比较多。</p>
</dd><dt id="model.NodeType.inlineContent"><code><strong><a href="#model.NodeType.inlineContent">inlineContent</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True if this node type has inline content." lang="cn">如果当前节点类型有内联内容的话，即为 true。</p>
</dd><dt id="model.NodeType.isBlock"><code><strong><a href="#model.NodeType.isBlock">isBlock</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True if this is a block type" lang="cn">当前节点是块级类型的话，即为 true。</p>
<p type="comment"><span>注: </span>判断是否是块级类型是用排除法，如果不是内联类型（即 spec.inline 是 false）且节点类型的名称不是「text」，则该类型是块级类型。</p>
</dd><dt id="model.NodeType.isText"><code><strong><a href="#model.NodeType.isText">isText</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True if this is the text node type." lang="cn">如果是文本类型的节点，即为 true。</p>
<p type="comment"><span>注: </span>也即节点名字是「text」。</p>
</dd><dt id="model.NodeType.isInline"><code><strong><a href="#model.NodeType.isInline">isInline</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True if this is an inline type." lang="cn">如果是一个内联类型，则为 true。</p>
<p type="comment"><span>注: </span>同样使用排除法，即与 spec.isBlock 互斥。</p>
</dd><dt id="model.NodeType.isTextblock"><code><strong><a href="#model.NodeType.isTextblock">isTextblock</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True if this is a textblock type, a block that contains inline
content." lang="cn">如果节点是文本块类型节点则为 true，即一个包含内联内容的块级类型节点。</p>
<p type="comment"><span>注: </span>一个块级类型可能包含另一个块级类型，一个文本块类型则只会包含内联内容，哪些节点是内联元素由 schema 决定。</p>
<p type="comment"><span>注: </span>文本块类型的判断需要同时满足 spec.isBlock 和 spec.inlineContent 同时为 true。</p>
</dd><dt id="model.NodeType.isLeaf"><code><strong><a href="#model.NodeType.isLeaf">isLeaf</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True for node types that allow no content." lang="cn">如果节点不允许内容，则为 true。</p>
<p type="comment"><span>注: </span>是否是叶节点使用的是 spec.contentMatch 是否为空判断的。</p>
</dd><dt id="model.NodeType.isAtom"><code><strong><a href="#model.NodeType.isAtom">isAtom</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this node is an atom, i.e. when it does not have
directly editable content." lang="cn">如果节点是一个原子节点则为 true，例如，一个没有直接可编辑的内容的节点。</p>
</dd><dt id="model.NodeType.hasRequiredAttrs"><code><strong><a href="#model.NodeType.hasRequiredAttrs">hasRequiredAttrs</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Tells you whether this node type has any required attributes." lang="cn">告诉你该节点类型是否有任何必须的 attributes。</p>
</dd><dt id="model.NodeType.create"><code><strong><a href="#model.NodeType.create">create</a></strong>(<span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">content:</span>&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a> | <a href="#model.Node"><span class="type">Node</span></a> | [<a href="#model.Node"><span class="type">Node</span></a>], <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Create a Node of this type. The given attributes are
checked and defaulted (you can pass null to use the type's
defaults entirely, if no required attributes exist). content
may be a Fragment, a node, an array of nodes, or
null. Similarly marks may be null to default to the empty
set of marks." lang="cn">新建一个此种类型的节点。将会检查给定的 attributes，未给定的话即为默认值（如果该中类型的节点没有任何必须的 attributes，你可以直接传递 <code>null</code> 来使用全部 attributes 的默认值）。
<code>content</code> 可能是一个 <code>Fragment</code>、一个节点、一个节点数组或者 <code>null</code>。<code>marks</code> 参数与之类似，默认是 <code>null</code>，表示空的 marks 集合。</p>
</dd><dt id="model.NodeType.createChecked"><code><strong><a href="#model.NodeType.createChecked">createChecked</a></strong>(<span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">content:</span>&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a> | <a href="#model.Node"><span class="type">Node</span></a> | [<a href="#model.Node"><span class="type">Node</span></a>], <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Like create, but check the given content
against the node type's content restrictions, and throw an error
if it doesn't match." lang="cn">与 <a href="#model.NodeType.create"><code>create</code></a> 类似，但是会检查给定的 content 是否符合节点类型的内容限制，如果不符的话会抛出一个错误。</p>
<p type="comment"><span>注: </span>该自定义错误类型为 RangeError。</p>
</dd><dt id="model.NodeType.createAndFill"><code><strong><a href="#model.NodeType.createAndFill">createAndFill</a></strong>(<span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">content:</span>&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a> | <a href="#model.Node"><span class="type">Node</span></a> | [<a href="#model.Node"><span class="type">Node</span></a>], <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Like create, but see if it is necessary to
add nodes to the start or end of the given fragment to make it
fit the node. If no fitting wrapping can be found, return null.
Note that, due to the fact that required nodes can always be
created, this will always succeed if you pass null or
Fragment.empty as content." lang="cn">和 <a href="#model.NodeType.create"><code>create</code></a> 类似，不过该方法会查看是否有必要在给定的 fragment 开始和结尾的地方
添加一些节点，以让该 fragment 适应当前 node。如果没有找到合适的包裹节点，则返回 null。
记住，如果你传递 <code>null</code> 或者 <code>Fragment.empty</code> 作为内容会导致其一定会适合当前 node，因此该方法一定会成功。</p>
<p type="comment"><span>注: </span>因为 <code>null</code> 和 <code>Fragment.empty</code> 不用寻找任何「合适的包裹节点」就能适应当前节点。</p>
</dd><dt id="model.NodeType.validContent"><code><strong><a href="#model.NodeType.validContent">validContent</a></strong>(<span class="param">content:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Returns true if the given fragment is valid content for this node
type with the given attributes." lang="cn">如果给定的 fragment 对当前带有 attributes 的节点是可用的，则返回 true。</p>
</dd><dt id="model.NodeType.allowsMarkType"><code><strong><a href="#model.NodeType.allowsMarkType">allowsMarkType</a></strong>(<span class="param">markType:</span>&nbsp;<a href="#model.MarkType"><span class="type">MarkType</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Check whether the given mark type is allowed in this node." lang="cn">检查当前节点类型是否允许给定的 mark 类型。</p>
</dd><dt id="model.NodeType.allowsMarks"><code><strong><a href="#model.NodeType.allowsMarks">allowsMarks</a></strong>(<span class="param">marks:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether the given set of marks are allowed in this node." lang="cn">检查当前节点类型是否允许给定的 marks 集合。</p>
</dd><dt id="model.NodeType.allowedMarks"><code><strong><a href="#model.NodeType.allowedMarks">allowedMarks</a></strong>(<span class="param">marks:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="Removes the marks that are not allowed in this node from the given set." lang="cn">从给定的 marks 集合中移除不允许出现在当前 node 中的 marks。</p>
</dd></dl>
<h4 id="model.MarkType">
  <a href="#model.MarkType">MarkType</a> <span class="kind">class</span></h4>
<p data-en="Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
tagged with type objects, which are
instantiated once per Schema." lang="cn">和 nodes 类似，marks（与 node 关联的以表示诸如强调、链接等的内容）也被用类型对象进行 <a href="#model.Mark.type">tagged（归类）</a>，
每个类型只会被 <code>Schema</code> 实例化一次。</p>
<dl><dt id="model.MarkType.name"><code><strong><a href="#model.MarkType.name">name</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The name of the mark type." lang="cn">mark 类型的名称。</p>
</dd><dt id="model.MarkType.schema"><code><strong><a href="#model.MarkType.schema">schema</a></strong>: <a href="#model.Schema"><span class="type">Schema</span></a></code></dt>

<dd>
<p data-en="The schema that this mark type instance is part of." lang="cn">当前 mark 类型所属于的 schema。</p>
</dd><dt id="model.MarkType.spec"><code><strong><a href="#model.MarkType.spec">spec</a></strong>: <a href="#model.MarkSpec"><span class="type">MarkSpec</span></a></code></dt>

<dd>
<p data-en="The spec on which the type is based." lang="cn">当前 mark 类型的配置对象。</p>
</dd><dt id="model.MarkType.create"><code><strong><a href="#model.MarkType.create">create</a></strong>(<span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a></code></dt>

<dd>
<p data-en="Create a mark of this type. attrs may be null or an object
containing only some of the mark's attributes. The others, if
they have defaults, will be added." lang="cn">创建一个当前类型的 mark。<code>attrs</code> 可能是 <code>null</code> 或者是一个仅包含部分 marks attributes 的对象。
其他未包含的 attributes，会使用它们的默认值添加上去。</p>
</dd><dt id="model.MarkType.removeFromSet"><code><strong><a href="#model.MarkType.removeFromSet">removeFromSet</a></strong>(<span class="param">set:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]</code></dt>

<dd>
<p data-en="When there is a mark of this type in the given set, a new set
without it is returned. Otherwise, the input set is returned." lang="cn">如果当前 mark 类型存在与给定的 mark 集合，则将会返回不含有当前 mark 类型的 marks 集合。
否则，直接返回给定的 marks 集合。</p>
<p type="comment"><span>注: </span>看函数名，顾名思义就是在给定 marks 集合中移除当前 mark 类型的 marks。</p>
</dd><dt id="model.MarkType.isInSet"><code><strong><a href="#model.MarkType.isInSet">isInSet</a></strong>(<span class="param">set:</span>&nbsp;[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;?⁠<a href="#model.Mark"><span class="type">Mark</span></a></code></dt>

<dd>
<p data-en="Tests whether there is a mark of this type in the given set." lang="cn">检查当前类型的 marks 是否存在于给定 marks 集合。</p>
</dd><dt id="model.MarkType.excludes"><code><strong><a href="#model.MarkType.excludes">excludes</a></strong>(<span class="param">other:</span>&nbsp;<a href="#model.MarkType"><span class="type">MarkType</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Queries whether a given mark type is
excluded by this one." lang="cn">查询给定的 mark 类型是否与当前 mark 类型 <a href="#model.MarkSpec.excludes">excluded（互斥）</a></p>
</dd></dl>
<h4 id="model.ContentMatch">
  <a href="#model.ContentMatch">ContentMatch</a> <span class="kind">class</span></h4>
<p data-en="Instances of this class represent a match state of a node
type's content expression, and can be
used to find out whether further content matches here, and whether
a given position is a valid end of the node." lang="cn">该类的实例表示一个节点类型的 <a href="#model.NodeSpec.content">content expression（内容表达式）</a> 的匹配状态，
其可以用来寻找是否此处是否有更进一步的内容能够匹配到，以及判断一个位置是否是该节点的可用的结尾。</p>
<p type="comment"><span>注: </span>本小节的方法和类我用的不多，可能在处理一些边缘 case 的情况才会用到，因此很多直译了。</p>
<dl><dt id="model.ContentMatch.validEnd"><code><strong><a href="#model.ContentMatch.validEnd">validEnd</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when this match state represents a valid end of the node." lang="cn">当匹配状态表示该节点有一个可用的结尾时为 true。</p>
</dd><dt id="model.ContentMatch.matchType"><code><strong><a href="#model.ContentMatch.matchType">matchType</a></strong>(<span class="param">type:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>) →&nbsp;?⁠<a href="#model.ContentMatch"><span class="type">ContentMatch</span></a></code></dt>

<dd>
<p data-en="Match a node type, returning a match after that node if
successful." lang="cn">匹配一个节点类型，如果成功则返回该 ContentMatch 匹配结果。</p>
</dd><dt id="model.ContentMatch.matchFragment"><code><strong><a href="#model.ContentMatch.matchFragment">matchFragment</a></strong>(<span class="param">frag:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>, <span class="param">start:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 0</span>, <span class="param">end:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = frag.childCount</span>) →&nbsp;?⁠<a href="#model.ContentMatch"><span class="type">ContentMatch</span></a></code></dt>

<dd>
<p data-en="Try to match a fragment. Returns the resulting match when
successful." lang="cn">尝试去匹配一个 fragment。如果成功则返回 ContentMatch 匹配结果。</p>
</dd><dt id="model.ContentMatch.defaultType"><code><strong><a href="#model.ContentMatch.defaultType">defaultType</a></strong>: ?⁠<a href="#model.NodeType"><span class="type">NodeType</span></a></code></dt>

<dd>
<p data-en="Get the first matching node type at this match position that can
be generated." lang="cn">获取相应匹配位置的第一个可以被生成的匹配节点类型。</p>
<p type="comment"><span>注: </span>「可以被生成的」指的是该位置不能是文本节点或者不能有必须存在的 attribute 才能被生成。</p>
</dd><dt id="model.ContentMatch.fillBefore"><code><strong><a href="#model.ContentMatch.fillBefore">fillBefore</a></strong>(<span class="param">after:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>, <span class="param">toEnd:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a><span class="defaultvalue"> = false</span>, <span class="param">startIndex:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 0</span>) →&nbsp;?⁠<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="Try to match the given fragment, and if that fails, see if it can
be made to match by inserting nodes in front of it. When
successful, return a fragment of inserted nodes (which may be
empty if nothing had to be inserted). When toEnd is true, only
return a fragment if the resulting match goes to the end of the
content expression." lang="cn">尝试匹配给定的 fragment，如果失败，则会查看是否可以通过在该 fragment 前面插入一些节点来使之匹配。
如果插入节点后匹配成功，则会返回一个插入的节点组成的 fragment（如果没有需要插入的节点，则可能是空的）。
当 <code>toEnd</code> 为 true 时，只有结果匹配到达了内容表达式的结尾之时，才会返回一个 fragment。</p>
<p type="comment"><span>注: </span>否则返回 undefined。</p>
</dd><dt id="model.ContentMatch.findWrapping"><code><strong><a href="#model.ContentMatch.findWrapping">findWrapping</a></strong>(<span class="param">target:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>) →&nbsp;?⁠[<a href="#model.NodeType"><span class="type">NodeType</span></a>]</code></dt>

<dd>
<p data-en="Find a set of wrapping node types that would allow a node of the
given type to appear at this position. The result may be empty
(when it fits directly) and will be null when no such wrapping
exists." lang="cn">寻找一个包裹给定节点的节点集合，该集合中的节点在包裹住给定类型的节点后才能出现在当前位置。
集合的内容可能是空（如果给定类型节点直接就适合当前位置而无需包裹任何节点时），若不存在相应的包裹节点，则集合也可能是 null。</p>
</dd><dt id="model.ContentMatch.edgeCount"><code><strong><a href="#model.ContentMatch.edgeCount">edgeCount</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The number of outgoing edges this node has in the finite
automaton that describes the content expression." lang="cn">在描述内容表达式的有限自动机中该节点拥有的外部边界的数量。</p>
<p type="comment"><span>注: </span>没理解什么意思，需要看源码，我直译的，鼠标悬浮查看原始文档。</p>
</dd><dt id="model.ContentMatch.edge"><code><strong><a href="#model.ContentMatch.edge">edge</a></strong>(<span class="param">n:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;{<span class="prop">type:&nbsp;</span><a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="prop">next:&nbsp;</span><a href="#model.ContentMatch"><span class="type">ContentMatch</span></a>}</code></dt>

<dd>
<p data-en="Get the _n_​th outgoing edge from this node in the finite
automaton that describes the content expression." lang="cn">在描述内容表达式的有限自动机中获取该节点第 <em>n</em> 个外部的边界。</p>
</dd></dl>
<h3 id="model.DOM_Representation"><a href="#model.DOM_Representation">DOM Representation</a></h3>

<p data-en="Because representing a document as a tree of DOM nodes is central to
the way ProseMirror operates, DOM parsing and
serializing is integrated with the model." lang="cn">由于用一颗 DOM 节点树来表示一个文档是 ProseMirror 进行各种操作的核心思想，因此 DOM <a href="#model.DOMParser">parsing</a> 和 <a href="#model.DOMSerializer">serializing</a> 被集成进该模块中。</p>

<p data-en="(But note that you do not need to have a DOM implementation loaded
to use this module.)" lang="cn">（不过记住，你 <em>不需要</em> 使用该模块来实现一个 DOM 操作接口。）</p>
<h4 id="model.DOMParser">
  <a href="#model.DOMParser">DOMParser</a> <span class="kind">class</span></h4>
<p data-en="A DOM parser represents a strategy for parsing DOM content into
a ProseMirror document conforming to a given schema. Its behavior
is defined by an array of rules." lang="cn">一个为了让 ProseMirror 文档符合给定 schema 的 Parser。它的行为由一个 <a href="#model.ParseRule">rules</a> 数组定义。</p>
<dl><dt id="model.DOMParser.constructor"><code>new <strong><a href="#model.DOMParser.constructor">DOMParser</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>, <span class="param">rules:</span>&nbsp;[<a href="#model.ParseRule"><span class="type">ParseRule</span></a>])</code></dt>

<dd>
<p data-en="Create a parser that targets the given schema, using the given
parsing rules." lang="cn">新建一个针对给定 schema 的 parser，使用给定的 parsing rules。</p>
</dd><dt id="model.DOMParser.schema"><code><strong><a href="#model.DOMParser.schema">schema</a></strong>: <a href="#model.Schema"><span class="type">Schema</span></a></code></dt>

<dd>
<p data-en="The schema into which the parser parses." lang="cn">parser 所 parses 的 schema。</p>
<p type="comment"><span>注: </span>解析器所解析的 schema。</p>
</dd><dt id="model.DOMParser.rules"><code><strong><a href="#model.DOMParser.rules">rules</a></strong>: [<a href="#model.ParseRule"><span class="type">ParseRule</span></a>]</code></dt>

<dd>
<p data-en="The set of parse rules that the parser
uses, in order of precedence." lang="cn">parser 所使用的 <a href="#model.ParseRule">parse rules</a>，按顺序优先。</p>
</dd><dt id="model.DOMParser.parse"><code><strong><a href="#model.DOMParser.parse">parse</a></strong>(<span class="param">dom:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="param">options:</span>&nbsp;?⁠<a href="#model.ParseOptions"><span class="type">ParseOptions</span></a><span class="defaultvalue"> = {}</span>) →&nbsp;<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="Parse a document from the content of a DOM node." lang="cn">parse 一个 DOM 节点的内容成一个文档。</p>
</dd><dt id="model.DOMParser.parseSlice"><code><strong><a href="#model.DOMParser.parseSlice">parseSlice</a></strong>(<span class="param">dom:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="param">options:</span>&nbsp;?⁠<a href="#model.ParseOptions"><span class="type">ParseOptions</span></a><span class="defaultvalue"> = {}</span>) →&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd>
<p data-en="Parses the content of the given DOM node, like
parse, and takes the same set of
options. But unlike that method, which produces a whole node,
this one returns a slice that is open at the sides, meaning that
the schema constraints aren't applied to the start of nodes to
the left of the input and the end of nodes at the end." lang="cn">parses 给定的 DOM 节点，与 <a href="#model.DOMParser.parse"><code>parse</code></a> 类似，接受与之相同的参数。
不过与 parse 方法产生一整个节点不同的是，这个方法返回一个在节点两侧打开的 slice，这意味着 schema
的约束不适用于输入节点左侧节点的开始位置和末尾节点的结束位置。</p>
<p type="comment"><span>注: </span>这表示该方法可能产生一个不受 schema 约束的 node，只是该 node 由于 openStart 和 openEnd 的存在而适合 schema
（被 open 剪切掉以适合 schema，但是整体不适合 schema）。</p>
</dd><dt id="model.DOMParser^fromSchema"><code>static <strong><a href="#model.DOMParser^fromSchema">fromSchema</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>) →&nbsp;<a href="#model.DOMParser"><span class="type">DOMParser</span></a></code></dt>

<dd>
<p data-en="Construct a DOM parser using the parsing rules listed in a
schema's node specs, reordered by
priority." lang="cn">用给定的 schema 中的 <a href="#model.NodeSpec.parseDOM">node 配置对象</a> 中的 parsing rule 来构造一个 DOM parser，
被按 <a href="#model.ParseRule.priority">优先级</a> 重新排序。</p>
</dd></dl>
<h4 id="model.ParseOptions">
  <a href="#model.ParseOptions">ParseOptions</a> <span class="kind">interface</span></h4>
<p data-en="These are the options recognized by the
parse and
parseSlice methods." lang="cn">这是一个被 <a href="#model.DOMParser.parse"><code>parse</code></a> 和 <a href="#model.DOMParser.parseSlice"><code>parseSlice</code></a> 方法用到的参数配置对象。</p>
<dl><dt id="model.ParseOptions.preserveWhitespace"><code><strong><a href="#model.ParseOptions.preserveWhitespace">preserveWhitespace</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a> | <span class="string">"full"</span></code></dt>

<dd>
<p data-en="By default, whitespace is collapsed as per HTML's rules. Pass
true to preserve whitespace, but normalize newlines to
spaces, and &quot;full&quot; to preserve whitespace entirely." lang="cn">默认情况下，根据 HTML 的规则，空白符会被折叠起来不显示。传递 <code>true</code> 表示保留空白符，但会将换行符表示为空格。
<code>"full"</code> 表示完全保留所有的空白符。</p>
</dd><dt id="model.ParseOptions.findPositions"><code><strong><a href="#model.ParseOptions.findPositions">findPositions</a></strong>: ?⁠[{<span class="prop">node:&nbsp;</span><a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="prop">offset:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>}]</code></dt>

<dd>
<p data-en="When given, the parser will, beside parsing the content,
record the document positions of the given DOM positions. It
will do so by writing to the objects, adding a pos property
that holds the document position. DOM positions that are not
in the parsed content will not be written to." lang="cn">如果设置了该参数，则 parser 除了 parsing 内容外，还将记录给定位置 DOM 在文档中相应的位置。
它将通过写入对象，添加一个保存文档位置的 <code>pos</code> 属性来实现。不在 parsed 内容中的 DOM 的位置将不会被写入。</p>
</dd><dt id="model.ParseOptions.from"><code><strong><a href="#model.ParseOptions.from">from</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The child node index to start parsing from." lang="cn">从开始 parsing 位置计算的子节点的索引。</p>
</dd><dt id="model.ParseOptions.to"><code><strong><a href="#model.ParseOptions.to">to</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The child node index to stop parsing at." lang="cn">从结束 parsing 位置计算的子节点的索引。</p>
</dd><dt id="model.ParseOptions.topNode"><code><strong><a href="#model.ParseOptions.topNode">topNode</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="By default, the content is parsed into the schema's default
top node type. You can pass this
option to use the type and attributes from a different node
as the top container." lang="cn">默认情况下，内容会被 parsed 到 schema 的默认 <a href="#model.Schema.topNodeType">顶级节点</a> 中。
你可以传递这个选项和 attributes 以使用一个不同的节点作为顶级容器。</p>
</dd><dt id="model.ParseOptions.topMatch"><code><strong><a href="#model.ParseOptions.topMatch">topMatch</a></strong>: ?⁠<a href="#model.ContentMatch"><span class="type">ContentMatch</span></a></code></dt>

<dd>
<p data-en="Provide the starting content match that content parsed into the
top node is matched against." lang="cn">提供与 parsed 到顶级节点的内容匹配的起始内容匹配。</p>
</dd><dt id="model.ParseOptions.context"><code><strong><a href="#model.ParseOptions.context">context</a></strong>: ?⁠<a href="#model.ResolvedPos"><span class="type">ResolvedPos</span></a></code></dt>

<dd>
<p data-en="A set of additional nodes to count as
context when parsing, above the
given top node." lang="cn">在 parsing 的时候的一个额外的节点集合，其被算作给定 <a href="#model.ParseOptions.topNode">top node</a> 之上的 <a href="#model.ParseRule.context">context</a>。</p>
</dd></dl>
<h4 id="model.ParseRule">
  <a href="#model.ParseRule">ParseRule</a> <span class="kind">interface</span></h4>
<p data-en="A value that describes how to parse a given DOM node or inline
style as a ProseMirror node or mark." lang="cn">一个描述了如何 parse 给定 DOM 节点及行内样式成 ProseMirror 节点及 mark 的对象。</p>
<dl><dt id="model.ParseRule.tag"><code><strong><a href="#model.ParseRule.tag">tag</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="A CSS selector describing the kind of DOM elements to match. A
single rule should have either a tag or a style property." lang="cn">一个描述了需要匹配那种 DOM 元素的 CSS 选择器。每个 rule 都应该有一个 <code>tag</code> 属性 <em>或者</em> <code>style</code> 属性。</p>
</dd><dt id="model.ParseRule.namespace"><code><strong><a href="#model.ParseRule.namespace">namespace</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The namespace to match. This should be used with tag.
Nodes are only matched when the namespace matches or this property
is null." lang="cn">需要匹配的命名空间。应该和 <code>tag</code> 一起使用。只有命名空间匹配之后或者为 null 表示没有命名空间，才会开始匹配节点。</p>
</dd><dt id="model.ParseRule.style"><code><strong><a href="#model.ParseRule.style">style</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="A CSS property name to match. When given, this rule matches
inline styles that list that property. May also have the form
&quot;property=value&quot;, in which case the rule only matches if the
property's value exactly matches the given value. (For more
complicated filters, use getAttrs
and return false to indicate that the match failed.) Rules
matching styles may only produce marks,
not nodes." lang="cn">需要匹配的 CSS 属性名。如果给定的话，这个 rule 将会匹配包含该属性的行内样式。
也可以是 <code>"property=value"</code> 的形式，这种情况下 property 的值完全符合给定值时 rule 才会匹配。
（对于更复杂的过滤方式，使用 <a href="#model.ParseRule.getAttrs"><code>getAttrs</code></a>，然后返回 false 表示匹配失败。）</p>
</dd><dt id="model.ParseRule.priority"><code><strong><a href="#model.ParseRule.priority">priority</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Can be used to change the order in which the parse rules in a
schema are tried. Those with higher priority come first. Rules
without a priority are counted as having priority 50. This
property is only meaningful in a schema—when directly
constructing a parser, the order of the rule array is used." lang="cn">可以使用它来提升 schema 中 parse rule 的优先级顺序。更高优先级的更先被 parse。
没有优先级设置的 rule 则被默认设置一个 50 的优先级。该属性只在 schema 中才有意义。
而在直接构造一个 parser 的时候使用的是 rule 数组的顺序。</p>
</dd><dt id="model.ParseRule.consuming"><code><strong><a href="#model.ParseRule.consuming">consuming</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">boolean</span></a></code></dt>

<dd>
<p data-en="By default, when a rule matches an element or style, no further
rules get a chance to match it. By setting this to false, you
indicate that even when this rule matches, other rules that come
after it should also run." lang="cn">默认情况下，如果一个 rule 匹配了一个元素或者样式，那么就不会进一步的匹配接下来的 rule 了。
而通过设置该参数为 <code>false</code>，你可以决定即使当一个 rule 匹配了，在该 rule 之后的 rule 也依然会运行一次。</p>
</dd><dt id="model.ParseRule.context"><code><strong><a href="#model.ParseRule.context">context</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="When given, restricts this rule to only match when the current
context—the parent nodes into which the content is being
parsed—matches this expression. Should contain one or more node
names or node group names followed by single or double slashes.
For example &quot;paragraph/&quot; means the rule only matches when the
parent node is a paragraph, &quot;blockquote/paragraph/&quot; restricts
it to be in a paragraph that is inside a blockquote, and
&quot;section//&quot; matches any position inside a section—a double
slash matches any sequence of ancestor nodes. To allow multiple
different contexts, they can be separated by a pipe (|)
character, as in &quot;blockquote/|list_item/&quot;." lang="cn">如果设置了该属性，则限制 rule 只匹配给定的上下文表达式，该上下文即为被 parsed 的内容所在的父级节点。
应该包含一个或者多个节点名或者节点 group 名，用一个或者两个斜杠结尾。例如 <code>"paragraph/"</code> 表示只有当父级节点是段落的时候才会被匹配，
<code>"blockquote/paragraph/"</code> 限制只有在一个 blockquote 中的一个段落中才会被匹配，<code>"section//"</code> 表示匹配在一个 section 中的任何位置--一个双斜线表示匹配
任何祖先节点序列。为了允许多个不同的上下文，它们可以用 <code>|</code> 分隔，比如 <code>"blockquote/|list_item/"</code>。</p>
</dd><dt id="model.ParseRule.node"><code><strong><a href="#model.ParseRule.node">node</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The name of the node type to create when this rule matches. Only
valid for rules with a tag property, not for style rules. Each
rule should have one of a node, mark, or ignore property
(except when it appears in a node or
mark spec, in which case the node
or mark property will be derived from its position)." lang="cn">当 rule 匹配的时候，将要创建的节点类型的名字。仅对带有 <code>tag</code> 属性的 rules 可用，对样式 rule 无效。
每个 rule 应该有 <code>node</code>、<code>mark</code>、<code>ignore</code> 属性的其中一个（除非是当 rule 出现在一个 <a href="#model.NodeSpec.parseDOM">node</a> 或者
<a href="#model.MarkSpec.parseDOM">mark spec</a> 中时，在这种情况下，<code>node</code> 或者 <code>mark</code> 属性将会从它的位置推断出来）。</p>
</dd><dt id="model.ParseRule.mark"><code><strong><a href="#model.ParseRule.mark">mark</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="The name of the mark type to wrap the matched content in." lang="cn">包裹匹配内容的 mark 类型的名字。</p>
</dd><dt id="model.ParseRule.ignore"><code><strong><a href="#model.ParseRule.ignore">ignore</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When true, ignore content that matches this rule." lang="cn">如果是 true，则当前 rule 的内容会被忽略。</p>
</dd><dt id="model.ParseRule.closeParent"><code><strong><a href="#model.ParseRule.closeParent">closeParent</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When true, finding an element that matches this rule will close
the current node." lang="cn">如果是 true，则会在寻找匹配该 rule 的元素的时候关闭当前节点。</p>
</dd><dt id="model.ParseRule.skip"><code><strong><a href="#model.ParseRule.skip">skip</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When true, ignore the node that matches this rule, but do parse
its content." lang="cn">如果是 true，则会忽略匹配当前规则的节点，但是会 parse 它的内容。</p>
</dd><dt id="model.ParseRule.attrs"><code><strong><a href="#model.ParseRule.attrs">attrs</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Attributes for the node or mark created by this rule. When
getAttrs is provided, it takes precedence." lang="cn">由该 rule 创建的节点或者 mark 的 attributes。如果 <code>getAttrs</code> 存在的话，<code>getAttrs</code> 优先。</p>
</dd><dt id="model.ParseRule.getAttrs"><code><strong><a href="#model.ParseRule.getAttrs">getAttrs</a></strong>: ?⁠<span class="fn">fn</span>(<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a> | <span class="prim">false</span></code></dt>

<dd>
<p data-en="A function used to compute the attributes for the node or mark
created by this rule. Can also be used to describe further
conditions the DOM element or style must match. When it returns
false, the rule won't match. When it returns null or undefined,
that is interpreted as an empty/default set of attributes." lang="cn">用来计算由当前 rule 新建的节点或者 mark 的 attributes。也可以用来描述进一步 DOM 元素或者行内样式匹配的话需要满足的条件。
当它返回 <code>false</code>，则 rule 不会匹配。当它返回 null 或者 undefined，则被当成是一个空的/默认的 attributes 集合。</p>

<p data-en="Called with a DOM Element for tag rules, and with a string (the
style's value) for style rules." lang="cn">对于 <code>tag</code> rule 来说该方法参数是一个 DOM 元素，对于 <code>style</code> rule 来说参数是一个字符串（即行内样式的值）</p>
</dd><dt id="model.ParseRule.contentElement"><code><strong><a href="#model.ParseRule.contentElement">contentElement</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a> | <span class="fn">fn</span>(<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a></code></dt>

<dd>
<p data-en="For tag rules that produce non-leaf nodes or marks, by default
the content of the DOM element is parsed as content of the mark
or node. If the child nodes are in a descendent node, this may be
a CSS selector string that the parser must use to find the actual
content element, or a function that returns the actual content
element to the parser." lang="cn">对于 <code>tag</code> rule 来说，其产生一个非叶子节点的 node 或者 marks，默认情况下 DOM 元素的内容被 parsed 作为该 mark 或者
节点的内容。如果子节点在一个子孙节点中，则这个可能是一个 CSS 选择器字符串， parser 必须使用它以寻找实际的内容元素，或者是一个函数，
为 parser 返回实际的内容元素。</p>
</dd><dt id="model.ParseRule.getContent"><code><strong><a href="#model.ParseRule.getContent">getContent</a></strong>: ?⁠<span class="fn">fn</span>(<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>) →&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a></code></dt>

<dd>
<p data-en="Can be used to override the content of a matched node. When
present, instead of parsing the node's child nodes, the result of
this function is used." lang="cn">如果设置了该方法，则会使用函数返回的结果来作为匹配节点的内容，而不是 parsing 节点的子节点。</p>
</dd><dt id="model.ParseRule.preserveWhitespace"><code><strong><a href="#model.ParseRule.preserveWhitespace">preserveWhitespace</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a> | <span class="string">"full"</span></code></dt>

<dd>
<p data-en="Controls whether whitespace should be preserved when parsing the
content inside the matched element. false means whitespace may
be collapsed, true means that whitespace should be preserved
but newlines normalized to spaces, and &quot;full&quot; means that
newlines should also be preserved." lang="cn">控制当 parsing 匹配元素的内容的时候，空白符是否应该保留。<code>false</code> 表示空白符应该不显示，
<code>true</code> 表示空白符应该不显示但是换行符会被换成空格，<code>"full"</code> 表示换行符也应该被保留。</p>
</dd></dl>
<h4 id="model.DOMSerializer">
  <a href="#model.DOMSerializer">DOMSerializer</a> <span class="kind">class</span></h4>
<p data-en="A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes." lang="cn">一个 DOM serializer 知道如何将不同类型的 ProseMirror 节点和 marks 转换成 DOM 节点。</p>
<dl><dt id="model.DOMSerializer.constructor"><code>new <strong><a href="#model.DOMSerializer.constructor">DOMSerializer</a></strong>(<span class="param">nodes:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#model.DOMOutputSpec"><span class="type">DOMOutputSpec</span></a>&gt;, <span class="param">marks:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;?⁠<span class="fn">fn</span>(<span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>, <span class="param">inline:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="#model.DOMOutputSpec"><span class="type">DOMOutputSpec</span></a>&gt;)</code></dt>

<dd>
<p data-en="Create a serializer. nodes should map node names to functions
that take a node and return a description of the corresponding
DOM. marks does the same for mark names, but also gets an
argument that tells it whether the mark's content is block or
inline content (for typical use, it'll always be inline). A mark
serializer may be null to indicate that marks of that type
should not be serialized." lang="cn">新建一个 serializer。<code>nodes</code> 应该是一个对象，键是节点名，值是一个函数，函数接受一个节点作为参数，返回相应的 DOM 描述。
<code>marks</code> 类似，键值 marks 名，值是一个函数，只不过函数参数表示的是 marks 的内容是否是 block 的或者是 inline 的（一般情况下应该是 inline 的）。
一个 mark serializer 可能是 <code>null</code>，表示这种类型的 mark 不应该被 serialized（序列化）。</p>
</dd><dt id="model.DOMSerializer.nodes"><code><strong><a href="#model.DOMSerializer.nodes">nodes</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;<span class="fn">fn</span>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#model.DOMOutputSpec"><span class="type">DOMOutputSpec</span></a>&gt;</code></dt>

<dd>
<p data-en="The node serialization functions." lang="cn">节点的 serialization 函数们。</p>
</dd><dt id="model.DOMSerializer.marks"><code><strong><a href="#model.DOMSerializer.marks">marks</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>&lt;?⁠<span class="fn">fn</span>(<span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>, <span class="param">inline:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="#model.DOMOutputSpec"><span class="type">DOMOutputSpec</span></a>&gt;</code></dt>

<dd>
<p data-en="The mark serialization functions." lang="cn">mark 的 serialization 函数们。</p>
</dd><dt id="model.DOMSerializer.serializeFragment"><code><strong><a href="#model.DOMSerializer.serializeFragment">serializeFragment</a></strong>(<span class="param">fragment:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a>, <span class="param">options:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a><span class="defaultvalue"> = {}</span>) →&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment"><span class="type">dom.DocumentFragment</span></a></code></dt>

<dd>
<p data-en="Serialize the content of this fragment to a DOM fragment. When
not in the browser, the document option, containing a DOM
document, should be passed so that the serializer can create
nodes." lang="cn">将给定的 fragment serialize 成 DOM fragment。如果该操作不是在浏览器中完成，
那么应该传递一个 <code>document</code> 参数，以让 serializer 能够新建 nodes 们。</p>
<p type="comment"><span>注: </span>即 <code>option.document</code>，如果没有传，默认使用的是 <code>window.document</code>。</p>
</dd><dt id="model.DOMSerializer.serializeNode"><code><strong><a href="#model.DOMSerializer.serializeNode">serializeNode</a></strong>(<span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">options:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a><span class="defaultvalue"> = {}</span>) →&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a></code></dt>

<dd>
<p data-en="Serialize this node to a DOM node. This can be useful when you
need to serialize a part of a document, as opposed to the whole
document. To serialize a whole document, use
serializeFragment on
its content." lang="cn">将节点 serialize 成一个 DOM 节点。这对于当想要 serialize 文档的一部分而不是整个文档的时候很有用。
若要 serialize 整个文档，在它的 <a href="#model.Node.content">content</a> 属性上调用 <a href="#model.DOMSerializer.serializeFragment"><code>serializeFragment</code></a> 来完成。</p>
</dd><dt id="model.DOMSerializer^renderSpec"><code>static <strong><a href="#model.DOMSerializer^renderSpec">renderSpec</a></strong>(<span class="param">doc:</span>&nbsp;<a href="https://developer.mozilla.org/en/docs/DOM/document"><span class="type">dom.Document</span></a>, <span class="param">structure:</span>&nbsp;<a href="#model.DOMOutputSpec"><span class="type">DOMOutputSpec</span></a>) →&nbsp;{<span class="prop">dom:&nbsp;</span><a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>, <span class="prop">contentDOM:&nbsp;</span>?⁠<a href="https://developer.mozilla.org/en/docs/DOM/Node"><span class="type">dom.Node</span></a>}</code></dt>

<dd>
<p data-en="Render an output spec to a DOM node. If
the spec has a hole (zero) in it, contentDOM will point at the
node with the hole." lang="cn">渲染一个 <a href="#model.DOMOutputSpec">output 配置对象</a> 到一个 DOM 节点。如果配置对象有一个洞（数字0），
则 <code>contentDOM</code> 将会指向该洞所代表的节点。</p>
</dd><dt id="model.DOMSerializer^fromSchema"><code>static <strong><a href="#model.DOMSerializer^fromSchema">fromSchema</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>) →&nbsp;<a href="#model.DOMSerializer"><span class="type">DOMSerializer</span></a></code></dt>

<dd>
<p data-en="Build a serializer using the toDOM
properties in a schema's node and mark specs." lang="cn">使用 schema 中节点和 mark 配置对象的 <a href="#model.NodeSpec.toDOM"><code>toDOM</code></a> 方法来构建一个 serializer。</p>
</dd></dl>
<h4 id="model.DOMOutputSpec">
  <a href="#model.DOMOutputSpec">DOMOutputSpec</a> <span class="kind">interface</span></h4>
<p data-en="A description of a DOM structure. Can be either a string, which is
interpreted as a text node, a DOM node, which is interpreted as
itself, a {dom: Node, contentDOM: ?Node} object, or an array." lang="cn">一个 DOM 结构的描述。既可以是一个字符串，用来表示一个文本节点，也可以是一个 DOM 节点，表示它自身，亦或者是一个数组。</p>

<p data-en="An array describes a DOM element. The first value in the array
should be a string—the name of the DOM element, optionally prefixed
by a namespace URL and a space. If the second element is plain
object, it is interpreted as a set of attributes for the element.
Any elements after that (including the 2nd if it's not an attribute
object) are interpreted as children of the DOM elements, and must
either be valid DOMOutputSpec values, or the number zero." lang="cn">这个数组描述了一个 DOM 元素。数组中的第一个值应该是这个 DOM 元素名字字符串，可以允许带上命名空间 URL 的前缀或者空格。
如果数组第二个值是一个普通对象，则被当做是 DOM 元素的 attributes。在数组第二个值之后的任何值（包括第二个值，如果它不是一个普通属性对象的话）
都被认为是该 DOM 元素的子元素，因此这些后面的值必须是有一个有效的 <code>DOMOutputSpec</code> 值，或者是数字 0。</p>

<p data-en="The number zero (pronounced “hole”) is used to indicate the place
where a node's child nodes should be inserted. If it occurs in an
output spec, it should be the only child element in its parent
node." lang="cn">数字 0（念做「洞」）被用来指示子元素应该被放置的位置。如果子元素是一个会被放置内容的节点，那么 0 应该是它唯一子元素。</p>
<p type="comment"><span>注: </span>举个例子：
<code>['div', {style:'color:red'}, 0]</code>，表示的是 <code>&lt;div style="color:red"&gt;子元素&lt;div&gt;</code>;
<code>['div', {style:'color:red'}, ['p', 0]]</code>，表示的是 <code>&lt;div style="color:red"&gt;&lt;p&gt;子元素&lt;/p&gt;&lt;div&gt;</code>;
<code>['div', {style:'color:red'}, ['p'], 0]</code> 非法，因为 0 作为一个放置子元素的容器，其并不是父节点 <code>div</code> 的唯一子元素，父节点还有个子元素是 <code>p</code>。</p>
<dl></dl>
</section><section id=part_transform>
    <h2 class=module id=transform>
      <a href="#transform">prosemirror-transform <span class=kind>module</span></a>
    </h2>
<p data-en="This module defines a way of modifying documents that allows changes
to be recorded, replayed, and reordered. You can read more about
transformations in the guide." lang="cn">这个模块定义了一种修改文档的方式，以允许修改被记录、回放、重新排序。你可以在
<a href="https://xheldon.com/prosemirror-guide-chinese.html#document-transformations">中文指南</a> 了解更多。</p>
<h3 id="transform.Steps"><a href="#transform.Steps">Steps</a></h3>

<p data-en="Transforming happens in Steps, which are atomic, well-defined
modifications to a document. Applying a step
produces a new document." lang="cn">Transforming 发生在一个或者多个 <code>Step</code> 中，step 是原子的及定义良好的一个修改文档的类。
<a href="#transform.Step.apply">Applying（应用）</a> 一个 step 会产生一个新的文档。</p>

<p data-en="Each step provides a change map that maps
positions in the old document to position in the transformed document.
Steps can be inverted to create a step that
undoes their effect, and chained together in a convenience object
called a Transform." lang="cn">每个 step 提供一个 <a href="#transform.StepMap">change map（修改映射）</a>，它会在旧的文档和 transformed
后的文档之间映射。 Steps 可以被 <a href="#transform.Step.invert">inverted（反转）</a> 以新建一个 step 来取消之前 step 所做的影响，
而且可以在一个叫做 <a href="#transform.Transform"><code>Transform</code></a> 的对象上方便的链式调用。</p>
<h4 id="transform.Step">
  <a href="#transform.Step">Step</a> <span class="kind">class</span></h4>
<p data-en="A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document." lang="cn">一个 step 对象表示对文档的一个原子修改。大体上讲，它只会应用到创建它的那个文档上去，因为其内的位置信息只有对那个文档来说才有意义。</p>

<p data-en="New steps are defined by creating classes that extend Step,
overriding the apply, invert, map, getMap and fromJSON
methods, and registering your class with a unique
JSON-serialization identifier using
Step.jsonID." lang="cn">新的 steps 通过创建扩展自 <code>Step</code> 的类来定义，其覆盖了 <code>apply</code>、<code>invert</code>、<code>map</code>、<code>getMap</code> 和 <code>fromJSON</code> 方法，
此外注册类的时候还需要使用 <a href="#transform.Step%5EjsonID"><code>Step.jsonID</code></a> 来生成一个唯一的 JSON 序列化过的标识符。</p>
<dl><dt id="transform.Step.apply"><code><strong><a href="#transform.Step.apply">apply</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#transform.StepResult"><span class="type">StepResult</span></a></code></dt>

<dd>
<p data-en="Applies this step to the given document, returning a result
object that either indicates failure, if the step can not be
applied to this document, or indicates success by containing a
transformed document." lang="cn">将当前 step 应用到给定的文档，返回一个结果对象，对象可能表示失败，如果 step 不能被应用到文档中；
也可能表示成功，此时它会包含一个转换后的文档。</p>
</dd><dt id="transform.Step.getMap"><code><strong><a href="#transform.Step.getMap">getMap</a></strong>() →&nbsp;<a href="#transform.StepMap"><span class="type">StepMap</span></a></code></dt>

<dd>
<p data-en="Get the step map that represents the changes made by this step,
and which can be used to transform between positions in the old
and the new document." lang="cn">获取由当前 step 产生的表示文档变化的 step map，可以用来在新旧两个文档之间转换位置。</p>
</dd><dt id="transform.Step.invert"><code><strong><a href="#transform.Step.invert">invert</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#transform.Step"><span class="type">Step</span></a></code></dt>

<dd>
<p data-en="Create an inverted version of this step. Needs the document as it
was before the step as argument." lang="cn">新建一个当前 step 相反的 step 版本，需要 step 之前的文档作为参数。</p>
</dd><dt id="transform.Step.map"><code><strong><a href="#transform.Step.map">map</a></strong>(<span class="param">mapping:</span>&nbsp;<a href="#transform.Mappable"><span class="type">Mappable</span></a>) →&nbsp;?⁠<a href="#transform.Step"><span class="type">Step</span></a></code></dt>

<dd>
<p data-en="Map this step through a mappable thing, returning either a
version of that step with its positions adjusted, or null if
the step was entirely deleted by the mapping." lang="cn">通过一个可 mappable 的东西来 map 当前 step，返回值可能是一个调整过位置的 step 版本，
或者 <code>null</code>，如果 step 完全被这个 mapping 删除的话。</p>
</dd><dt id="transform.Step.merge"><code><strong><a href="#transform.Step.merge">merge</a></strong>(<span class="param">other:</span>&nbsp;<a href="#transform.Step"><span class="type">Step</span></a>) →&nbsp;?⁠<a href="#transform.Step"><span class="type">Step</span></a></code></dt>

<dd>
<p data-en="Try to merge this step with another one, to be applied directly
after it. Returns the merged step when possible, null if the
steps can't be merged." lang="cn">试着合并当前 step 与给定的 step，会被直接应用到当前 step 之后。如果可能的话，会返回合并之后的 step，
如果 step 不能被合并，则返回 null。</p>
</dd><dt id="transform.Step.toJSON"><code><strong><a href="#transform.Step.toJSON">toJSON</a></strong>() →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Create a JSON-serializeable representation of this step. When
defining this for a custom subclass, make sure the result object
includes the step type's JSON id under
the stepType property." lang="cn">新建一个当前 step JSON 序列化后的版本。如果为一个自定义的子类定义了该方法，则需要确保返回的结果对象的 <code>stepType</code> 属性值是
step 类型的 <a href="#transform.Step%5EjsonID">JSON id</a>。</p>
</dd><dt id="transform.Step^fromJSON"><code>static <strong><a href="#transform.Step^fromJSON">fromJSON</a></strong>(<span class="param">schema:</span>&nbsp;<a href="#model.Schema"><span class="type">Schema</span></a>, <span class="param">json:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#transform.Step"><span class="type">Step</span></a></code></dt>

<dd>
<p data-en="Deserialize a step from its JSON representation. Will call
through to the step class' own implementation of this method." lang="cn">从一个 step 的 JSON 形式反序列化为一个 step。将会调用 step 类自己实现的此方法。</p>
</dd><dt id="transform.Step^jsonID"><code>static <strong><a href="#transform.Step^jsonID">jsonID</a></strong>(<span class="param">id:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">stepClass:</span>&nbsp;<span class="prim">constructor</span>&lt;<a href="#transform.Step"><span class="type">Step</span></a>&gt;)</code></dt>

<dd>
<p data-en="To be able to serialize steps to JSON, each step needs a string
ID to attach to its JSON representation. Use this method to
register an ID for your step classes. Try to pick something
that's unlikely to clash with steps from other modules." lang="cn">为了能够将 steps 序列化为 JSON 形式，每个 step 都需要一个字符串 ID 附加到它自己的 JSON 形式上去。
使用这个方法为你的 step 类注册一个 ID。需要避免与其他模块的 step 的命名冲突。</p>
</dd></dl>
<h4 id="transform.StepResult">
  <a href="#transform.StepResult">StepResult</a> <span class="kind">class</span></h4>
<p data-en="The result of applying a step. Contains either a
new document or a failure value." lang="cn"><a href="#transform.Step.apply">applying（应用）</a> 一个 step 的结果。可能包含一个新的文档或者是一个失败的值。</p>
<dl><dt id="transform.StepResult.doc"><code><strong><a href="#transform.StepResult.doc">doc</a></strong>: ?⁠<a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The transformed document." lang="cn">transform 后的文档。</p>
</dd><dt id="transform.StepResult.failed"><code><strong><a href="#transform.StepResult.failed">failed</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="Text providing information about a failed step." lang="cn">提供失败信息的文本。</p>
</dd><dt id="transform.StepResult^ok"><code>static <strong><a href="#transform.StepResult^ok">ok</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="#transform.StepResult"><span class="type">StepResult</span></a></code></dt>

<dd>
<p data-en="Create a successful step result." lang="cn">创建一个成功的 step 结果。</p>
</dd><dt id="transform.StepResult^fail"><code>static <strong><a href="#transform.StepResult^fail">fail</a></strong>(<span class="param">message:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>) →&nbsp;<a href="#transform.StepResult"><span class="type">StepResult</span></a></code></dt>

<dd>
<p data-en="Create a failed step result." lang="cn">创建一个失败的 step 结果。</p>
</dd><dt id="transform.StepResult^fromReplace"><code>static <strong><a href="#transform.StepResult^fromReplace">fromReplace</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<a href="#transform.StepResult"><span class="type">StepResult</span></a></code></dt>

<dd>
<p data-en="Call Node.replace with the given
arguments. Create a successful result if it succeeds, and a
failed one if it throws a ReplaceError." lang="cn">用给定的参数调用 <a href="#model.Node.replace"><code>Node.replace</code></a>。如果成功就返回一个成功值，
如果它抛出一个 <code>ReplaceError</code> 则返回一个失败值。</p>
</dd></dl>
<h4 id="transform.ReplaceStep">
  <a href="#transform.ReplaceStep">ReplaceStep</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#transform.Step"><span class="type">Step</span></a></code></span></h4>
<p data-en="Replace a part of the document with a slice of new content." lang="cn">用含有新内容的 slice 来替换文档的一部分。</p>
<dl><dt id="transform.ReplaceStep.constructor"><code>new <strong><a href="#transform.ReplaceStep.constructor">ReplaceStep</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>, <span class="param">structure:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>)</code></dt>

<dd>
<p data-en="The given slice should fit the 'gap' between from and
to—the depths must line up, and the surrounding nodes must be
able to be joined with the open sides of the slice. When
structure is true, the step will fail if the content between
from and to is not just a sequence of closing and then opening
tokens (this is to guard against rebased replace steps
overwriting something they weren't supposed to)." lang="cn">给定的 slice 应该适应这个介于 <code>from</code> 和 <code>to</code> 之间的 「gap」，即 slice 两侧的深度和各自所接起来的位置深度必须是相同的，且 slice 周围
的节点必须能够接起来。当 <code>structure</code> 为 true 的时候，如果介意 from 和 to 之间的内容不是连续的先闭合后开放的标签，则 step 将会失败（这是为了
保证避免 rebased 的 replace step 意外覆盖了一些东西）。</p>
</dd><dt id="transform.ReplaceStep.from"><code><strong><a href="#transform.ReplaceStep.from">from</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The start position of the replaced range.</p>
</dd><dt id="transform.ReplaceStep.to"><code><strong><a href="#transform.ReplaceStep.to">to</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The end position of the replaced range.</p>
</dd><dt id="transform.ReplaceStep.slice"><code><strong><a href="#transform.ReplaceStep.slice">slice</a></strong>: <a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd><p>The slice to insert.</p>
</dd></dl>
<h4 id="transform.ReplaceAroundStep">
  <a href="#transform.ReplaceAroundStep">ReplaceAroundStep</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#transform.Step"><span class="type">Step</span></a></code></span></h4>
<p data-en="Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice." lang="cn">用一个 slice 的内容替换文档的一部分，不过会通过将被替换内容移动到 slice 中的方式来保留它的一个 range。</p>
<dl><dt id="transform.ReplaceAroundStep.constructor"><code>new <strong><a href="#transform.ReplaceAroundStep.constructor">ReplaceAroundStep</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">gapFrom:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">gapTo:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>, <span class="param">insert:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">structure:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>)</code></dt>

<dd>
<p data-en="Create a replace-around step with the given range and gap.
insert should be the point in the slice into which the content
of the gap should be moved. structure has the same meaning as
it has in the ReplaceStep class." lang="cn">用给定的 range 和 gap 来新建一个 replace-around step。 <code>insert</code> 应该指向的是在 slice 中 gap 的内容应该被放置的位置。
<code>structure</code> 有与它在 <a href="#transform.ReplaceStep"><code>ReplaceStep</code></a> 类中相同的含义。</p>
</dd><dt id="transform.ReplaceAroundStep.from"><code><strong><a href="#transform.ReplaceAroundStep.from">from</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The start position of the replaced range.</p>
</dd><dt id="transform.ReplaceAroundStep.to"><code><strong><a href="#transform.ReplaceAroundStep.to">to</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The end position of the replaced range.</p>
</dd><dt id="transform.ReplaceAroundStep.gapFrom"><code><strong><a href="#transform.ReplaceAroundStep.gapFrom">gapFrom</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The start of preserved range.</p>
</dd><dt id="transform.ReplaceAroundStep.gapTo"><code><strong><a href="#transform.ReplaceAroundStep.gapTo">gapTo</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The end of preserved range.</p>
</dd><dt id="transform.ReplaceAroundStep.slice"><code><strong><a href="#transform.ReplaceAroundStep.slice">slice</a></strong>: <a href="#model.Slice"><span class="type">Slice</span></a></code></dt>

<dd><p>The slice to insert.</p>
</dd><dt id="transform.ReplaceAroundStep.insert"><code><strong><a href="#transform.ReplaceAroundStep.insert">insert</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The position in the slice where the preserved range should be
inserted.</p>
</dd></dl>
<h4 id="transform.AddMarkStep">
  <a href="#transform.AddMarkStep">AddMarkStep</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#transform.Step"><span class="type">Step</span></a></code></span></h4>
<p data-en="Add a mark to all inline content between two positions." lang="cn">在给定的两个位置中的所有内联元素上添加一个 mark。</p>
<dl><dt id="transform.AddMarkStep.constructor"><code>new <strong><a href="#transform.AddMarkStep.constructor">AddMarkStep</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>)</code></dt>

<dd></dd><dt id="transform.AddMarkStep.from"><code><strong><a href="#transform.AddMarkStep.from">from</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The start of the marked range.</p>
</dd><dt id="transform.AddMarkStep.to"><code><strong><a href="#transform.AddMarkStep.to">to</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The end of the marked range.</p>
</dd><dt id="transform.AddMarkStep.mark"><code><strong><a href="#transform.AddMarkStep.mark">mark</a></strong>: <a href="#model.Mark"><span class="type">Mark</span></a></code></dt>

<dd><p>The mark to add.</p>
</dd></dl>
<h4 id="transform.RemoveMarkStep">
  <a href="#transform.RemoveMarkStep">RemoveMarkStep</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#transform.Step"><span class="type">Step</span></a></code></span></h4>
<p data-en="Remove a mark from all inline content between two positions." lang="cn">在给定的两个位置中的所有内联元素上移除一个 mark。</p>
<dl><dt id="transform.RemoveMarkStep.constructor"><code>new <strong><a href="#transform.RemoveMarkStep.constructor">RemoveMarkStep</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>)</code></dt>

<dd></dd><dt id="transform.RemoveMarkStep.from"><code><strong><a href="#transform.RemoveMarkStep.from">from</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The start of the unmarked range.</p>
</dd><dt id="transform.RemoveMarkStep.to"><code><strong><a href="#transform.RemoveMarkStep.to">to</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd><p>The end of the unmarked range.</p>
</dd><dt id="transform.RemoveMarkStep.mark"><code><strong><a href="#transform.RemoveMarkStep.mark">mark</a></strong>: <a href="#model.Mark"><span class="type">Mark</span></a></code></dt>

<dd><p>The mark to remove.</p>
</dd></dl>
<h3 id="transform.Position_Mapping"><a href="#transform.Position_Mapping">Position Mapping</a></h3>

<p data-en="Mapping positions from one document to another by running through the
step maps produced by steps is an important
operation in ProseMirror. It is used, for example, for updating the
selection when the document changes." lang="cn">通过调用由 step 产生的 <a href="#transform.StepMap">step maps</a> 来从一个文档中映射位置到另一个文档中在 ProseMirror 中是一个非常重要的操作。
例如，它被用来当文档改变的时候更新选区。</p>
<h4 id="transform.Mappable">
  <a href="#transform.Mappable">Mappable</a> <span class="kind">interface</span></h4>
<p data-en="There are several things that positions can be mapped through.
Such objects conform to this interface." lang="cn">位置可以被好几个对象 map，这类对象都符合该接口。</p>
<dl><dt id="transform.Mappable.map"><code><strong><a href="#transform.Mappable.map">map</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">assoc:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Map a position through this object. When given, assoc (should
be -1 or 1, defaults to 1) determines with which side the
position is associated, which determines in which direction to
move when a chunk of content is inserted at the mapped position." lang="cn">通过该对象 map 一个位置。如果给定该方法，则 <code>assoc</code>（应该是 -1 或者 1，默认是 1）
决定位置与哪一侧有关，这决定了当一块内容被插入到被 map 的位置的时候，该位置应该往哪个方向移动。</p>
</dd><dt id="transform.Mappable.mapResult"><code><strong><a href="#transform.Mappable.mapResult">mapResult</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">assoc:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#transform.MapResult"><span class="type">MapResult</span></a></code></dt>

<dd>
<p data-en="Map a position, and return an object containing additional
information about the mapping. The result's deleted field tells
you whether the position was deleted (completely enclosed in a
replaced range) during the mapping. When content on only one side
is deleted, the position itself is only considered deleted when
assoc points in the direction of the deleted content." lang="cn">map 一个位置，然后返回一个包含关于这个 mapping 附加信息的对象。结果的 <code>deleted</code> 字段会告诉你该位置在 map 期间是否被删除（在一个 replace 的
range 中完全闭合的位置，即两侧都删除），如果只有一侧被删除，则只有当 <code>assoc</code> 指向删除一侧的时候，这个位置才会被认为是删除了。</p>
</dd></dl>
<h4 id="transform.MapResult">
  <a href="#transform.MapResult">MapResult</a> <span class="kind">class</span></h4>
<p data-en="An object representing a mapped position with extra
information." lang="cn">一个带有额外信息的表示一个 map 过的位置的对象。</p>
<dl><dt id="transform.MapResult.pos"><code><strong><a href="#transform.MapResult.pos">pos</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The mapped version of the position." lang="cn">该位置 map 过的版本。</p>
</dd><dt id="transform.MapResult.deleted"><code><strong><a href="#transform.MapResult.deleted">deleted</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Tells you whether the position was deleted, that is,
whether the step removed its surroundings from the document." lang="cn">告诉你该位置是否被删除了，也就是说，是否有 step 从文档中将该位置两侧（周围）的内容删除了。</p>
</dd></dl>
<h4 id="transform.StepMap">
  <a href="#transform.StepMap">StepMap</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#transform.Mappable"><span class="type">Mappable</span></a></code></span></h4>
<p data-en="A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version." lang="cn">一个 map 描述了由 step 产生的删除和插入操作，这可以用来找到应用 step 之前文档的位置和应用 step 之后文档的相同位置之间的对应关系。</p>
<dl><dt id="transform.StepMap.constructor"><code>new <strong><a href="#transform.StepMap.constructor">StepMap</a></strong>(<span class="param">ranges:</span>&nbsp;[<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>])</code></dt>

<dd>
<p data-en="Create a position map. The modifications to the document are
represented as an array of numbers, in which each group of three
represents a modified chunk as [start, oldSize, newSize]." lang="cn">新建一个位置 map。对文档的修改被表示为一个数字数组，在数组中每三个值表示一个修改区域，即 <code>[开始，旧大小，新大小]</code>。</p>
</dd><dt id="transform.StepMap.forEach"><code><strong><a href="#transform.StepMap.forEach">forEach</a></strong>(<span class="param">f:</span>&nbsp;<span class="fn">fn</span>(<span class="param">oldStart:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">oldEnd:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">newStart:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">newEnd:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>))</code></dt>

<dd>
<p data-en="Calls the given function on each of the changed ranges included in
this map." lang="cn">对该 map 中的每一个修改的 range 调用给定的函数。</p>
</dd><dt id="transform.StepMap.invert"><code><strong><a href="#transform.StepMap.invert">invert</a></strong>() →&nbsp;<a href="#transform.StepMap"><span class="type">StepMap</span></a></code></dt>

<dd>
<p data-en="Create an inverted version of this map. The result can be used to
map positions in the post-step document to the pre-step document." lang="cn">新建一个该 map 的反转版本。函数返回的结果可以被用来将 step 修改后的文档位置 map 回 step 修改前的文档位置。</p>
</dd><dt id="transform.StepMap^offset"><code>static <strong><a href="#transform.StepMap^offset">offset</a></strong>(<span class="param">n:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="#transform.StepMap"><span class="type">StepMap</span></a></code></dt>

<dd>
<p data-en="Create a map that moves all positions by offset n (which may be
negative). This can be useful when applying steps meant for a
sub-document to a larger document, or vice-versa." lang="cn">新建一个将所有位置偏移 <code>n</code> （n 可能为负数）的一个 map。当将一个子文档的 step 应用于一个较大文档的时候，这可能会很有用，反之亦然。</p>
</dd></dl>
<h4 id="transform.Mapping">
  <a href="#transform.Mapping">Mapping</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#transform.Mappable"><span class="type">Mappable</span></a></code></span></h4>
<p data-en="A mapping represents a pipeline of zero or more step
maps. It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
‘rebasing’ steps for
collaboration or history management.)" lang="cn">一个 mapping 表示 0 个或者更多个 <a href="#transform.StepMap">step maps</a> 的管道。为了能够无损的处理通过一系列 step 而产生的位置 mapping，
其中一些 steps 很有可能是之前 step 的反转版本（这可能出现在为了协同编辑或者历史管理而 ‘<a href="/docs/guide/#transform.rebasing">rebasing</a>’ step 的时候）因此有一些特殊的规定需要遵守。</p>
<dl><dt id="transform.Mapping.constructor"><code>new <strong><a href="#transform.Mapping.constructor">Mapping</a></strong>(<span class="param">maps:</span>&nbsp;?⁠[<a href="#transform.StepMap"><span class="type">StepMap</span></a>])</code></dt>

<dd>
<p data-en="Create a new mapping with the given position maps." lang="cn">用给定的位置 maps 新建一个 mapping。</p>
</dd><dt id="transform.Mapping.maps"><code><strong><a href="#transform.Mapping.maps">maps</a></strong>: [<a href="#transform.StepMap"><span class="type">StepMap</span></a>]</code></dt>

<dd>
<p data-en="The step maps in this mapping." lang="cn">在当前 mapping 中的 step maps。</p>
</dd><dt id="transform.Mapping.from"><code><strong><a href="#transform.Mapping.from">from</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The starting position in the maps array, used when map or
mapResult is called." lang="cn">在 <code>maps</code> 数组中的起始位置，当 <code>map</code> 或者 <code>mapResult</code> 调用的时候会被使用。</p>
</dd><dt id="transform.Mapping.to"><code><strong><a href="#transform.Mapping.to">to</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The end position in the maps array." lang="cn"><code>maps</code> 位置的结束位置。</p>
</dd><dt id="transform.Mapping.slice"><code><strong><a href="#transform.Mapping.slice">slice</a></strong>(<span class="param">from:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 0</span>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = this.maps.length</span>) →&nbsp;<a href="#transform.Mapping"><span class="type">Mapping</span></a></code></dt>

<dd>
<p data-en="Create a mapping that maps only through a part of this one." lang="cn">新建一个 mapping，其只 map 当前 mapping 的一部分。</p>
</dd><dt id="transform.Mapping.appendMap"><code><strong><a href="#transform.Mapping.appendMap">appendMap</a></strong>(<span class="param">map:</span>&nbsp;<a href="#transform.StepMap"><span class="type">StepMap</span></a>, <span class="param">mirrors:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>)</code></dt>

<dd>
<p data-en="Add a step map to the end of this mapping. If mirrors is
given, it should be the index of the step map that is the mirror
image of this one." lang="cn">添加一个 step map 到当前 mapping 的末尾。如果设置了 <code>mirrors</code> 参数，则它应该是 step map 的索引，即第一个参数 step map 的镜像。</p>
</dd><dt id="transform.Mapping.appendMapping"><code><strong><a href="#transform.Mapping.appendMapping">appendMapping</a></strong>(<span class="param">mapping:</span>&nbsp;<a href="#transform.Mapping"><span class="type">Mapping</span></a>)</code></dt>

<dd>
<p data-en="Add all the step maps in a given mapping to this one (preserving
mirroring information)." lang="cn">将给定 mapping 的所有 maps 添加到当前 mapping（保留镜像信息）。</p>
</dd><dt id="transform.Mapping.getMirror"><code><strong><a href="#transform.Mapping.getMirror">getMirror</a></strong>(<span class="param">n:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Finds the offset of the step map that mirrors the map at the
given offset, in this mapping (as per the second argument to
appendMap)." lang="cn">寻找给定偏移量位置的 map 的镜像 step map 的偏移量。</p>
</dd><dt id="transform.Mapping.appendMappingInverted"><code><strong><a href="#transform.Mapping.appendMappingInverted">appendMappingInverted</a></strong>(<span class="param">mapping:</span>&nbsp;<a href="#transform.Mapping"><span class="type">Mapping</span></a>)</code></dt>

<dd>
<p data-en="Append the inverse of the given mapping to this one." lang="cn">将给定 mapping 的相反顺序的 mapping 附加到当前 mapping 上。</p>
</dd><dt id="transform.Mapping.invert"><code><strong><a href="#transform.Mapping.invert">invert</a></strong>() →&nbsp;<a href="#transform.Mapping"><span class="type">Mapping</span></a></code></dt>

<dd>
<p data-en="Create an inverted version of this mapping." lang="cn">新建一个当前 mapping 包含相反 map 顺序的版本。</p>
</dd></dl>
<h3 id="transform.Document_transforms"><a href="#transform.Document_transforms">Document transforms</a></h3>

<p data-en="Because you often need to collect a number of steps together to effect
a composite change, ProseMirror provides an abstraction to make this
easy. State transactions are a subclass of
transforms." lang="cn">由于你可能经常需要通过将一系列的 steps 合并到一起来修改文档，ProseMirror 提供了一个抽象来使这个过程简单化。
<a href="#state.Transaction">State transactions</a> 就是这个抽象，它是 transforms 的子类。</p>
<p type="comment"><span>注: </span>transaction 通常被简写为 tr。</p>
<h4 id="transform.Transform">
  <a href="#transform.Transform">Transform</a> <span class="kind">class</span></h4>
<p data-en="Abstraction to build up and track an array of
steps representing a document transformation." lang="cn">为了构建和跟踪文档 transformation 的一系列 steps 的抽象。</p>

<p data-en="Most transforming methods return the Transform object itself, so
that they can be chained." lang="cn">大多数的 transforming 方法返回 <code>Transform</code> 对象本身，因此它们可以链式调用。</p>
<dl><dt id="transform.Transform.constructor"><code>new <strong><a href="#transform.Transform.constructor">Transform</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>)</code></dt>

<dd>
<p data-en="Create a transform that starts with the given document." lang="cn">新建一个起始于给定文档的 transform。</p>
</dd><dt id="transform.Transform.doc"><code><strong><a href="#transform.Transform.doc">doc</a></strong>: <a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The current document (the result of applying the steps in the
transform)." lang="cn">当前文档（即应用了 transform 中 steps 后的结果）。</p>
</dd><dt id="transform.Transform.steps"><code><strong><a href="#transform.Transform.steps">steps</a></strong>: [<a href="#transform.Step"><span class="type">Step</span></a>]</code></dt>

<dd>
<p data-en="The steps in this transform." lang="cn">transform 中的 steps 们。</p>
</dd><dt id="transform.Transform.docs"><code><strong><a href="#transform.Transform.docs">docs</a></strong>: [<a href="#model.Node"><span class="type">Node</span></a>]</code></dt>

<dd>
<p data-en="The documents before each of the steps." lang="cn">在每个 steps 开始之前的文档们。</p>
</dd><dt id="transform.Transform.mapping"><code><strong><a href="#transform.Transform.mapping">mapping</a></strong>: <a href="#transform.Mapping"><span class="type">Mapping</span></a></code></dt>

<dd>
<p data-en="A mapping with the maps for each of the steps in this transform." lang="cn">一个 maps 了 transform 中的每一个 steps 的 mapping。</p>
</dd><dt id="transform.Transform.before"><code><strong><a href="#transform.Transform.before">before</a></strong>: <a href="#model.Node"><span class="type">Node</span></a></code></dt>

<dd>
<p data-en="The starting document." lang="cn">起始文档。</p>
</dd><dt id="transform.Transform.step"><code><strong><a href="#transform.Transform.step">step</a></strong>(<span class="param">step:</span>&nbsp;<a href="#transform.Step"><span class="type">Step</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Apply a new step in this transform, saving the result. Throws an
error when the step fails." lang="cn">对当前 transform 应用一个新的 step，然后保存结果。如果应用失败则抛出一个错误。</p>
<p type="comment"><span>注: </span>错误的类叫做「TransformError」。</p>
</dd><dt id="transform.Transform.maybeStep"><code><strong><a href="#transform.Transform.maybeStep">maybeStep</a></strong>(<span class="param">step:</span>&nbsp;<a href="#transform.Step"><span class="type">Step</span></a>) →&nbsp;<a href="#transform.StepResult"><span class="type">StepResult</span></a></code></dt>

<dd>
<p data-en="Try to apply a step in this transformation, ignoring it if it
fails. Returns the step result." lang="cn">尝试在当前 transformation 中应用一个 step，如果失败则忽略，否则返回 step result。</p>
</dd><dt id="transform.Transform.docChanged"><code><strong><a href="#transform.Transform.docChanged">docChanged</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="True when the document has been changed (when there are any
steps)." lang="cn">如果文档被改变过（当有任何 step 的时候），则返回 true。</p>
</dd><dt id="transform.Transform.addMark"><code><strong><a href="#transform.Transform.addMark">addMark</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">mark:</span>&nbsp;<a href="#model.Mark"><span class="type">Mark</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Add the given mark to the inline content between from and to." lang="cn">将给定的 mark 添加到 <code>from</code> 到 <code>to</code> 之间的内联节点中。</p>
</dd><dt id="transform.Transform.removeMark"><code><strong><a href="#transform.Transform.removeMark">removeMark</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">mark:</span>&nbsp;?⁠<a href="#model.Mark"><span class="type">Mark</span></a> | <a href="#model.MarkType"><span class="type">MarkType</span></a><span class="defaultvalue"> = null</span>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Remove marks from inline nodes between from and to. When mark
is a single mark, remove precisely that mark. When it is a mark type,
remove all marks of that type. When it is null, remove all marks of
any type." lang="cn">将 <code>from</code> 到 <code>to</code> 之间的内联节点上给定的的 mark 移除。当 <code>mark</code> 是一个单独的 mark 时，则精确移除这个 mark。
如果是一个 mark 类型时，则移除所有的该类型的 mark。如果是 null，移除其内所有类型的 mark。</p>
</dd><dt id="transform.Transform.clearIncompatible"><code><strong><a href="#transform.Transform.clearIncompatible">clearIncompatible</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">parentType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">match:</span>&nbsp;?⁠<a href="#model.ContentMatch"><span class="type">ContentMatch</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Removes all marks and nodes from the content of the node at pos
that don't match the given new parent node type. Accepts an
optional starting content match as third
argument." lang="cn">从给定的 pos 移除与给定的新的父级节点类型不兼容的所有 marks 和节点们。
接受一个可选的起始 <a href="#model.ContentMatch">content match</a> 作为第三个参数。</p>
</dd><dt id="transform.Transform.replace"><code><strong><a href="#transform.Transform.replace">replace</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = from</span>, <span class="param">slice:</span>&nbsp;?⁠<a href="#model.Slice"><span class="type">Slice</span></a><span class="defaultvalue"> = Slice.empty</span>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Replace the part of the document between from and to with the
given slice." lang="cn">用给定的 <code>slice</code> 替换在 <code>from</code> 和 <code>to</code> 之间的这部分文档。</p>
</dd><dt id="transform.Transform.replaceWith"><code><strong><a href="#transform.Transform.replaceWith">replaceWith</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">content:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a> | <a href="#model.Node"><span class="type">Node</span></a> | [<a href="#model.Node"><span class="type">Node</span></a>]) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Replace the given range with the given content, which may be a
fragment, node, or array of nodes." lang="cn">用给定的内容替换给定过的 range，该内容可能是一个 fragment、节点、或者节点数组。</p>
</dd><dt id="transform.Transform.delete"><code><strong><a href="#transform.Transform.delete">delete</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Delete the content between the given positions." lang="cn">删除给定位置之间的内容。</p>
</dd><dt id="transform.Transform.insert"><code><strong><a href="#transform.Transform.insert">insert</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">content:</span>&nbsp;<a href="#model.Fragment"><span class="type">Fragment</span></a> | <a href="#model.Node"><span class="type">Node</span></a> | [<a href="#model.Node"><span class="type">Node</span></a>]) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Insert the given content at the given position." lang="cn">在给定的位置插入给定的内容。</p>
</dd><dt id="transform.Transform.replaceRange"><code><strong><a href="#transform.Transform.replaceRange">replaceRange</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Replace a range of the document with a given slice, using from,
to, and the slice's openStart property
as hints, rather than fixed start and end points. This method may
grow the replaced area or close open nodes in the slice in order to
get a fit that is more in line with WYSIWYG expectations, by
dropping fully covered parent nodes of the replaced region when
they are marked non-defining, or
including an open parent node from the slice that is marked as
defining." lang="cn">用给定的 slice 替换文档的一个 range，用 <code>from</code>、<code>to</code> 以及 slice 的 <a href="#model.Slice.openStart"><code>openStart</code></a> 属性
作为参照，而不是固定的起始和结束点。这个方法可能会使要替换的范围变大，或者会关闭在 slice 中开放的节点以更符合所谓 「WYSIWYG」的预期，
如果父级节点配置对象是 <a href="#model.NodeSpec.defining">non-defining</a> 的，则替换内容会完全覆盖被替换区域，
如果是 <a href="#model.NodeSpec.defining">defining</a> 的，则会包含一个来自于 slice 的打开的父级节点。</p>
<p>This is the method, for example, to handle paste. The similar
<a href="#transform.Transform.replace"><code>replace</code></a> method is a more
primitive tool which will <em>not</em> move the start and end of its given
range, and is useful in situations where you need more precise
control over what happens.</p>
</dd><dt id="transform.Transform.replaceRangeWith"><code><strong><a href="#transform.Transform.replaceRangeWith">replaceRangeWith</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">node:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Replace the given range with a node, but use from and to as
hints, rather than precise positions. When from and to are the same
and are at the start or end of a parent node in which the given
node doesn't fit, this method may move them out towards a parent
that does allow the given node to be placed. When the given range
completely covers a parent node, this method may completely replace
that parent node." lang="cn">用给定的 node 替换一个由给定 <code>from</code> 和 <code>to</code> 模糊确定的 range，而不是一个精确的位置。
如果当 from 和 to 相同且都位于父级节点的起始或者结尾位置，而给定的 node 并不适合此位置的时候，该方法可能将 from 和 to 的范围 <em>扩大</em> 到
超出父级节点以允许给定的 node 被放置，如果给定的 range（from 和 to 形成的）完全覆盖了一个父级节点，则该方法可能完全替换掉这个父级节点。</p>
</dd><dt id="transform.Transform.deleteRange"><code><strong><a href="#transform.Transform.deleteRange">deleteRange</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Delete the given range, expanding it to cover fully covered
parent nodes until a valid replace is found." lang="cn">删除给定的 range，会将该 range 扩大到完全覆盖父级节点，直到找到一个有效的替换为止。</p>
<p type="comment"><span>注: </span>有些 range 两侧在不同深度的节点中，因此会先将二者的值扩展到与二者中深度与较小的那个保持一致以形成完全覆盖一个父级节点的 range。</p>
</dd><dt id="transform.Transform.lift"><code><strong><a href="#transform.Transform.lift">lift</a></strong>(<span class="param">range:</span>&nbsp;<a href="#model.NodeRange"><span class="type">NodeRange</span></a>, <span class="param">target:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Split the content in the given range off from its parent, if there
is sibling content before or after it, and move it up the tree to
the depth specified by target. You'll probably want to use
liftTarget to compute target, to make
sure the lift is valid." lang="cn">如果 range 内容前后有同级内容，则会将给定 range 从其父级节点中分割，然后将其沿树移动到由 <code>target</code>
指定的深度。你可能想要使用 <a href="#transform.liftTarget"><code>liftTarget</code></a> 来计算 <code>target</code>，以保证这个沿着树的提升是有效的。</p>
</dd><dt id="transform.Transform.wrap"><code><strong><a href="#transform.Transform.wrap">wrap</a></strong>(<span class="param">range:</span>&nbsp;<a href="#model.NodeRange"><span class="type">NodeRange</span></a>, <span class="param">wrappers:</span>&nbsp;[{<span class="prop">type:&nbsp;</span><a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="prop">attrs:&nbsp;</span>?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>}]) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Wrap the given range in the given set of wrappers.
The wrappers are assumed to be valid in this position, and should
probably be computed with findWrapping." lang="cn">用规定的包裹节点集合来包裹给定的 <a href="#model.NodeRange">range</a>。包裹节点们会被假定是适合当前位置的，其应该被 <a href="#transform.findWrapping"><code>findWrapping</code></a>
方法合适的计算出来。</p>
</dd><dt id="transform.Transform.setBlockType"><code><strong><a href="#transform.Transform.setBlockType">setBlockType</a></strong>(<span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = from</span>, <span class="param">type:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Set the type of all textblocks (partly) between from and to to
the given node type with the given attributes." lang="cn">将介于 <code>from</code> 和 <code>to</code> 之间的所有的文本块（部分地）设置成带有给定 attributes 的给定的节点类型。</p>
<p type="comment"><span>注: </span>为什么是「部分的」是因为有些文本块或许不能被改变类型。</p>
</dd><dt id="transform.Transform.setNodeMarkup"><code><strong><a href="#transform.Transform.setNodeMarkup">setNodeMarkup</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">type:</span>&nbsp;?⁠<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">marks:</span>&nbsp;?⁠[<a href="#model.Mark"><span class="type">Mark</span></a>]) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Change the type, attributes, and/or marks of the node at pos.
When type isn't given, the existing node type is preserved," lang="cn">在给定的 <code>pos</code> 处改变节点的类型、attributes、或者/和 marks。如果 <code>type</code> 没有给，则保留当前节点的类型。</p>
</dd><dt id="transform.Transform.split"><code><strong><a href="#transform.Transform.split">split</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 1</span>, <span class="param">typesAfter:</span>&nbsp;?⁠[?⁠{<span class="prop">type:&nbsp;</span><a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="prop">attrs:&nbsp;</span>?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>}]) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Split the node at the given position, and optionally, if depth is
greater than one, any number of nodes above that. By default, the
parts split off will inherit the node type of the original node.
This can be changed by passing an array of types and attributes to
use after the split." lang="cn">分割给定位置的节点，如果传入了 <code>depth</code> 参数，且其大于 1，则任何数量的节点在它之上（？？？）。
默认情况下，被分割部分的节点类型将会继承原始的节点类型，但是也可以通过传入一个类型数组和 attributes 来在分割后设置其上。</p>
<p type="comment"><span>注: </span>这句英文原文也不通顺。</p>
</dd><dt id="transform.Transform.join"><code><strong><a href="#transform.Transform.join">join</a></strong>(<span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 1</span>) →&nbsp;<span class="prim">this</span></code></dt>

<dd>
<p data-en="Join the blocks around the given position. If depth is 2, their
last and first siblings are also joined, and so on." lang="cn">将给定位置周围的块级元素连接起来。如果深度是 2，它们最后和第一个同级节点也会被连接，以此类推。</p>
</dd></dl>

<p data-en="The following helper functions can be useful when creating
transformations or determining whether they are even possible." lang="cn">当新建一个 transform 或者决定能否新建一个 transform 的时候，下面几个工具函数非常有用。</p>
<dt id="transform.replaceStep"><code><strong><a href="#transform.replaceStep">replaceStep</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">from:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">to:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = from</span>, <span class="param">slice:</span>&nbsp;?⁠<a href="#model.Slice"><span class="type">Slice</span></a><span class="defaultvalue"> = Slice.empty</span>) →&nbsp;?⁠<a href="#transform.Step"><span class="type">Step</span></a></code></dt>

<dd>
<p data-en="‘Fit’ a slice into a given position in the document, producing a
step that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range)." lang="cn">将一个 slice 「恰当的」放到文档中给定的位置，会生成一个进行插入操作的 step。如果没有一个有意义的途径来插入该 slice，或者插入的 slice
没有意义（比如一个空的 slice 带着空的 range）则返回 null。</p>
</dd>
<dt id="transform.liftTarget"><code><strong><a href="#transform.liftTarget">liftTarget</a></strong>(<span class="param">range:</span>&nbsp;<a href="#model.NodeRange"><span class="type">NodeRange</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Try to find a target depth to which the content in the given range
can be lifted. Will not go across
isolating parent nodes." lang="cn">尝试寻找一个目标深度以让给定的 range 内的内容可以被提升（深度）。不会考虑有属性 <a href="#model.NodeSpec.isolating">isolating</a>
存在的父级节点。</p>
</dd>
<dt id="transform.findWrapping"><code><strong><a href="#transform.findWrapping">findWrapping</a></strong>(<span class="param">range:</span>&nbsp;<a href="#model.NodeRange"><span class="type">NodeRange</span></a>, <span class="param">nodeType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">innerRange:</span>&nbsp;?⁠<a href="#model.NodeRange"><span class="type">NodeRange</span></a><span class="defaultvalue"> = range</span>) →&nbsp;?⁠[{<span class="prop">type:&nbsp;</span><a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="prop">attrs:&nbsp;</span>?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>}]</code></dt>

<dd>
<p data-en="Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When innerRange is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of range." lang="cn">尝试找到一个有效的方式来用给定的节点类型包裹给定 range 的内容。如果必要的话，可能会在包裹节点的内部和周围生成额外的节点。
如果没有可用的包裹方式则返回 null。当 <code>innerRange</code> 给定的时候，该 range 的内容将会被作为被包裹的内容，而不是 <code>range</code> 的内容。</p>
<p type="comment"><span>注: </span>需要研究一下 range 和 innerRange 的区别，若 range 包含多个同级节点和 range 只含有一个节点是否有区别？</p>
</dd>
<dt id="transform.canSplit"><code><strong><a href="#transform.canSplit">canSplit</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">depth:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = 1</span>, <span class="param">typesAfter:</span>&nbsp;?⁠[?⁠{<span class="prop">type:&nbsp;</span><a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="prop">attrs:&nbsp;</span>?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>}]) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Check whether splitting at the given position is allowed." lang="cn">检查给定的位置是否允许分割。</p>
</dd>
<dt id="transform.canJoin"><code><strong><a href="#transform.canJoin">canJoin</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Test whether the blocks before and after a given position can be
joined." lang="cn">测试在给定位置之前或者之后的块级节点是否可以被连接起来。</p>
</dd>
<dt id="transform.joinPoint"><code><strong><a href="#transform.joinPoint">joinPoint</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">dir:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a><span class="defaultvalue"> = -1</span>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Find an ancestor of the given position that can be joined to the
block before (or after if dir is positive). Returns the joinable
point, if any." lang="cn">寻找一个给定位置的祖先节点，该节点可以被连接到块级节点之前（或者之后，如果 <code>dir</code> 是正的话）。
如果找到，返回这个可加入的位置。</p>
</dd>
<dt id="transform.insertPoint"><code><strong><a href="#transform.insertPoint">insertPoint</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">nodeType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Try to find a point where a node of the given type can be inserted
near pos, by searching up the node hierarchy when pos itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found." lang="cn">当 <code>pos</code> 本身不是有效的位置但位于节点的起始或结尾处时，通过搜索节点的层级结构，尝试找到一个可以在给定位置的节点附近插入给定节点类型的点。
如果找不到位置，则返回 null。</p>
</dd>
<dt id="transform.dropPoint"><code><strong><a href="#transform.dropPoint">dropPoint</a></strong>(<span class="param">doc:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">pos:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">slice:</span>&nbsp;<a href="#model.Slice"><span class="type">Slice</span></a>) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found." lang="cn">寻找一个位置在给定的位置或者附近，以让给定的 slice能够插入。即使原始的位置并不直接在父级节点的起始或者结束位置，
也会尝试查看父级节点最近的边界然后尝试插入。如果找不到位置，则返回 null。</p>
</dd>
</section><section id=part_commands>
    <h2 class=module id=commands>
      <a href="#commands">prosemirror-commands <span class=kind>module</span></a>
    </h2>
<p data-en="This module exports a number of commands, which are building block
functions that encapsulate an editing action. A command function takes
an editor state, optionally a dispatch function that it can use
to dispatch a transaction and optionally an EditorView instance.
It should return a boolean that indicates whether it could perform any
action. When no dispatch callback is passed, the command should do a
'dry run', determining whether it is applicable, but not actually doing
anything." lang="cn">本模块导出了一些 <em>命令</em>，它可以构建块级函数以封装一个编辑行为。一个命令函数接受一个编辑器的 state，
一个 <em>可选的</em> <code>dispatch</code> 函数，用来 dispatch 一个 transaction，及一个 <em>可选的</em> <code>EditorView</code>
实例作为参数。它应该返回一个布尔值以指示它是否可以执行任何行为。当没有 <code>dispatch</code> 回调被传入的时候，
该命令应该做一个 <code>空运行</code>，以决定它是否应该被运行，而不实际做任何事情。</p>

<p data-en="These are mostly used to bind keys and define menu items." lang="cn">这些命令大多数用来绑定按键以及定义菜单项。</p>
<dt id="commands.chainCommands"><code><strong><a href="#commands.chainCommands">chainCommands</a></strong>(...<span class="param">commands:</span>&nbsp;[<span class="fn">fn</span>(<a href="#state.EditorState"><span class="type">EditorState</span></a>, ?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>), ?⁠<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>]) →&nbsp;<span class="fn">fn</span>(<a href="#state.EditorState"><span class="type">EditorState</span></a>, ?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>), ?⁠<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Combine a number of command functions into a single function (which
calls them one by one until one returns true)." lang="cn">组合多个命令函数到一个单独的函数（一个一个的调用这些命令，直到其中一个返回 true）。</p>
</dd>
<dt id="commands.deleteSelection"><code><strong><a href="#commands.deleteSelection">deleteSelection</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Delete the selection, if there is one." lang="cn">删除选区，如果存在的话。</p>
</dd>
<dt id="commands.joinBackward"><code><strong><a href="#commands.joinBackward">joinBackward</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>), <span class="param">view:</span>&nbsp;?⁠<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before it—if
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given." lang="cn">如果选区是空（光标）而且在一个文本块的起始位置，则试着减少光标所在的块级节点和该块级节点之前的节点之间的距离。如果存在一个块级节点直接位于
光标所在的块级节点之前而且能够被连接的话，则连接他们。如果不存在，则尝试通过将光标所在的块级节点从其父级节点中提升一级或者将其移动到父级节点之前的
块级节点中的方式来尝试将选择的块级节点（即光标所在的块级及诶单）移动的更接近文档中的下一个节点。如果给定 view 参数，则将会使用之以获取准确的（用来处理 bidi 的）文本块起始方向。</p>
</dd>
<dt id="commands.selectNodeBackward"><code><strong><a href="#commands.selectNodeBackward">selectNodeBackward</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>), <span class="param">view:</span>&nbsp;?⁠<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
joinBackward or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point." lang="cn">当选区是空且在一个文本块的起始位置的时候，如果可以的话，选中位于文本块之前的节点。这个行为通常倾向于在 <a href="#commands.joinBackward"><code>joinBackward</code></a>
之后绑定向后删除键或者其他删除命令，以作为一个回退方案，如果 schema 不允许在选择的点进行删除操作的话。</p>
<p type="comment"><span>注: </span>向后删除键在 Mac 上是 Ctrl + D，会删除光标右侧的内容。</p>
</dd>
<dt id="commands.joinForward"><code><strong><a href="#commands.joinForward">joinForward</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>), <span class="param">view:</span>&nbsp;?⁠<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given." lang="cn">如果选区是空而且光标在一个文本块的结尾处，则尝试减少或者移除当前块级元素和它之后的块级元素之间边界。可以通过连接他们或者在树中移动挨着当前块级元素的
其他块级元素。将会使用给定的 view（如果有）以获取准确的文本块起始方向。</p>
</dd>
<dt id="commands.selectNodeForward"><code><strong><a href="#commands.selectNodeForward">selectNodeForward</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>), <span class="param">view:</span>&nbsp;?⁠<a href="#view.EditorView"><span class="type">EditorView</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
joinForward and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point." lang="cn">当选区是空且在一个文本块的结尾位置的时候，如果可以的话，选中位于文本块之后的节点。这个行为通常倾向于在 <a href="#commands.joinForward"><code>joinForward</code></a>
之后绑定删除键或者其他类似的删除命令，以作为一个回退方案，如果 schema 不允许在选择的点进行删除操作的话。</p>
</dd>
<dt id="commands.joinUp"><code><strong><a href="#commands.joinUp">joinUp</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Join the selected block or, if there is a text selection, the
closest ancestor block of the selection that can be joined, with
the sibling above it." lang="cn">连接选择的块级节点，或者如果有文本选区，则连接与选区最接近的可连接的祖先节点和它之前的同级节点。</p>
</dd>
<dt id="commands.joinDown"><code><strong><a href="#commands.joinDown">joinDown</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Join the selected block, or the closest ancestor of the selection
that can be joined, with the sibling after it." lang="cn">连接选择的块级节点，或者连接与选区最接近的可连接的祖先节点和它之后的同级节点。</p>
</dd>
<dt id="commands.lift"><code><strong><a href="#commands.lift">lift</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Lift the selected block, or the closest ancestor block of the
selection that can be lifted, out of its parent node." lang="cn">从父级节点中提升选择的块级节点，或者提升与选区最接近的可提升的祖先节点。</p>
</dd>
<dt id="commands.newlineInCode"><code><strong><a href="#commands.newlineInCode">newlineInCode</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="If the selection is in a node whose type has a truthy
code property in its spec, replace the
selection with a newline character." lang="cn">如果选区在一个配置对象中 <a href="#model.NodeSpec.code"><code>code</code></a> 属性为真值的节点类型中，则用一个换行符替换选区。</p>
</dd>
<dt id="commands.exitCode"><code><strong><a href="#commands.exitCode">exitCode</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="When the selection is in a node with a truthy
code property in its spec, create a
default block after the code block, and move the cursor there." lang="cn">如果选区在一个配置对象中 <a href="#model.NodeSpec.code"><code>code</code></a> 属性为真值的节点类型中，则在当前代码块之后新建一个默认的块级节点，
然后将光标移动到其内。</p>
</dd>
<dt id="commands.createParagraphNear"><code><strong><a href="#commands.createParagraphNear">createParagraphNear</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it." lang="cn">如果一个块级节点被选中，则在其前面（如果它是其父级节点的第一个子元素）新建一个段落，或者其后面。</p>
</dd>
<dt id="commands.liftEmptyBlock"><code><strong><a href="#commands.liftEmptyBlock">liftEmptyBlock</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="If the cursor is in an empty textblock that can be lifted, lift the
block." lang="cn">如果光标在一个空的可以被提升的文本块中，那么提升这个文本块。</p>
</dd>
<dt id="commands.splitBlock"><code><strong><a href="#commands.splitBlock">splitBlock</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Split the parent block of the selection. If the selection is a text
selection, also delete its content." lang="cn">分割选区的父级节点。如果选区是一个文本选区，还会同时删除选区内容。</p>
</dd>
<dt id="commands.splitBlockKeepMarks"><code><strong><a href="#commands.splitBlockKeepMarks">splitBlockKeepMarks</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Acts like splitBlock, but without
resetting the set of active marks at the cursor." lang="cn">行为和 <a href="#commands.splitBlock"><code>splitBlock</code></a> 类似，不过不会重置光标处已经激活的 marks 集合。</p>
</dd>
<dt id="commands.selectParentNode"><code><strong><a href="#commands.selectParentNode">selectParentNode</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Move the selection to the node wrapping the current selection, if
any. (Will not select the document node.)" lang="cn">移动选区到包裹当前选区的节点中（如果有的话，不会选择文档根节点）。</p>
</dd>
<dt id="commands.selectAll"><code><strong><a href="#commands.selectAll">selectAll</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Select the whole document." lang="cn">选择整个文档。</p>
</dd>
<dt id="commands.wrapIn"><code><strong><a href="#commands.wrapIn">wrapIn</a></strong>(<span class="param">nodeType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Wrap the selection in a node of the given type with the given
attributes." lang="cn">用带有给定 attributes 的给定类型的节点来包裹选区。</p>
</dd>
<dt id="commands.setBlockType"><code><strong><a href="#commands.setBlockType">setBlockType</a></strong>(<span class="param">nodeType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Returns a command that tries to set the selected textblocks to the
given node type with the given attributes." lang="cn">返回一个尝试将选中的文本块设置为带有给定 attributes 的给定节点类型的命令。</p>
</dd>
<dt id="commands.toggleMark"><code><strong><a href="#commands.toggleMark">toggleMark</a></strong>(<span class="param">markType:</span>&nbsp;<a href="#model.MarkType"><span class="type">MarkType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Create a command function that toggles the given mark with the
given attributes. Will return false when the current selection
doesn't support that mark. This will remove the mark if any marks
of that type exist in the selection, or add it otherwise. If the
selection is empty, this applies to the stored
marks instead of a range of the
document." lang="cn">新建一个命令函数，控制带有给定 attributes 的给定 mark 的开关。如果当前选区不支持这个的 mark 将会返回 <code>false</code>。
这个过程将会移除在选区中存在的任何该种类型的 mark，或者如果没有的话则添加之。如果选区是空，则这将会应用到 stored
marks](#state.EditorState.storedMarks) 中，而不是文档的某个范围。</p>
</dd>
<dt id="commands.autoJoin"><code><strong><a href="#commands.autoJoin">autoJoin</a></strong>(<span class="param">command:</span>&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, ?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>, <span class="param">isJoinable:</span>&nbsp;<span class="fn">fn</span>(<span class="param">before:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>, <span class="param">after:</span>&nbsp;<a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a> | [<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>]) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, ?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Wrap a command so that, when it produces a transform that causes
two joinable nodes to end up next to each other, those are joined.
Nodes are considered joinable when they are of the same type and
when the isJoinable predicate returns true for them or, if an
array of strings was passed, if their node type name is in that
array." lang="cn">封装一个命令，以便当它产生一个 transform 以引起两个可连接的节点彼此相邻时能够被连接。
当节点具有相同类型并且当 <code>isJoinable</code> 参数是函数时返回 true 或者参数是一个字符串数组而这些节点名在这个数组中时，节点将会被认为是可连接的。</p>
</dd>
<dt id="commands.baseKeymap"><code><strong><a href="#commands.baseKeymap">baseKeymap</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Depending on the detected platform, this will hold
pcBasekeymap or
macBaseKeymap." lang="cn">取决于删除操作的平台，该值将指向 <a href="#commands.pcBaseKeymap"><code>pcBasekeymap</code></a> 或者 <a href="#commands.macBaseKeymap"><code>macBaseKeymap</code></a>。</p>
</dd>
<dt id="commands.pcBaseKeymap"><code><strong><a href="#commands.pcBaseKeymap">pcBaseKeymap</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="A basic keymap containing bindings not specific to any schema.
Binds the following keys (when multiple commands are listed, they
are chained with chainCommands):" lang="cn">一个基本的按键映射，包含不特定于任何 schema 的按键绑定。绑定包含下列按键（当多个命令被列出来的时候，它们被 <a href="#commands.chainCommands"><code>chainCommands</code></a>
所链接起来）。</p>
<ul>

<li data-en="Enter to newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock" lang="cn"><strong>Enter</strong> 绑定到 <code>newlineInCode</code>, <code>createParagraphNear</code>, <code>liftEmptyBlock</code>, <code>splitBlock</code></li>

<li data-en="Mod-Enter to exitCode" lang="cn"><strong>Mod-Enter</strong> 绑定到 <code>exitCode</code></li>

<li data-en="Backspace and Mod-Backspace to deleteSelection, joinBackward, selectNodeBackward" lang="cn"><strong>Backspace</strong> 及 <strong>Mod-Backspace</strong> 绑定到 <code>deleteSelection</code>, <code>joinBackward</code>, <code>selectNodeBackward</code></li>

<li data-en="Delete and Mod-Delete to deleteSelection, joinForward, selectNodeForward" lang="cn"><strong>Delete</strong> 及 <strong>Mod-Delete</strong> 绑定到 <code>deleteSelection</code>, <code>joinForward</code>, <code>selectNodeForward</code></li>

<li data-en="Mod-Delete to deleteSelection, joinForward, selectNodeForward" lang="cn"><strong>Mod-Delete</strong> 绑定到 <code>deleteSelection</code>, <code>joinForward</code>, <code>selectNodeForward</code></li>

<li data-en="Mod-a to selectAll" lang="cn"><strong>Mod-a</strong> 绑定到 <code>selectAll</code></li>
</ul>
</dd>
<dt id="commands.macBaseKeymap"><code><strong><a href="#commands.macBaseKeymap">macBaseKeymap</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="A copy of pcBaseKeymap that also binds Ctrl-h like Backspace,
Ctrl-d like Delete, Alt-Backspace like Ctrl-Backspace, and
Ctrl-Alt-Backspace, Alt-Delete, and Alt-d like
Ctrl-Delete." lang="cn"><code>pcBaseKeymap</code> 的复制版，和 Backspace 一样绑定了 <strong>Ctrl-h</strong>，和 Delete 一样绑定了 <strong>Ctrl-d</strong>，
和 Ctrl-Backspace 一样绑定了 <strong>Alt-Backspace</strong>，和 Ctrl-Delete 一样绑定了 <strong>Ctrl-Alt-Backspace</strong>, <strong>Alt-Delete</strong>, 和 <strong>Alt-d</strong></p>
</dd>
</section><section id=part_history>
    <h2 class=module id=history>
      <a href="#history">prosemirror-history <span class=kind>module</span></a>
    </h2>
<p data-en="An implementation of an undo/redo history for ProseMirror. This
history is selective, meaning it does not just roll back to a
previous state but can undo some changes while keeping other, later
changes intact. (This is necessary for collaborative editing, and
comes up in other situations as well.)" lang="cn">一个 ProseMirror 的撤销/重做历史的实现。撤销/重做的历史是 <em>可选择的</em>，这意味着它不仅仅是回滚到
之前的 state，而是可以在撤销部分修改的同时保留其他的修改，或者原封不动的保留之后的修改（这对于协同编辑来说
是很有必要的，在其他一些情况下也可能会发生）。</p>
<dt id="history.history"><code><strong><a href="#history.history">history</a></strong>(<span class="param">config:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#state.Plugin"><span class="type">Plugin</span></a></code></dt>

<dd>
<p data-en="Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
undo and redo commands." lang="cn">返回一个插件以使编辑器撤销历史可用。该插件将会追踪撤销和重做的操作栈，这可以和 <a href="#history.undo"><code>撤销</code></a> and <a href="#history.redo"><code>重做</code></a>
命令一同使用。</p>

<p data-en="You can set an &quot;addToHistory&quot; metadata
property of false on a transaction
to prevent it from being rolled back by undo." lang="cn">你可以在一个 transaction 上设置一个 <code>"addToHistory"</code> 的 <a href="#state.Transaction.setMeta">metadata 属性</a> 为 <code>false</code>，来阻止该
tr 被撤销回滚。</p>
<p type="comment"><span>注: </span>设置了这个之后，该 tr 就相当于不会被加入到历史栈中。</p>
<dl><dt id="history.history^config"><code><strong><a href="#history.history^config">config</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Supports the following configuration options:" lang="cn">支持下列的参数可选：</p>
<dl><dt id="history.history^config.depth"><code><strong><a href="#history.history^config.depth">depth</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The amount of history events that are collected before the
oldest events are discarded. Defaults to 100." lang="cn">在最早的操作历史被丢弃之前，历史栈的最大长度，默认是 100。</p>
<p type="comment"><span>注: </span>超过了就先丢弃最早的操作记录。</p>
</dd><dl><dt id="history.history^config.newGroupDelay"><code><strong><a href="#history.history^config.newGroupDelay">newGroupDelay</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The delay between changes after which a new group should be
started. Defaults to 500 (milliseconds). Note that when changes
aren't adjacent, a new group is always started." lang="cn">操作从开始算起应该持续多久才会被算作一个操作。默认是 500（毫秒）。记住，如果多个修改不相邻的话，总是会被算作是新的操作。</p>
<p type="comment"><span>注: </span>如果该值被设置为 500，则在 500 毫秒内输入 10 个字，这样会触发 10 个 tr，但是会被归为一「组」，撤销的时候直接撤销这 10 个字的输入记录。
如果 500 毫秒内输入 20 个字同理撤销这 20 个字的记录。如果在 500 毫秒内输入了 10 个字，在 501 毫秒内输入了第 11 个字，则撤销的时候，那第 501 毫秒输入的第
11 个字被算做是一组，先撤销那 1 个字的输入，再撤销那 10 个字的输入。这个逻辑是为了和系统输入保持一致，各位可以试试在系统的某个界面如搜索框变换输入速度来输入内容后
撤销，看会发生什么。</p>
</dd></dl></dl></dd></dl></dd>
<dt id="history.undo"><code><strong><a href="#history.undo">undo</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="A command function that undoes the last change, if any." lang="cn">一个可以撤销最后修改（如果有）的命令函数。</p>
</dd>
<dt id="history.redo"><code><strong><a href="#history.redo">redo</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="A command function that redoes the last undone change, if any." lang="cn">一个可以重做最后一次撤销修改（如果有）的命令函数。</p>
</dd>
<dt id="history.undoDepth"><code><strong><a href="#history.undoDepth">undoDepth</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The amount of undoable events available in a given state." lang="cn">在给定的 state 中可以被撤销的操作的数量。</p>
</dd>
<dt id="history.redoDepth"><code><strong><a href="#history.redoDepth">redoDepth</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The amount of redoable events available in a given editor state." lang="cn">在给定的编辑器 state 中可以被重做的操作的数量。</p>
</dd>
<dt id="history.closeHistory"><code><strong><a href="#history.closeHistory">closeHistory</a></strong>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Set a flag on the given transaction that will prevent further steps
from being appended to an existing history event (so that they
require a separate undo command to undo)." lang="cn">在给定的 transaction 上设置一个标记，这将会阻止接下来的 steps 们被附加到一个已经存在的历史事件中（这样就需要一个单独的撤销命令来撤销了）。</p>
<p type="comment"><span>注: </span>这个函数不能顾名思义的以为不会会将 tr 加入到历史栈中。正确理解应该是其会将本来能够一个 tr n 个 steps 完成的修改，
变成了 两个 tr，n/2 个 step。因此需要额外的撤销命令来撤销修改。「close」表示紧急中断该 tr，然后将剩余的 steps 放到一个新的 tr 中。</p>
</dd>
</section><section id=part_collab>
    <h2 class=module id=collab>
      <a href="#collab">prosemirror-collab <span class=kind>module</span></a>
    </h2>
<p data-en="This module implements an API into which a communication channel for
collaborative editing can be hooked. See
the guide for more details and an example." lang="cn">这个模块实现了一个 API，该 API 可以供协同编辑使用。查看 <a href="/docs/guide/#collab">指南</a> 以获取更多细节和示例。</p>
<dt id="collab.collab"><code><strong><a href="#collab.collab">collab</a></strong>(<span class="param">config:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a><span class="defaultvalue"> = {}</span>) →&nbsp;<a href="#state.Plugin"><span class="type">Plugin</span></a></code></dt>

<dd>
<p data-en="Creates a plugin that enables the collaborative editing framework
for the editor." lang="cn">创建一个能使编辑器支持协同编辑框架的插件。</p>
<dl><dt id="collab.collab^config"><code><strong><a href="#collab.collab^config">config</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="An optional set of options" lang="cn">可选参数对象。</p>
<dl><dt id="collab.collab^config.version"><code><strong><a href="#collab.collab^config.version">version</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="The starting version number of the collaborative editing.
Defaults to 0." lang="cn">协同编辑的起始版本号，默认是 0.</p>
</dd><dl><dt id="collab.collab^config.clientID"><code><strong><a href="#collab.collab^config.clientID">clientID</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a></code></dt>

<dd>
<p data-en="This client's ID, used to distinguish its changes from those of
other clients. Defaults to a random 32-bit number." lang="cn">客户端 ID，用来分别哪些修改是自己做的哪些是其他客户端做的。默认是一个随机的 32 位数字。</p>
</dd></dl></dl></dd></dl></dd>
<dt id="collab.getVersion"><code><strong><a href="#collab.getVersion">getVersion</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a></code></dt>

<dd>
<p data-en="Get the version up to which the collab plugin has synced with the
central authority." lang="cn">获取 collab 插件与鉴权中心同步的版本。</p>
</dd>
<dt id="collab.receiveTransaction"><code><strong><a href="#collab.receiveTransaction">receiveTransaction</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">steps:</span>&nbsp;[<a href="#transform.Step"><span class="type">Step</span></a>], <span class="param">clientIDs:</span>&nbsp;[<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>], <span class="param">options:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a></code></dt>

<dd>
<p data-en="Create a transaction that represents a set of new steps received from
the authority. Applying this transaction moves the state forward to
adjust to the authority's view of the document." lang="cn">创建一个接受自鉴权中心的表示新 steps 集合的 transaction。应用该 transaction 以将 state 向前移动来适应文档的鉴权中心的视图。</p>
<p type="comment"><span>注: </span>「鉴权中心」指的就是协同处理的服务端，那里负责处理接受那些 tr，拒绝哪些 tr。</p>
<dl><dt id="collab.receiveTransaction^options"><code><strong><a href="#collab.receiveTransaction^options">options</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Additional options." lang="cn">可选的配置参数。</p>
<dl><dt id="collab.receiveTransaction^options.mapSelectionBackward"><code><strong><a href="#collab.receiveTransaction^options.mapSelectionBackward">mapSelectionBackward</a></strong>: ?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">boolean</span></a></code></dt>

<dd>
<p data-en="When enabled (the default is false), if the current selection
is a text selection, its sides are
mapped with a negative bias for this transaction, so that
content inserted at the cursor ends up after the cursor. Users
usually prefer this, but it isn't done by default for reasons
of backwards compatibility." lang="cn">启用后（默认是 <code>false</code>），如果当前选区是一个 <a href="#state.TextSelection">文本选区</a>，则它的两侧位置会被这个
transaction 通过一个负向偏移 mapped，以便使插入光标处的内容会以光标所在的位置结尾。用户通常倾向于这样做，不过因为向后兼容的
原因，默认情况下不会这么做。</p>
</dd></dl></dd></dl></dd>
<dt id="collab.sendableSteps"><code><strong><a href="#collab.sendableSteps">sendableSteps</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>) →&nbsp;?⁠{<span class="prop">version:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="prop">steps:&nbsp;</span>[<a href="#transform.Step"><span class="type">Step</span></a>], <span class="prop">clientID:&nbsp;</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="prop">origins:&nbsp;</span>[<a href="#state.Transaction"><span class="type">Transaction</span></a>]}</code></dt>

<dd>
<p data-en="Provides data describing the editor's unconfirmed steps, which need
to be sent to the central authority. Returns null when there is
nothing to send." lang="cn">提供编辑器未被确认的 steps 的数据描述，它会被发送给鉴权中心。如果没有需要发送的东西，返回 null。</p>

<p data-en="origins holds the original transactions that produced each
steps. This can be useful for looking up time stamps and other
metadata for the steps, but note that the steps may have been
rebased, whereas the origin transactions are still the old,
unchanged objects." lang="cn"><code>origins</code> 值是产生每个 steps 的 <em>原始</em> transactions。对于寻找 steps 的时间戳和其他 metadata 信息很有用，不过记住，steps 可能会被 rebased，
因此原始的 transaction 仍然是旧的，未改变的对象。</p>
</dd>
</section><section id=part_keymap>
    <h2 class=module id=keymap>
      <a href="#keymap">prosemirror-keymap <span class=kind>module</span></a>
    </h2>
<p data-en="A plugin for conveniently defining key bindings." lang="cn">一个为了方便的定义按键绑定的插件。</p>
<dt id="keymap.keymap"><code><strong><a href="#keymap.keymap">keymap</a></strong>(<span class="param">bindings:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#state.Plugin"><span class="type">Plugin</span></a></code></dt>

<dd>
<p data-en="Create a keymap plugin for the given set of bindings." lang="cn">用给定的绑定集合来创建一个按键映射插件。</p>

<p data-en="Bindings should map key names to command-style
functions, which will be called with (EditorState, dispatch, EditorView) arguments, and should return true when they've handled
the key. Note that the view argument isn't part of the command
protocol, but can be used as an escape hatch if a binding needs to
directly interact with the UI." lang="cn">绑定应该将按键名和 <a href="#commands">命令</a> 格式的函数对应起来，该函数将会传入 <code>(EditorState, dispatch, EditorView)</code> 作为参数来调用，如果它响应了该按键按下，则应该返回 true。记住，view 参数并不是命令协议的一部分，但是如果按键绑定需要直接与 UI
交互，则可以将其用来作为应急出口使用。</p>

<p data-en="Key names may be strings like &quot;Shift-Ctrl-Enter&quot;—a key
identifier prefixed with zero or more modifiers. Key identifiers
are based on the strings that can appear in
KeyEvent.key.
Use lowercase letters to refer to letter keys (or uppercase letters
if you want shift to be held). You may use &quot;Space&quot; as an alias
for the &quot; &quot; name." lang="cn">按键的名字可以是形如 <code>"Shift-Ctrl-Enter"</code> 的字符串，它是一个按键标识符，可以有 0 个或者多个修饰符做前缀。按键标识符的基础字符串基于这个
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key"><code>KeyEvent.key</code></a> 中的按键而来。使用小写字母来表示字母键
（或者使用大写字母，如果你想要处理 shift 被同时按下的情况）。你也许会使用 <code>"Space"</code> 作为 <code>" "</code> 的别名。</p>

<p data-en="Modifiers can be given in any order. Shift- (or s-), Alt- (or
a-), Ctrl- (or c- or Control-) and Cmd- (or m- or
Meta-) are recognized. For characters that are created by holding
shift, the Shift- prefix is implied, and should not be added
explicitly." lang="cn">修饰符可以以任何顺序给定。只允许 <code>Shift-</code>（或者 <code>s-</code>)，<code>Alt-</code>（或者 <code>a-</code>），<code>Ctrl-</code>（或 <code>c-</code> 或 <code>Control-</code>）及 <code>Cmd-</code>（或 <code>m-</code> 或 <code>Meta-</code>）
这些修饰符出现。对于通过按下 shift 创建的字符，则 <code>Shift-</code> 前缀就是隐式的，不应该再显式添加了。</p>

<p data-en="You can use Mod- as a shorthand for Cmd- on Mac and Ctrl- on
other platforms." lang="cn">在 Mac 上你可以使用 <code>Mod-</code> 作为 <code>Cmd-</code> 的简称，在其他平台可以使用 <code>Ctrl-</code>。</p>

<p data-en="You can add multiple keymap plugins to an editor. The order in
which they appear determines their precedence (the ones early in
the array get to dispatch first)." lang="cn">你可以在编辑器中添加多个按键映射插件。它们出现的顺序决定了它们的优先级（数组前面的优先被 dispatch）。</p>
</dd>
<dt id="keymap.keydownHandler"><code><strong><a href="#keymap.keydownHandler">keydownHandler</a></strong>(<span class="param">bindings:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">view:</span>&nbsp;<a href="#view.EditorView"><span class="type">EditorView</span></a>, <span class="param">event:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/DOM/event"><span class="type">dom.Event</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Given a set of bindings (using the same format as
keymap, return a keydown
handler that handles them." lang="cn">给定一个按键绑定的集合（和 <a href="#keymap.keymap"><code>keymap</code></a> 使用一样的格式），返回一个处理相应按键事件的 <a href="#view.EditorProps.handleKeyDown">按键
处理函数</a>。</p>
</dd>
</section><section id=part_inputrules>
    <h2 class=module id=inputrules>
      <a href="#inputrules">prosemirror-inputrules <span class=kind>module</span></a>
    </h2>
<p data-en="This module defines a plugin for attaching input rules to an editor,
which can react to or transform text typed by the user. It also comes
with a bunch of default rules that can be enabled in this plugin." lang="cn">本模块定义了一个编辑器插件用来附加 <em>input rules（输入规则）</em>，它可以响应或者转换用户输入的文字。
本模块还带有一些默认的规则，可以通过本插件启用。</p>
<h4 id="inputrules.InputRule">
  <a href="#inputrules.InputRule">InputRule</a> <span class="kind">class</span></h4>
<p data-en="Input rules are regular expressions describing a piece of text
that, when typed, causes something to happen. This might be
changing two dashes into an emdash, wrapping a paragraph starting
with &quot;> &quot; into a blockquote, or something entirely different." lang="cn">输入规则是一些正则表达式，描述了输入何种文本会引起一些额外的变化。这个变化可能是将两个短斜杠变成一个长破折号，或者将以 <code>"&gt; "</code> 开头的段落用 blockquote 包裹着，
亦或者其他完全不一样的事情。</p>
<dl><dt id="inputrules.InputRule.constructor"><code>new <strong><a href="#inputrules.InputRule.constructor">InputRule</a></strong>(<span class="param">match:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><span class="type">RegExp</span></a>, <span class="param">handler:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a> | <span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">match:</span>&nbsp;[<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>], <span class="param">start:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>, <span class="param">end:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number"><span class="prim">number</span></a>) →&nbsp;?⁠<a href="#state.Transaction"><span class="type">Transaction</span></a>)</code></dt>

<dd>
<p data-en="Create an input rule. The rule applies when the user typed
something and the text directly in front of the cursor matches
match, which should end with $." lang="cn">创建一个输入规则。规则会应用到当用户输入一些内容的时候，且直接在光标之前的文本会匹配 <code>match</code> 参数，该参数应该合适的用 <code>$</code> 结尾。</p>

<p data-en="The handler can be a string, in which case the matched text, or
the first matched group in the regexp, is replaced by that
string." lang="cn"><code>handler</code> 参数可以是一个字符串，这种情况下表示匹配的文本，或者在正则中匹配的第一个组，会被该字符串替换。</p>

<p data-en="Or a it can be a function, which will be called with the match
array produced by
RegExp.exec,
as well as the start and end of the matched range, and which can
return a transaction that describes the
rule's effect, or null to indicate the input was not handled." lang="cn">它也可以是一个函数，会将调用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>RegExp.exec</code></a> 后产生的
结果匹配数组传入作为参数来调用，以及匹配的起始和结束的范围。函数返回一个描述了规则影响的 <a href="#state.Transaction">transaction</a>，或者如果输入没有被处理则返回 null。</p>
</dd></dl>
<dt id="inputrules.inputRules"><code><strong><a href="#inputrules.inputRules">inputRules</a></strong>(<span class="param">config:</span>&nbsp;{<span class="prop">rules:&nbsp;</span>[<a href="#inputrules.InputRule"><span class="type">InputRule</span></a>]}) →&nbsp;<a href="#state.Plugin"><span class="type">Plugin</span></a></code></dt>

<dd>
<p data-en="Create an input rules plugin. When enabled, it will cause text
input that matches any of the given rules to trigger the rule's
action." lang="cn">创建一个输入规则插件。启用的话，将会导致与任何给定规则匹配的文本输入都会触发该规则对应的行为。</p>
</dd>
<dt id="inputrules.undoInputRule"><code><strong><a href="#inputrules.undoInputRule">undoInputRule</a></strong>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="This is a command that will undo an input rule, if applying such a
rule was the last thing that the user did." lang="cn">如果应用这个规则是用户做的最后一件事情的话，这是一个可以撤销输入规则的命令。</p>
</dd>

<p data-en="The module comes with a number of predefined rules:" lang="cn">本模块还带有一些预定义的规则：</p>
<dt id="inputrules.emDash"><code><strong><a href="#inputrules.emDash">emDash</a></strong>: <a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="Converts double dashes to an emdash." lang="cn">转换两个短斜杠为一个长破折号的输入规则。</p>
</dd>
<dt id="inputrules.ellipsis"><code><strong><a href="#inputrules.ellipsis">ellipsis</a></strong>: <a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="Converts three dots to an ellipsis character." lang="cn">转换三个点为一个省略号的输入规则。</p>
</dd>
<dt id="inputrules.openDoubleQuote"><code><strong><a href="#inputrules.openDoubleQuote">openDoubleQuote</a></strong>: <a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="“Smart” opening double quotes." lang="cn">「智能」打开双引号的输入规则。</p>
</dd>
<dt id="inputrules.closeDoubleQuote"><code><strong><a href="#inputrules.closeDoubleQuote">closeDoubleQuote</a></strong>: <a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="“Smart” closing double quotes." lang="cn">「智能」关闭双引号的输入规则。</p>
</dd>
<dt id="inputrules.openSingleQuote"><code><strong><a href="#inputrules.openSingleQuote">openSingleQuote</a></strong>: <a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="“Smart” opening single quotes." lang="cn">「智能」打开单引号的输入规则。</p>
</dd>
<dt id="inputrules.closeSingleQuote"><code><strong><a href="#inputrules.closeSingleQuote">closeSingleQuote</a></strong>: <a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="“Smart” closing single quotes." lang="cn">「智能」关闭单引号的输入规则。</p>
</dd>
<dt id="inputrules.smartQuotes"><code><strong><a href="#inputrules.smartQuotes">smartQuotes</a></strong>: [<a href="#inputrules.InputRule"><span class="type">InputRule</span></a>]</code></dt>

<dd>
<p data-en="Smart-quote related input rules." lang="cn">自动打开/关闭 单/双 引号相关的输入规则。</p>
</dd>

<p data-en="These utility functions take schema-specific parameters and create
input rules specific to that schema." lang="cn">下列这些工具函数接受一个特定于 schema 的参数，并创建一个特定于 schema 的输入规则。</p>
<dt id="inputrules.wrappingInputRule"><code><strong><a href="#inputrules.wrappingInputRule">wrappingInputRule</a></strong>(<span class="param">regexp:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><span class="type">RegExp</span></a>, <span class="param">nodeType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">getAttrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a> | <span class="fn">fn</span>([<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>]) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>, <span class="param">joinPredicate:</span>&nbsp;?⁠<span class="fn">fn</span>([<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>], <a href="#model.Node"><span class="type">Node</span></a>) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a>) →&nbsp;<a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="Build an input rule for automatically wrapping a textblock when a
given string is typed. The regexp argument is
directly passed through to the InputRule constructor. You'll
probably want the regexp to start with ^, so that the pattern can
only occur at the start of a textblock." lang="cn">当给定字符串被输入的时候构建一个输入规则以自动包裹一个文本块。<code>regexp</code> 参数被直接传给 <code>InputRule</code> 构造函数。你也许想要正则表达式以 <code>^</code> 开头，
这样的话就只会从一个文本块起始位置开始匹配。</p>
<p type="comment"><span>注: </span><code>^</code> 表示正则中的起始位置匹配，一般用来做类似于 markdown 的输入规则，例如在文本块开头输入 # + 空格后，生成一个 h 元素。</p>

<p data-en="nodeType is the type of node to wrap in. If it needs attributes,
you can either pass them directly, or pass a function that will
compute them from the regular expression match." lang="cn"><code>nodeType</code> 是要被包裹进的节点类型。如果它需要 attributes，那么你既可以直接传入，也可以传入一个计算 attributes 的函数，该函数接受正则匹配的结果作为参数。</p>

<p data-en="By default, if there's a node with the same type above the newly
wrapped node, the rule will try to join those
two nodes. You can pass a join predicate, which takes a regular
expression match and the node before the wrapped node, and can
return a boolean to indicate whether a join should happen." lang="cn">默认情况下，如果有新的包裹节点之前有一个与之相同类型的节点，那么这个规则将会尝试 <a href="#transform.Transform.join">join（连接）</a> 这两个节点。
你可以传递一个连接指示函数，它接受一个正则表达式的结果和在包裹节点之前的节点作为参数，返回一个指示连接是否应该进行的布尔值。</p>
</dd>
<dt id="inputrules.textblockTypeInputRule"><code><strong><a href="#inputrules.textblockTypeInputRule">textblockTypeInputRule</a></strong>(<span class="param">regexp:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><span class="type">RegExp</span></a>, <span class="param">nodeType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">getAttrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a> | <span class="fn">fn</span>([<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>]) →&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<a href="#inputrules.InputRule"><span class="type">InputRule</span></a></code></dt>

<dd>
<p data-en="Build an input rule that changes the type of a textblock when the
matched text is typed into it. You'll usually want to start your
regexp with ^ to that it is only matched at the start of a
textblock. The optional getAttrs parameter can be used to compute
the new node's attributes, and works the same as in the
wrappingInputRule function." lang="cn">构建一个输入规则，以当匹配的文本输入的时候能够改变文本块的类型。你的正则通常应该以 <code>^</code> 开头，这样它就会只匹配文本块的起始位置。
可选参数 <code>getAttrs</code> 可以被用来计算新节点的 attributes，功能和 <code>wrappingInputRule</code> 中的该函数一样。</p>
</dd>
</section><section id=part_gapcursor>
    <h2 class=module id=gapcursor>
      <a href="#gapcursor">prosemirror-gapcursor <span class=kind>module</span></a>
    </h2>
<p data-en="This is a plugin that adds a type of selection for focusing places
that don't allow regular selection (such as positions that have a leaf
block node, table, or the end of the document both before and after
them)." lang="cn">本插件为那些不允许正常选区的聚焦的位置（比如说该位置有叶子节点、表格、或者文档的起始和结尾处）添加一种选区的类型。</p>

<p data-en="You'll probably want to load style/gapcursor.css, which contains
basic styling for the simulated cursor (as a short, blinking
horizontal stripe)." lang="cn">你可能需要加载 <code>style/gapcursor.css</code> 这个文件，它包含了模拟光标的基本样式（即短的，闪烁的水平条纹）。</p>

<p data-en="By default, gap cursor are only allowed in places where the default
content node (in the schema content constraints) is a textblock node.
You can customize this by adding an allowGapCursor property to your
node specs—if it's true, gap cursor are allowed everywhere in that
node, if it's false they are never allowed." lang="cn">默认情况下，gap 光标只允许放置于默认内容节点（通过 schema 的 content 限制）是文本节点的地方。你可以通过在节点配置对象中添加
<code>allowGapCursor</code> 属性来自定义这个行为，如果该值是 true，则 gap 光标被允许放置到该节点的任何位置，如果是 <code>false</code> 则表示永远不允许放置该种类型的光标。</p>
<dt id="gapcursor.gapCursor"><code><strong><a href="#gapcursor.gapCursor">gapCursor</a></strong>() →&nbsp;<a href="#state.Plugin"><span class="type">Plugin</span></a></code></dt>

<dd>
<p data-en="Create a gap cursor plugin. When enabled, this will capture clicks
near and arrow-key-motion past places that don't have a normally
selectable position nearby, and create a gap cursor selection for
them. The cursor is drawn as an element with class
ProseMirror-gapcursor. You can either include
style/gapcursor.css from the package's directory or add your own
styles to make it visible." lang="cn">创建一个 gap 光标插件。如果启用的话，它将会捕获点击区域附近的和方向键经过的不允许有一个正常的可选择区域的地方，然后为它们创建一个 gap 光标选区。
光标元素的类名是 <code>ProseMirror-gapcursor</code>。你既可以从该包中直接引入 <code>style/gapcursor.css</code> 做样式文件，也可以添加你自己的样式以使它可见。</p>
</dd>
<h4 id="gapcursor.GapCursor">
  <a href="#gapcursor.GapCursor">GapCursor</a> <span class="kind">class</span> <span class="extends">extends <code><a href="#state.Selection"><span class="type">Selection</span></a></code></span></h4>
<p data-en="Gap cursor selections are represented using this class. Its
$anchor and $head properties both point at the cursor position." lang="cn">这个类是 Gap 光标选区的表现形式。它的 <code>$anchor</code> 和 <code>$head</code> 属性都指向光标的位置。</p>
<dl></dl>
</section><section id=part_schema-basic>
    <h2 class=module id=schema-basic>
      <a href="#schema-basic">prosemirror-schema-basic <span class=kind>module</span></a>
    </h2>
<p data-en="This module defines a simple schema. You can use it directly, extend
it, or just pick out a few node and mark specs to use in a new schema." lang="cn">本模块定义了一个简单的 schema。你可以直接拿来使用，或者扩展它，亦或者仅仅是抄其中的一些节点和 mark 的配置对象然后应用到新的 schema 中。</p>
<dt id="schema-basic.schema"><code><strong><a href="#schema-basic.schema">schema</a></strong>: <a href="#model.Schema"><span class="type">Schema</span></a></code></dt>

<dd>
<p data-en="This schema roughly corresponds to the document schema used by
CommonMark, minus the list elements,
which are defined in the prosemirror-schema-list
module." lang="cn">该 schema 大致对应于 <a href="http://commonmark.org/">CommonMark</a> 使用的文档 schema，减去在 <a href="#schema-list"><code>prosemirror-schema-list</code></a>
模块中定义的里列表元素。</p>

<p data-en="To reuse elements from this schema, extend or read from its
spec.nodes and spec.marks properties." lang="cn">为了能够从该 schema 中重用元素，可以扩展和读取 <code>spec.nodes</code> 和 <code>spec.marks</code> <a href="#model.Schema.spec">属性</a>。</p>
</dd>
<dt id="schema-basic.nodes"><code><strong><a href="#schema-basic.nodes">nodes</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Specs for the nodes defined in this schema." lang="cn">定义在该 schema 中节点们的 <a href="#model.NodeSpec">Specs（配置对象）</a>。</p>
<dl><dt id="schema-basic.nodes.doc"><code><strong><a href="#schema-basic.nodes.doc">doc</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="The top level document node." lang="cn">文档顶级节点。</p>
</dd><dl><dt id="schema-basic.nodes.paragraph"><code><strong><a href="#schema-basic.nodes.paragraph">paragraph</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A plain paragraph textblock. Represented in the DOM
as a <p> element." lang="cn">普通段落文本块。在 DOM 中表现为一个 <code>&lt;p&gt;</code> 元素。</p>
</dd><dl><dt id="schema-basic.nodes.blockquote"><code><strong><a href="#schema-basic.nodes.blockquote">blockquote</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A blockquote (<blockquote>) wrapping one or more blocks." lang="cn">一个引用块（<code>&lt;blockquote&gt;</code>）包裹一个或者多个块级节点。</p>
</dd><dl><dt id="schema-basic.nodes.horizontal_rule"><code><strong><a href="#schema-basic.nodes.horizontal_rule">horizontal_rule</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A horizontal rule (<hr>)." lang="cn">水平分隔线（<code>&lt;hr&gt;</code>）。</p>
</dd><dl><dt id="schema-basic.nodes.heading"><code><strong><a href="#schema-basic.nodes.heading">heading</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A heading textblock, with a level attribute that
should hold the number 1 to 6. Parsed and serialized as <h1> to
<h6> elements." lang="cn">标题文本块，带有一个 <code>level</code> 属性，该属性的值应该在 1 到 6 的范围。会被格式化和序列化为 <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code> 元素。</p>
</dd><dl><dt id="schema-basic.nodes.code_block"><code><strong><a href="#schema-basic.nodes.code_block">code_block</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A code listing. Disallows marks or non-text inline
nodes by default. Represented as a <pre> element with a
<code> element inside of it." lang="cn">代码块。默认情况下不允许 marks 和非文本行内节点。表现为一个包裹着 <code>&lt;code&gt;</code> 元素的 <code>&lt;pre&gt;</code> 元素。</p>
</dd><dl><dt id="schema-basic.nodes.text"><code><strong><a href="#schema-basic.nodes.text">text</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="The text node." lang="cn">文本节点。</p>
</dd><dl><dt id="schema-basic.nodes.image"><code><strong><a href="#schema-basic.nodes.image">image</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="An inline image (<img>) node. Supports src,
alt, and href attributes. The latter two default to the empty
string." lang="cn">行内图片节点。支持 <code>src</code>、<code>alt</code> 和 <code>href</code> 属性。后两者默认的值是空字符串。</p>
</dd><dl><dt id="schema-basic.nodes.hard_break"><code><strong><a href="#schema-basic.nodes.hard_break">hard_break</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A hard line break, represented in the DOM as <br>." lang="cn">强制换行符，在 DOM 中表示为 <code>&lt;br&gt;</code> 元素。</p>
</dd></dl></dl></dl></dl></dl></dl></dl></dl></dl></dd>
<dt id="schema-basic.marks"><code><strong><a href="#schema-basic.marks">marks</a></strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a></code></dt>

<dd>
<p data-en="Specs for the marks in the schema." lang="cn">schema 中 marks 们的 <a href="#model.MarkSpec">Specs（配置对象）</a></p>
<dl><dt id="schema-basic.marks.link"><code><strong><a href="#schema-basic.marks.link">link</a></strong>: <a href="#model.MarkSpec"><span class="type">MarkSpec</span></a></code></dt>

<dd>
<p data-en="A link. Has href and title attributes. title
defaults to the empty string. Rendered and parsed as an <a>
element." lang="cn">链接。有 <code>href</code> 和 <code>title</code> 属性。<code>title</code> 默认是空字符串。会被渲染和格式化为一个 <code>&lt;a&gt;</code> 元素。</p>
</dd><dl><dt id="schema-basic.marks.em"><code><strong><a href="#schema-basic.marks.em">em</a></strong>: <a href="#model.MarkSpec"><span class="type">MarkSpec</span></a></code></dt>

<dd>
<p data-en="An emphasis mark. Rendered as an <em> element.
Has parse rules that also match <i> and font-style: italic." lang="cn">强调。渲染为一个 <code>&lt;em&gt;</code> 元素，格式化规则同样匹配 <code>&lt;i&gt;</code> 和 <code>font-style: italic</code>。</p>
<p type="comment"><span>注: </span>这里可能是 em 加粗，或者 i/font-style: italic 斜体。</p>
<p type="comment"><span>注: </span>「font-style: italic」写法中，样式名的冒号后面的空格要保持统一，要么都有，要么都无。</p>
</dd><dl><dt id="schema-basic.marks.strong"><code><strong><a href="#schema-basic.marks.strong">strong</a></strong>: <a href="#model.MarkSpec"><span class="type">MarkSpec</span></a></code></dt>

<dd>
<p data-en="A strong mark. Rendered as <strong>, parse rules
also match <b> and font-weight: bold." lang="cn">加粗。渲染为 <code>&lt;strong&gt;</code>，格式化规则同样匹配 <code>&lt;b&gt;</code> 和 <code>font-weight: bold</code>。</p>
</dd><dl><dt id="schema-basic.marks.code"><code><strong><a href="#schema-basic.marks.code">code</a></strong>: <a href="#model.MarkSpec"><span class="type">MarkSpec</span></a></code></dt>

<dd>
<p data-en="Code font mark. Represented as a <code> element." lang="cn">行内代码。表现为 <code>&lt;code&gt;</code> 元素。</p>
</dd></dl></dl></dl></dl></dd>
</section><section id=part_schema-list>
    <h2 class=module id=schema-list>
      <a href="#schema-list">prosemirror-schema-list <span class=kind>module</span></a>
    </h2>
<p data-en="This module exports list-related schema elements and commands. The
commands assume lists to be nestable, with the restriction that the
first child of a list item is a plain paragraph." lang="cn">本模块导出了列表相关的 schema 元素和命令。命令假设列表是可以被嵌套的，以及限制列表项的第一个元素必须为普通段落元素。</p>

<p data-en="These are the node specs:" lang="cn">下面这些是节点配置对象：</p>
<dt id="schema-list.orderedList"><code><strong><a href="#schema-list.orderedList">orderedList</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="An ordered list node spec. Has a single
attribute, order, which determines the number at which the list
starts counting, and defaults to 1. Represented as an <ol>
element." lang="cn">一个有序列表的 <a href="#model.NodeSpec">节点配置对象</a>。有一个唯一的属性 <code>order</code>，它决定了列表从哪个数字开始计数，默认是 1。
表现形式是一个 <code>&lt;ol&gt;</code> 元素。</p>
</dd>
<dt id="schema-list.bulletList"><code><strong><a href="#schema-list.bulletList">bulletList</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A bullet list node spec, represented in the DOM as <ul>." lang="cn">一个无序列表的节点配置对象，DOM 表示为 <code>&lt;ul&gt;</code>。</p>
</dd>
<dt id="schema-list.listItem"><code><strong><a href="#schema-list.listItem">listItem</a></strong>: <a href="#model.NodeSpec"><span class="type">NodeSpec</span></a></code></dt>

<dd>
<p data-en="A list item (<li>) spec." lang="cn">列表项（<code>&lt;li&gt;</code>）的配置对象。</p>
<p type="comment"><span>注: </span><code>li</code> 父节点可以是 <code>ol</code> 也可以是 <code>ul</code>，高级用法还可以扩展为 <code>todo</code>。</p>
</dd>
<dt id="schema-list.addListNodes"><code><strong><a href="#schema-list.addListNodes">addListNodes</a></strong>(<span class="param">nodes:</span>&nbsp;<a href="https://github.com/marijnh/orderedmap#readme"><span class="type">OrderedMap</span></a>&lt;<a href="#model.NodeSpec"><span class="type">NodeSpec</span></a>&gt;, <span class="param">itemContent:</span>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>, <span class="param">listGroup:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"><span class="prim">string</span></a>) →&nbsp;<a href="https://github.com/marijnh/orderedmap#readme"><span class="type">OrderedMap</span></a>&lt;<a href="#model.NodeSpec"><span class="type">NodeSpec</span></a>&gt;</code></dt>

<dd>
<p data-en="Convenience function for adding list-related node types to a map
specifying the nodes for a schema. Adds
orderedList as &quot;ordered_list&quot;,
bulletList as &quot;bullet_list&quot;, and
listItem as &quot;list_item&quot;." lang="cn">为 schema 方便的添加列表相关的节点类型到一个特定的节点类型的函数。<a href="#schema-list.orderedList"><code>orderedList</code></a> 表示为 <code>"ordered_list"</code>，
<a href="#schema-list.bulletList"><code>bulletList</code></a> 表示为 <code>"bullet_list"</code>， 以及
<a href="#schema-list.listItem"><code>listItem</code></a> 表示为 <code>"list_item"</code>。</p>

<p data-en="itemContent determines the content expression for the list items.
If you want the commands defined in this module to apply to your
list structure, it should have a shape like &quot;paragraph block*&quot; or
&quot;paragraph (ordered_list | bullet_list)*&quot;. listGroup can be
given to assign a group name to the list node types, for example
&quot;block&quot;." lang="cn"><code>itemContent</code> 决定了列表项的内容表达式。如果你想要在本模块中定义的命令应用于你自己的列表结构，则它的值应该是诸如 <code>"paragraph block*"</code>
或者 <code>"paragraph (ordered_list | bullet_list)*"</code> 之类的。<code>listGroup</code> 可以将列表节点类型分配到一个组名，比如 <code>"block"</code>。</p>
</dd>

<p data-en="Using this would look something like this:" lang="cn">本模块使用方式应该像下面这样：</p>
<pre><code class="language-javascript"><span class="hl-keyword">const</span> <span class="hl-def">mySchema</span> <span class="hl-operator">=</span> <span class="hl-keyword">new</span> <span class="hl-variable">Schema</span>({
  <span class="hl-property">nodes</span>: <span class="hl-variable">addListNodes</span>(<span class="hl-variable">baseSchema</span>.<span class="hl-property">spec</span>.<span class="hl-property">nodes</span>, <span class="hl-string">"paragraph block*"</span>, <span class="hl-string">"block"</span>),
  <span class="hl-property">marks</span>: <span class="hl-variable">baseSchema</span>.<span class="hl-property">spec</span>.<span class="hl-property">marks</span>
})
</code></pre>

<p data-en="The following functions are commands:" lang="cn">下列函数是 <a href="/docs/guide/#commands">命令</a>：</p>
<dt id="schema-list.wrapInList"><code><strong><a href="#schema-list.wrapInList">wrapInList</a></strong>(<span class="param">listType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>, <span class="param">attrs:</span>&nbsp;?⁠<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"><span class="type">Object</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Returns a command function that wraps the selection in a list with
the given type an attributes. If dispatch is null, only return a
value to indicate whether this is possible, but don't actually
perform the change." lang="cn">返回一个命令函数，该函数用给定的类型和属性包裹位于 list 中的选区。如果 <code>dispatch</code> 参数是 null，则只返回一个指示该行为是否可能的值，
而不实际执行修改。</p>
</dd>
<dt id="schema-list.splitListItem"><code><strong><a href="#schema-list.splitListItem">splitListItem</a></strong>(<span class="param">itemType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Build a command that splits a non-empty textblock at the top level
of a list item by also splitting that list item." lang="cn">构建一个命令，它会通过分割列表项的直接子元素的非空文本节点的方式来分割一个列表项。</p>
</dd>
<dt id="schema-list.liftListItem"><code><strong><a href="#schema-list.liftListItem">liftListItem</a></strong>(<span class="param">itemType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Create a command to lift the list item around the selection up into
a wrapping list." lang="cn">创建一个命令，该命令会提升选区所在的列表项到上一级列表中。</p>
</dd>
<dt id="schema-list.sinkListItem"><code><strong><a href="#schema-list.sinkListItem">sinkListItem</a></strong>(<span class="param">itemType:</span>&nbsp;<a href="#model.NodeType"><span class="type">NodeType</span></a>) →&nbsp;<span class="fn">fn</span>(<span class="param">state:</span>&nbsp;<a href="#state.EditorState"><span class="type">EditorState</span></a>, <span class="param">dispatch:</span>&nbsp;?⁠<span class="fn">fn</span>(<span class="param">tr:</span>&nbsp;<a href="#state.Transaction"><span class="type">Transaction</span></a>)) →&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><span class="prim">bool</span></a></code></dt>

<dd>
<p data-en="Create a command to sink the list item around the selection down
into an inner list." lang="cn">创建一个命令，该命令会将选区所在的列表项缩进到一个内部列表中去。</p>
</dd>
</section></article>

<footer>
  <nav>
    <a class=logo href=".">ProseMirror</a>
    <div class=navlinks>
      <a href="/backers.html">支持者</a>
      <a href="http://contributor-covenant.org/version/1/1/0/">代码贡献公约</a>
      <a href="https://discuss.prosemirror.net/">官方论坛</a>
      <a href="https://github.com/prosemirror/prosemirror/issues">报告错误</a>
      <a href="https://github.com/xheldon-prosemirror/prosemirror/issues">报告翻译错误</a>
    </div>
  </nav>
</footer>

</html><script>
  // 显示汉化完成度（粗略估算），待真正完成时移除该代码
  try {
    var a = 0;
    [...document.getElementsByTagName('article')[0].getElementsByTagName('p')].forEach((p) => {
      if (/[\u4e00-\u9fa5]/g.test(p.innerText)) a = p;
    });
    var complete = `${((a.offsetTop / document.body.offsetHeight).toFixed(2) * 100)}%`;
    var frag = document.createDocumentFragment();
    var div = document.createElement('div');
    div.style = `
      position: fixed;
      right: -50px;
      top: -50px;
      width: 40px;
      text-align: start;
      height: 40px;
      display: block;
      border-style: solid;
      border-width: 30px;
      border-color: transparent transparent black;
      transform: rotate(45deg);
      font-family: none;
      font-size: 13px;
    `;  
    var a = document.createElement('a');
    a.href = 'https://github.com/xheldon-prosemirror/prosemirror';
    a.style = `
      top: 48px;
      left: -5px;
      position: absolute;
      color: white;
      white-space: nowrap;
      letter-spacing: 1px;
    `;
    a.target = '_blank';
    a.innerText = `翻译:${complete}`;
    div.appendChild(a);
    frag.appendChild(div);
    document.body.appendChild(frag);
    
  } catch (e) {console.log('汉化进度统计出错:', e)}
</script>